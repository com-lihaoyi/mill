= MiMa

Port of the https://github.com/lightbend/mima[MiMa Sbt Plugin]

== Getting Started

After importing it in the `+build.sc+` file:

[source,scala]
----
import $ivy.`com.github.lolgab::mill-mima::x.y.z`
import com.github.lolgab.mill.mima._
----

this plugin can be mixed in a `+ScalaModule with PublishModule+`
defining the `+mimaPreviousVersions+`:

[source,scala]
----
object module extends ScalaModule with PublishModule with Mima {
  def mimaPreviousVersions = Seq("1.0.0", "1.5.0")

  // ... other settings
}
----

== Configuration

=== mimaCheckDirection

The required direction of binary compatibility can be set in two ways:

* By setting the `+MIMA_CHECK_DIRECTION+` environment variable when
running Mill
+
....
MIMA_CHECK_DIRECTION=forward mill __.mimaReportBinaryIssues
....
+
The possible values are `+backward+` (default), `+forward+` and
`+both+`.
+
This is useful when you want to check for different directions at the
same time, for example when you might want to have separate CI checks
for forward and backward compatibility to evaluate if changes introduce
source compatibilities.
* By overriding `+mimaCheckDirection+`:
+
[source,scala]
----
override def mimaCheckDirection = CheckDirection.Both
----
+
The possible values are `+CheckDirection.Backward+` (default),
`+CheckDirection/Forward+` and `+CheckDirection.Both+`.
+
This is useful when the setting is static and you want to keep the
setting in your `+build.sc+` file.

=== mimaBinaryIssueFilters

When MiMa reports a binary incompatibility that you consider acceptable,
such as a change in an internal package, you need to use the
`+mimaBinaryIssueFilters+` setting to filter it out and get
`+mimaReportBinaryIssues+` to pass, like so:

[source,scala]
----
import com.github.lolgab.mill.mima._

object mylibrary extends ScalaModule with PublishModule with Mima {
  override def mimaBinaryIssueFilters = super.mimaBinaryIssueFilters() ++ Seq(
    ProblemFilter.exclude[MissingClassProblem]("com.example.mylibrary.internal.Foo")
  )

  // ... other settings
}
----

You may also use wildcards in the package and/or the top `+Problem+`
parent type for such situations:

[source,scala]
----
import com.github.lolgab.mill.mima._

override def mimaBinaryIssueFilters = super.mimaBinaryIssueFilters() ++ Seq(
  ProblemFilter.exclude[MissingClassProblem]("com.example.mylibrary.internal.*")
)
----

=== mimaExcludeAnnotations

The fully-qualified class names of annotations that exclude parts of the
API from problem checking.

[source,scala]
----
import com.github.lolgab.mill.mima._

object mylibrary extends ScalaModule with PublishModule with Mima {
  override def mimaExcludeAnnotations = Seq(
    Seq("mima.annotation.exclude")
  )
  // ... other settings
}
----

=== mimaPreviousArtifacts

If your previous artifacts have a different `+groupId+` or
`+artifactId+` you can check against them using
`+mimaPreviousArtifacts+` instead of `+millPreviousVersions+` (since
`+millPreviousVersions+` assumes the same `+groupId+` and
`+artifactId+`):

[source,scala]
----
def mimaPreviousArtifacts = Agg(
  ivy"my_group_id::module:my_previous_version"
)
----

=== mimaBackwardIssueFilters

Filters to apply to binary issues found grouped by version of a module
checked against. These filters only apply to backward compatibility
checking.

Signature:

[source,scala]
----
def mimaBackwardIssueFilters: Target[Map[String, Seq[ProblemFilter]]]
----

=== mimaForwardIssueFilters

Filters to apply to binary issues found grouped by version of a module
checked against. These filters only apply to forward compatibility
checking.

Signature:

[source,scala]
----
def mimaForwardIssueFilters: Target[Map[String, Seq[ProblemFilter]]]
----

=== IncompatibleSignatureProblem

Most MiMa checks (`+DirectMissingMethod+`,`+IncompatibleResultType+`,
`+IncompatibleMethType+`, etc) are against the "`method descriptor`",
which is the "`raw`" type signature, without any information about
generic parameters.

The `+IncompatibleSignature+` check compares the `+Signature+`, which
includes the full signature including generic parameters. This can catch
real incompatibilities, but also sometimes triggers for a change in
generics that would not in fact cause problems at run time. Notably, it
will warn when updating your project to scala 2.12.9+ or 2.13.1+, see
https://github.com/lightbend/mima/issues/423[this issue] for details.

You can opt-in to this check by setting:

[source,scala]
----
def mimaReportSignatureProblems = true
----
