package build.contrib
// imports
import scala.util.chaining._
import coursier.maven.MavenRepository
import mill._
import mill.api.JarManifest
import mill.main.Tasks
import mill.scalalib._
import mill.scalalib.api.ZincWorkerUtil
import mill.scalalib.publish._
import mill.util.Jvm
import mill.resolve.SelectMode
import mill.contrib.buildinfo.BuildInfo
import mill.T
import mill.define.Cross
import millbuild._


// plugins and dependencies
import $meta._

/**
 * [[build.contrib]] contains user-contributed Mill plugins that satisfy
 * a range of use cases not covered by the core Mill builtins. `contrib`
 * modules are typically less polished than builtins in [[build.javalib]]
 * or [[build.scalalib]], and do not offer binary or source compatibility
 * guarantees between Mill versions, but provide a place for the community
 * to collaborate on Mill plugins that is more discoverable than individuals
 * hosting their own Github repositories
 */
object `package` extends RootModule {
  def contribModules: Seq[ContribModule] =
    millInternal.modules.collect { case m: ContribModule => m }

  trait ContribModule extends MillPublishScalaModule {
    def readme = Task.Source(millSourcePath / "readme.adoc")
  }

  object testng extends JavaModule with ContribModule {

    def testTransitiveDeps =
      super.testTransitiveDeps() ++
        Seq(
          build.scalalib.testDep(),
          build.scalalib.worker.testDep(),
          build.testrunner.entrypoint.testDep()
        )

    // pure Java implementation
    def artifactSuffix: T[String] = ""
    def scalaLibraryIvyDeps: T[Agg[Dep]] = Task { Agg.empty[Dep] }
    def ivyDeps = Agg(Deps.sbtTestInterface)
    def compileIvyDeps = Agg(Deps.testng)
    def runIvyDeps = Agg(Deps.testng)
    def testModuleDeps: Seq[JavaModule] = super.testModuleDeps ++ Seq(build.scalalib)
    def docJar: T[PathRef] = super[JavaModule].docJar
  }

  object twirllib extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def testModuleDeps: Seq[JavaModule] = super.testModuleDeps ++ Seq(build.scalalib)
  }

  object playlib extends ContribModule {
    def moduleDeps = Seq(twirllib, playlib.api)
    def compileModuleDeps = Seq(build.scalalib)

    def testTransitiveDeps =
      super.testTransitiveDeps() ++ Task.traverse(Deps.play.keys.toSeq)(worker(_).testDep)()

    def testArgs = Task {
      super.testArgs() ++
        Seq(
          s"-DTEST_PLAY_VERSION_2_6=${Deps.Play_2_6.playVersion}",
          s"-DTEST_PLAY_VERSION_2_7=${Deps.Play_2_7.playVersion}",
          s"-DTEST_PLAY_VERSION_2_8=${Deps.Play_2_8.playVersion}",
          s"-DTEST_PLAY_VERSION_2_9=${Deps.Play_2_9.playVersion}",
          s"-DTEST_PLAY_VERSION_3_0=${Deps.Play_3_0.playVersion}"
        )
    }

    def testModuleDeps: Seq[JavaModule] = super.testModuleDeps ++ Seq(build.scalalib)

    object api extends MillPublishJavaModule

    object worker extends Cross[WorkerModule](Deps.play.keys.toSeq)
    trait WorkerModule extends MillPublishScalaModule with Cross.Module[String] {
      def playBinary = crossValue
      def millSourcePath: os.Path = super.millSourcePath / playBinary

      def sharedSources = Task.Sources(millSourcePath / os.up / "src-shared")
      def sources = Task {
        // We want to avoid duplicating code as long as the Play APIs allow.
        // But if newer Play versions introduce incompatibilities,
        // just remove the shared source dir for that worker and implement directly.
        sharedSources() ++ super.sources()
      }

      def scalaVersion = Deps.play(playBinary).scalaVersion
      def moduleDeps = Seq(playlib.api)
      def ivyDeps = Agg(Deps.osLib, Deps.play(playBinary).routesCompiler)
    }
  }

  object scalapblib extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def testModuleDeps = super.testModuleDeps ++ Seq(build.scalalib)
  }

  object scoverage extends ContribModule {
    object api extends MillPublishJavaModule

    def moduleDeps = Seq(scoverage.api)
    def compileModuleDeps = Seq(build.scalalib)

    def testTransitiveDeps =
      super.testTransitiveDeps() ++ Seq(worker2.testDep())

    def testArgs = Task {
      super.testArgs() ++
        Seq(
          s"-DMILL_SCOVERAGE2_VERSION=${Deps.scalacScoverage2Plugin.version}"
        )
    }

    // So we can test with buildinfo in the classpath
    def testModuleDeps =
      super.testModuleDeps ++
        Seq(build.scalalib, build.scalajslib, build.scalanativelib, build.contrib.buildinfo)

    // Worker for Scoverage 2.0
    object worker2 extends MillPublishScalaModule {
      def testDepPaths = Task { Seq(compile().classes) }
      def compileModuleDeps = Seq(
        build.core.api,
        scoverage.api
      )
      def compileIvyDeps = Task {
        super.mandatoryIvyDeps() ++ Agg(
          // compile-time only, need to provide the correct scoverage version at runtime
          Deps.scalacScoverage2Reporter,
          Deps.scalacScoverage2Domain,
          Deps.scalacScoverage2Serializer
        ) ++ when(!ZincWorkerUtil.isScala3(scalaVersion()))(Deps.scalacScoverage2Plugin)
      }
      def mandatoryIvyDeps = Agg.empty[Dep]
    }
  }

  object buildinfo extends ContribModule {
    def compileModuleDeps =
      Seq(build.scalalib, build.scalajslib, build.scalanativelib, build.kotlinlib)
    def testModuleDeps =
      super.testModuleDeps ++ Seq(
        build.scalalib,
        build.scalajslib,
        build.scalanativelib,
        build.kotlinlib
      )
  }

  object proguard extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def testModuleDeps = super.testModuleDeps ++ Seq(build.scalalib)
  }

  object flyway extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def ivyDeps = Agg(Deps.flywayCore)
    def testModuleDeps = super.testModuleDeps ++ Seq(build.scalalib)
  }

  object docker extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def testModuleDeps = super.testModuleDeps ++ Seq(build.scalalib)
  }

  object bloop extends ContribModule with BuildInfo {
    def compileModuleDeps = Seq(build.scalalib, build.scalajslib, build.scalanativelib)
    def ivyDeps = Agg(Deps.bloopConfig.exclude("*" -> s"jsoniter-scala-core_2.13"))
    def testModuleDeps = super.testModuleDeps ++ Seq(
      build.scalalib,
      build.scalajslib,
      build.scalanativelib
    )

    def buildInfoPackageName = "mill.contrib.bloop"
    def buildInfoObjectName = "Versions"
    def buildInfoMembers = Seq(BuildInfo.Value("bloop", Deps.bloopConfig.version))
  }

  object artifactory extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def ivyDeps = Agg(Deps.requests)
  }

  object codeartifact extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def ivyDeps = Agg(Deps.requests)
  }

  object sonatypecentral extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def ivyDeps = Agg(Deps.sonatypeCentralClient)
  }

  object versionfile extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
  }

  object bintray extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def ivyDeps = Agg(Deps.requests)
  }

  object gitlab extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def ivyDeps = Agg(Deps.requests, Deps.osLib)
    def testModuleDeps = super.testModuleDeps ++ Seq(build.scalalib)
  }

  object jmh extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def testModuleDeps = super.testModuleDeps ++ Seq(build.scalalib)
  }
}
