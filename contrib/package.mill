package build.contrib
// imports
import scala.util.chaining._
import com.github.lolgab.mill.mima.Mima
import coursier.maven.MavenRepository
import de.tobiasroeser.mill.vcs.version.VcsVersion
import com.goyeau.mill.scalafix.ScalafixModule
import mill._
import mill.api.JarManifest
import mill.main.Tasks
import mill.scalalib._
import mill.scalalib.api.ZincWorkerUtil
import mill.scalalib.publish._
import mill.util.Jvm
import mill.resolve.SelectMode
import mill.contrib.buildinfo.BuildInfo
import mill.T
import mill.define.Cross
import build.Deps

// plugins and dependencies
import $meta._
import $file.ci.shared
import $file.ci.upload

object `package` extends RootModule {
  def contribModules: Seq[ContribModule] =
    millInternal.modules.collect { case m: ContribModule => m }

  trait ContribModule extends build.MillPublishScalaModule {
    def readme = T.source(millSourcePath / "readme.adoc")
  }

  object testng extends JavaModule with ContribModule {

    def testTransitiveDeps =
      super.testTransitiveDeps() ++
        Seq(
          build.scalalib.testDep(),
          build.scalalib.worker.testDep(),
          build.testrunner.entrypoint.testDep()
        )

    // pure Java implementation
    def artifactSuffix: T[String] = ""
    def scalaLibraryIvyDeps: T[Agg[Dep]] = Task { Agg.empty[Dep] }
    def ivyDeps = Agg(build.Deps.sbtTestInterface)
    def compileIvyDeps = Agg(build.Deps.testng)
    def runIvyDeps = Agg(build.Deps.testng)
    def testModuleDeps: Seq[JavaModule] = super.testModuleDeps ++ Seq(build.scalalib)
    def docJar: T[PathRef] = super[JavaModule].docJar
  }

  object twirllib extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def testModuleDeps: Seq[JavaModule] = super.testModuleDeps ++ Seq(build.scalalib)
  }

  object playlib extends ContribModule {
    def moduleDeps = Seq(twirllib, playlib.api)
    def compileModuleDeps = Seq(build.scalalib)

    def testTransitiveDeps =
      super.testTransitiveDeps() ++ T.traverse(build.Deps.play.keys.toSeq)(worker(_).testDep)()

    def testArgs = Task {
      super.testArgs() ++
        Seq(
          s"-DTEST_PLAY_VERSION_2_6=${build.Deps.Play_2_6.playVersion}",
          s"-DTEST_PLAY_VERSION_2_7=${build.Deps.Play_2_7.playVersion}",
          s"-DTEST_PLAY_VERSION_2_8=${build.Deps.Play_2_8.playVersion}",
          s"-DTEST_PLAY_VERSION_2_9=${build.Deps.Play_2_9.playVersion}",
          s"-DTEST_PLAY_VERSION_3_0=${build.Deps.Play_3_0.playVersion}"
        )
    }

    def testModuleDeps: Seq[JavaModule] = super.testModuleDeps ++ Seq(build.scalalib)

    object api extends build.MillPublishJavaModule

    object worker extends Cross[WorkerModule](build.Deps.play.keys.toSeq)
    trait WorkerModule extends build.MillPublishScalaModule with Cross.Module[String] {
      def playBinary = crossValue
      def millSourcePath: os.Path = super.millSourcePath / playBinary

      def sources = T.sources {
        // We want to avoid duplicating code as long as the Play APIs allow.
        // But if newer Play versions introduce incompatibilities,
        // just remove the shared source dir for that worker and implement directly.
        Seq(PathRef(millSourcePath / os.up / "src-shared")) ++ super.sources()
      }

      def scalaVersion = build.Deps.play(playBinary).scalaVersion
      def moduleDeps = Seq(playlib.api)
      def ivyDeps = Agg(build.Deps.osLib, build.Deps.play(playBinary).routesCompiler)
    }
  }

  object scalapblib extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def testModuleDeps = super.testModuleDeps ++ Seq(build.scalalib)
  }

  object scoverage extends ContribModule {
    object api extends build.MillPublishScalaModule {
      def compileModuleDeps = Seq(build.main.api)
    }

    def moduleDeps = Seq(scoverage.api)
    def compileModuleDeps = Seq(build.scalalib)

    def testTransitiveDeps =
      super.testTransitiveDeps() ++ Seq(worker2.testDep())

    def testArgs = Task {
      super.testArgs() ++
        Seq(
          s"-DMILL_SCOVERAGE2_VERSION=${build.Deps.scalacScoverage2Plugin.dep.version}",
        )
    }

    // So we can test with buildinfo in the classpath
    def testModuleDeps =
      super.testModuleDeps ++
        Seq(build.scalalib, build.scalajslib, build.scalanativelib, build.contrib.buildinfo)

    // Worker for Scoverage 2.0
    object worker2 extends build.MillPublishScalaModule {
      def compileModuleDeps = Seq(build.main.api)
      def moduleDeps = Seq(scoverage.api)
      def testDepPaths = Task { Seq(compile().classes) }
      def compileIvyDeps = Task {
        Agg(
          // compile-time only, need to provide the correct scoverage version at runtime
          build.Deps.scalacScoverage2Plugin,
          build.Deps.scalacScoverage2Reporter,
          build.Deps.scalacScoverage2Domain,
          build.Deps.scalacScoverage2Serializer
        )
      }
    }
  }

  object buildinfo extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib, build.scalajslib, build.scalanativelib)
    def testModuleDeps =
      super.testModuleDeps ++ Seq(build.scalalib, build.scalajslib, build.scalanativelib)
  }

  object proguard extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def testModuleDeps = super.testModuleDeps ++ Seq(build.scalalib)
  }

  object flyway extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def ivyDeps = Agg(build.Deps.flywayCore)
    def testModuleDeps = super.testModuleDeps ++ Seq(build.scalalib)
  }

  object docker extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def testModuleDeps = super.testModuleDeps ++ Seq(build.scalalib)
  }

  object bloop extends ContribModule with BuildInfo {
    def compileModuleDeps = Seq(build.scalalib, build.scalajslib, build.scalanativelib)
    def ivyDeps = Agg(build.Deps.bloopConfig.exclude("*" -> s"jsoniter-scala-core_2.13"))
    def testModuleDeps = super.testModuleDeps ++ Seq(
      build.scalalib,
      build.scalajslib,
      build.scalanativelib
    )

    def buildInfoPackageName = "mill.contrib.bloop"
    def buildInfoObjectName = "Versions"
    def buildInfoMembers = Seq(BuildInfo.Value("bloop", build.Deps.bloopConfig.dep.version))
  }

  object artifactory extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def ivyDeps = Agg(build.Deps.requests)
  }

  object codeartifact extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def ivyDeps = Agg(build.Deps.requests)
  }

  object sonatypecentral extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def ivyDeps = Agg(build.Deps.sonatypeCentralClient)
  }

  object versionfile extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
  }

  object bintray extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def ivyDeps = Agg(build.Deps.requests)
  }

  object gitlab extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def ivyDeps = Agg(build.Deps.requests, build.Deps.osLib)
    def testModuleDeps = super.testModuleDeps ++ Seq(build.scalalib)
  }

  object jmh extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def testModuleDeps = super.testModuleDeps ++ Seq(build.scalalib)
  }
}
