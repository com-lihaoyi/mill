package build.contrib
// imports
import scala.util.chaining._
import coursier.maven.MavenRepository
import mill._
import mill.main.Tasks
import mill.scalalib._
import mill.scalalib.api.ZincWorkerUtil
import mill.scalalib.publish._
import mill.util.Jvm
import mill.define.SelectMode
import mill.contrib.buildinfo.BuildInfo
import mill.T
import mill.define.Cross
import build.Deps

// plugins and dependencies
import $meta._

/**
 * [[build.contrib]] contains user-contributed Mill plugins that satisfy
 * a range of use cases not covered by the core Mill builtins. `contrib`
 * modules are typically less polished than builtins in [[build.javalib]]
 * or [[build.scalalib]], and do not offer binary or source compatibility
 * guarantees between Mill versions, but provide a place for the community
 * to collaborate on Mill plugins that is more discoverable than individuals
 * hosting their own Github repositories
 */
object `package` extends RootModule {
  def contribModules: Seq[ContribModule] =
    moduleInternal.modules.collect { case m: ContribModule => m }

  trait ContribModule extends build.MillPublishScalaModule {
    def readme = Task.Source(moduleDir / "readme.adoc")
  }

  object testng extends JavaModule with ContribModule {

    def testTransitiveDeps =
      super.testTransitiveDeps() ++
        Seq(
          build.scalalib.testDep(),
          build.scalalib.worker.testDep(),
          build.testrunner.entrypoint.testDep()
        )

    // pure Java implementation
    def artifactSuffix: T[String] = ""
    def scalaLibraryIvyDeps: T[Agg[Dep]] = Task { Agg.empty[Dep] }
    def ivyDeps = Agg(build.Deps.sbtTestInterface)
    def compileIvyDeps = Agg(build.Deps.testng)
    def runIvyDeps = Agg(build.Deps.testng)
    def testModuleDeps: Seq[JavaModule] = super.testModuleDeps ++ Seq(build.scalalib)
    def docJar: T[PathRef] = super[JavaModule].docJar
  }

  object twirllib extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def testModuleDeps: Seq[JavaModule] = super.testModuleDeps ++ Seq(build.scalalib)
  }

  object playlib extends ContribModule {
    def moduleDeps = Seq(twirllib, playlib.api)
    def compileModuleDeps = Seq(build.scalalib)

    def testTransitiveDeps =
      super.testTransitiveDeps() ++ Task.traverse(build.Deps.play.keys.toSeq)(worker(_).testDep)()

    def testArgs = Task {
      super.testArgs() ++
        Seq(
          s"-DTEST_PLAY_VERSION_2_6=${build.Deps.Play_2_6.playVersion}",
          s"-DTEST_PLAY_VERSION_2_7=${build.Deps.Play_2_7.playVersion}",
          s"-DTEST_PLAY_VERSION_2_8=${build.Deps.Play_2_8.playVersion}",
          s"-DTEST_PLAY_VERSION_2_9=${build.Deps.Play_2_9.playVersion}",
          s"-DTEST_PLAY_VERSION_3_0=${build.Deps.Play_3_0.playVersion}"
        )
    }

    def testModuleDeps: Seq[JavaModule] = super.testModuleDeps ++ Seq(build.scalalib)

    object api extends build.MillPublishJavaModule

    object worker extends Cross[WorkerModule](build.Deps.play.keys.toSeq)
    trait WorkerModule extends build.MillPublishScalaModule with Cross.Module[String] {
      def playBinary = crossValue
      def moduleDir: os.Path = super.moduleDir / playBinary

      def sources = Task.Sources {
        // We want to avoid duplicating code as long as the Play APIs allow.
        // But if newer Play versions introduce incompatibilities,
        // just remove the shared source dir for that worker and implement directly.
        Seq(PathRef(moduleDir / os.up / "src-shared")) ++ super.sources()
      }

      def scalaVersion = build.Deps.play(playBinary).scalaVersion
      def moduleDeps = Seq(playlib.api)
      def ivyDeps = Agg(build.Deps.osLib, build.Deps.play(playBinary).routesCompiler)
    }
  }

  object scalapblib extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def testModuleDeps = super.testModuleDeps ++ Seq(build.scalalib)
  }

  object scoverage extends ContribModule {
    object api extends build.MillPublishJavaModule

    def moduleDeps = Seq(scoverage.api)
    def compileModuleDeps = Seq(build.scalalib)

    def testTransitiveDeps =
      super.testTransitiveDeps() ++ Seq(worker2.testDep())

    def testArgs = Task {
      super.testArgs() ++
        Seq(
          s"-DMILL_SCOVERAGE2_VERSION=${build.Deps.scalacScoverage2Plugin.dep.version}"
        )
    }

    // So we can test with buildinfo in the classpath
    def testModuleDeps =
      super.testModuleDeps ++
        Seq(build.scalalib, build.scalajslib, build.scalanativelib, build.contrib.buildinfo)

    // Worker for Scoverage 2.0
    object worker2 extends build.MillPublishScalaModule {
      def testDepPaths = Task { Seq(compile().classes) }
      def compileModuleDeps = Seq(
        build.core.api,
        scoverage.api
      )
      def compileIvyDeps = Task {
        super.mandatoryIvyDeps() ++ Agg(
          // compile-time only, need to provide the correct scoverage version at runtime
          build.Deps.scalacScoverage2Reporter,
          build.Deps.scalacScoverage2Domain,
          build.Deps.scalacScoverage2Serializer
        ) ++ Option.when(!ZincWorkerUtil.isScala3(scalaVersion()))(build.Deps.scalacScoverage2Plugin)
      }
      def mandatoryIvyDeps = Agg.empty[Dep]
    }
  }

  object buildinfo extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib, build.scalajslib, build.scalanativelib)
    def testModuleDeps =
      super.testModuleDeps ++ Seq(build.scalalib, build.scalajslib, build.scalanativelib)
  }

  object proguard extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def testModuleDeps = super.testModuleDeps ++ Seq(build.scalalib)
  }

  object flyway extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def ivyDeps = Agg(build.Deps.flywayCore)
    def testModuleDeps = super.testModuleDeps ++ Seq(build.scalalib)
  }

  object docker extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def testModuleDeps = super.testModuleDeps ++ Seq(build.scalalib)
  }

  object bloop extends ContribModule with BuildInfo {
    def compileModuleDeps = Seq(build.scalalib, build.scalajslib, build.scalanativelib)
    def ivyDeps = Agg(build.Deps.bloopConfig.exclude("*" -> s"jsoniter-scala-core_2.13"))
    def testModuleDeps = super.testModuleDeps ++ Seq(
      build.scalalib,
      build.scalajslib,
      build.scalanativelib
    )

    def buildInfoPackageName = "mill.contrib.bloop"
    def buildInfoObjectName = "Versions"
    def buildInfoMembers = Seq(BuildInfo.Value("bloop", build.Deps.bloopConfig.dep.version))
  }

  object artifactory extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def ivyDeps = Agg(build.Deps.requests)
  }

  object codeartifact extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def ivyDeps = Agg(build.Deps.requests)
  }

  object sonatypecentral extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def ivyDeps = Agg(build.Deps.sonatypeCentralClient)
  }

  object versionfile extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
  }

  object bintray extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def ivyDeps = Agg(build.Deps.requests)
  }

  object gitlab extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def ivyDeps = Agg(build.Deps.requests, build.Deps.osLib)
    def testModuleDeps = super.testModuleDeps ++ Seq(build.scalalib)
  }

  object jmh extends ContribModule {
    def compileModuleDeps = Seq(build.scalalib)
    def testModuleDeps = super.testModuleDeps ++ Seq(build.scalalib)
  }
}
