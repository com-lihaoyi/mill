<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Invalidating build caches using JVM bytecode callgraph analysis :: The Mill Build Tool</title>
    <link rel="canonical" href="https://mill-build.org/blog/10-bytecode-callgraph-analysis.html" />
    <link rel="prev" href="11-jvm-test-parallelism.html" />
    <link rel="next" href="9-mill-faster-assembly-jars.html" />
    <meta name="generator" content="Antora 3.1.12" />
    <link rel="stylesheet" href="../_/css/site.css" />
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-1C582ZJR85"></script>
    <script>function gtag(){dataLayer.push(arguments)};window.dataLayer=window.dataLayer||[];gtag('js',new Date());gtag('config','G-1C582ZJR85')</script>
<link rel="icon" href="../_/favicon.png" type="image/x-icon" />
  
  <style>
  /* auto-hyphenation is super ugly */
  *{
    hyphens: manual !important;
  }

  /* Reduce font size from 17px to something reasonable */
  .doc {
   font-size: 16px !important;
  }
  .doc pre {
   font-size: 14px !important;
  }
  /* Shrink unreasonably large top bar */
  nav.navbar{
    height: 2.5rem;
  }
  body.article{
    padding-top: 2.5rem;
  }
  div.nav-container{
    top: 2.5rem;
  }
  div.toolbar{
    top: 2.5rem;
  }
  aside.nav{
    top: 2.5rem;
    height: calc(100vh - 2.5rem);
  }
  </style></head><body class="article">
  
<header class="header">
  
  <script>
  gtag('config', 'AW-16649289906');

  document.addEventListener('DOMContentLoaded', function() {
  const links = document.querySelectorAll('a');
    links.forEach(link => {
      if (link.textContent.trim().toLowerCase() === 'download') {
        link.addEventListener('click', function(event) {
          console.log("download link clicked")
          gtag('event', 'conversion', {'send_to': 'AW-16649289906/rsphCKfVq8QZELKBgIM-'});
        });
      }
    });
  });
  </script>
  <nav class="navbar">
    <div class="navbar-brand">
      <!-- TODO: add mill icon -->
      <a class="navbar-item" href="https://mill-build.org"><img src="../_/logo-white.svg" height="20" /> The Mill Build Tool</a>
      <div class="navbar-item search">
        <input id="search-input" type="text" placeholder="Search the docs" />
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/com-lihaoyi/mill">GitHub</a>
        <a class="navbar-item" href="https://mill-build.org/blog/index.html">Blog</a>
        <a class="navbar-item" href="https://mill-build.org/api/latest/mill.html">API</a>
        <a class="navbar-item" href="https://github.com/com-lihaoyi/mill/issues">Issues</a>
        <a class="navbar-item" href="https://github.com/com-lihaoyi/mill/discussions">Discuss</a>


            <!--
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Documentation</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#"></a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Plugins</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Resource A</a>
            <a class="navbar-item" href="#">Resource B</a>
            <a class="navbar-item" href="#">Resource C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
        -->
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="blog" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
<ul class="nav-list">

  <li class="nav-item" data-depth="0">
<ul class="nav-list">

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="index.html"><em>The Mill Build Engineering Blog</em></a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="16-zero-setup.html">Zero-Setup Java Build Tooling via Mill Bootstrap Scripts</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="15-android-build-flow.html">Mill as an Alternative Android Build Tool</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="14-bash-zsh-completion.html">Writing Your Own Simple Tab-Completions for Bash and Zsh</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="13-mill-build-tool-v1-0-0.html">Mill Build Tool v1.0.0 Release Highlights</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="12-direct-style-build-tool.html">Mill as a Direct Style Build Tool</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="11-jvm-test-parallelism.html">Strategies for Efficiently Parallelizing JVM Test Suites</a>
  </li>

  <li class="nav-item is-current-page is-active" data-depth="1">
    <a class="nav-link" href="10-bytecode-callgraph-analysis.html">Invalidating build caches using JVM bytecode callgraph analysis</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="9-mill-faster-assembly-jars.html">Fast Incremental JVM Assembly Jar Creation with Mill</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="8-what-is-a-build-tool.html">What does a Build Tool do?</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="7-graal-native-executables.html">How to Compile Java into Native Binaries with Mill and Graal</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="6-garbage-collector-perf.html">Understanding JVM Garbage Collector Performance</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="5-executable-jars.html">How JVM Executable Assembly Jars Work</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="4-flaky-tests.html">How To Manage Flaky Tests in your CI Workflows</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="3-selective-testing.html">Faster CI with Selective Testing</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="2-monorepo-build-tool.html">Why Use a Monorepo Build Tool?</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="1-java-compile.html">How Fast Does Java Compile?</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">The Mill Build Engineering Blog</span>
    <span class="version"></span>
  </div>
  <ul class="components">
    <li class="component">
      <div class="title"><a href="../mill/index.html">Mill Documentation</a></div>
      <ul class="versions">
        <li class="version">
          <a href="../mill/main-branch/index.html">main-branch</a>
        </li>
        <li class="version is-latest">
          <a href="../mill/index.html">1.0.6</a>
        </li>
        <li class="version">
          <a href="../mill/0.12.x/index.html">0.12.16</a>
        </li>
        <li class="version">
          <a href="../mill/0.11.x/index.html">0.11.13</a>
        </li>
        <li class="version">
          <a href="../mill/0.10.15/index.html">0.10.15</a>
        </li>
        <li class="version">
          <a href="../mill/0.9.12/index.html">0.9.12</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <div class="title"><a href="index.html">The Mill Build Engineering Blog</a></div>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">

<div class="toolbar" role="navigation" style="position: fixed; top: 2.5rem; height: 2rem; left: 0px;">
<button class="nav-toggle"></button>
</div>
<div class="toolbar" style="position: fixed; top: 2.5rem; height: 1.5rem; right: 0px;">
<div class="edit-this-page"><a href="https://github.com/com-lihaoyi/mill/edit/main/out/website/blogFolder.dest/modules/ROOT/pages/10-bytecode-callgraph-analysis.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Invalidating build caches using JVM bytecode callgraph analysis</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><em>Li Haoyi, 10 March 2025</em></p>
</div>
<div class="paragraph">
<p>Build tools often cache your task outputs and invalidate them when the input
files change, and build tools often let you implement tasks using blocks of arbitrary
code in some general-purpose language. But the combination of these raises a
question: if your tasks can contain arbitrary code, how can you detect when that code
has changed, and appropriately invalidate the task’s caches? In most programming
languages, &quot;blocks of arbitrary code&quot; are opaque - and the only thing you can do is
run them - so this problem is unsolvable.</p>
</div>
<div class="paragraph">
<p>This blog post explores how Mill extends its JVM runtime by analyzing the callgraph of your
build logic at a bytecode level. This lets Mill analyze a task’s code-block to detect
changes in its implementation or that of transitively-called methods, letting us automatically
invalidate task caches when the code is modified. We’ll discuss the implementation and
limitations of this bytecode analysis, and show empirically how this is able to provide
a significant improvement over more naive approaches to the problem.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_source_file_and_code_change_invalidation"><a class="anchor" href="#_source_file_and_code_change_invalidation"></a>Source File and Code Change Invalidation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To illustrate this problem, consider the following <code>build.mill</code> config:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">def fooSource = Task.Source(&quot;foo.txt&quot;)
def fooTask = Task{
  println(&quot;evaluating fooTask&quot;)
  os.read(fooSource().path).toUpperCase
}

def barSource = Task.Source(&quot;bar.txt&quot;)
def barHelper(s: String) = s.toUpperCase
def barTask = Task{
  println(&quot;evaluating barTask&quot;)
  barHelper(os.read(barSource().path))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This generates a build graph that looks like the following:</p>
</div>
<div class="paragraph">
<center>
<svg width="179px" height="76px" viewBox="0.00 0.00 179.41 75.80" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1.0 1.0) rotate(0.0) translate(4.0 71.8)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-71.8 175.41,-71.8 175.41,4 -4,4"></polygon>
<!-- barSource -->
<g id="node1" class="node">
<title>barSource</title>
<polygon fill="none" stroke="black" points="73.01,-24.7 0.52,-24.7 0.52,-0.1 73.01,-0.1 73.01,-24.7"></polygon>
<text text-anchor="middle" x="36.77" y="-8.2" font-family="Times,serif" font-size="14.00">barSource</text>
</g>
<!-- barTask -->
<g id="node2" class="node">
<title>barTask</title>
<polygon fill="none" stroke="black" points="171.06,-24.7 109.88,-24.7 109.88,-0.1 171.06,-0.1 171.06,-24.7"></polygon>
<text text-anchor="middle" x="140.47" y="-8.2" font-family="Times,serif" font-size="14.00">barTask</text>
</g>
<!-- barSource&#45;&gt;barTask -->
<g id="edge1" class="edge">
<title>barSource-&gt;barTask</title>
<path fill="none" stroke="black" d="M73.05,-12.4C81.63,-12.4 90.86,-12.4 99.63,-12.4"></path>
<polygon fill="black" stroke="black" points="99.65,-15.9 109.65,-12.4 99.65,-8.9 99.65,-15.9"></polygon>
</g>
<!-- fooSource -->
<g id="node3" class="node">
<title>fooSource</title>
<polygon fill="none" stroke="black" points="73.3,-67.7 0.23,-67.7 0.23,-43.1 73.3,-43.1 73.3,-67.7"></polygon>
<text text-anchor="middle" x="36.77" y="-51.2" font-family="Times,serif" font-size="14.00">fooSource</text>
</g>
<!-- fooTask -->
<g id="node4" class="node">
<title>fooTask</title>
<polygon fill="none" stroke="black" points="171.34,-67.7 109.6,-67.7 109.6,-43.1 171.34,-43.1 171.34,-67.7"></polygon>
<text text-anchor="middle" x="140.47" y="-51.2" font-family="Times,serif" font-size="14.00">fooTask</text>
</g>
<!-- fooSource&#45;&gt;fooTask -->
<g id="edge2" class="edge">
<title>fooSource-&gt;fooTask</title>
<path fill="none" stroke="black" d="M73.34,-55.4C81.73,-55.4 90.73,-55.4 99.3,-55.4"></path>
<polygon fill="black" stroke="black" points="99.48,-58.9 109.48,-55.4 99.48,-51.9 99.48,-58.9"></polygon>
</g>
</g>
</svg>

</center>
</div>
<div class="paragraph">
<p>If you run this for the first time, you can see the <code>println</code>s indicating both
tasks were evaluated:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">&gt; ./mill show '{fooTask,barTask}'
evaluating fooTask
evaluating barTask
{
  &quot;fooTask&quot;: &quot;FOO.TXT CONTENTS&quot;,
  &quot;barTask&quot;: &quot;BAR.TXT CONTENTS&quot;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you then run it again after changing <code>foo.txt</code>, you will see that only <code>fooTask</code> re-evaluates,
and <code>barTask</code> does not:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">&gt; echo &quot; changed&quot; &gt;&gt; foo.txt

&gt; ./mill '{fooTask,barTask}'
evaluating fooTask
{
  &quot;fooTask&quot;: &quot;FOO.TXT CONTENTS CHANGED&quot;,
  &quot;barTask&quot;: &quot;BAR.TXT CONTENTS&quot;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is what you would expect, since <code>foo.txt</code> is watched by <code>fooSources</code>, which is then
in turn used by <code>fooTask</code>. So we would expect changes to <code>foo.txt</code> to invalidate <code>fooTask</code>'s
cache and force <code>fooTask</code> to re-evaluate:</p>
</div>
<div class="paragraph">
<center>
<svg width="179px" height="76px" viewBox="0.00 0.00 179.41 75.80" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1.0 1.0) rotate(0.0) translate(4.0 71.8)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-71.8 175.41,-71.8 175.41,4 -4,4"></polygon>
<!-- barSource -->
<g id="node1" class="node">
<title>barSource</title>
<polygon fill="none" stroke="black" points="73.01,-24.7 0.52,-24.7 0.52,-0.1 73.01,-0.1 73.01,-24.7"></polygon>
<text text-anchor="middle" x="36.77" y="-8.2" font-family="Times,serif" font-size="14.00">barSource</text>
</g>
<!-- barTask -->
<g id="node2" class="node">
<title>barTask</title>
<polygon fill="none" stroke="black" points="171.06,-24.7 109.88,-24.7 109.88,-0.1 171.06,-0.1 171.06,-24.7"></polygon>
<text text-anchor="middle" x="140.47" y="-8.2" font-family="Times,serif" font-size="14.00">barTask</text>
</g>
<!-- barSource&#45;&gt;barTask -->
<g id="edge1" class="edge">
<title>barSource-&gt;barTask</title>
<path fill="none" stroke="black" d="M73.05,-12.4C81.63,-12.4 90.86,-12.4 99.63,-12.4"></path>
<polygon fill="black" stroke="black" points="99.65,-15.9 109.65,-12.4 99.65,-8.9 99.65,-15.9"></polygon>
</g>
<!-- fooSource -->
<g id="node3" class="node">
<title>fooSource</title>
<polygon fill="none" stroke="red" stroke-width="3" points="73.3,-67.7 0.23,-67.7 0.23,-43.1 73.3,-43.1 73.3,-67.7"></polygon>
<text text-anchor="middle" x="36.77" y="-51.2" font-family="Times,serif" font-size="14.00">fooSource</text>
</g>
<!-- fooTask -->
<g id="node4" class="node">
<title>fooTask</title>
<polygon fill="none" stroke="red" stroke-width="3" points="171.34,-67.7 109.6,-67.7 109.6,-43.1 171.34,-43.1 171.34,-67.7"></polygon>
<text text-anchor="middle" x="140.47" y="-51.2" font-family="Times,serif" font-size="14.00">fooTask</text>
</g>
<!-- fooSource&#45;&gt;fooTask -->
<g id="edge2" class="edge">
<title>fooSource-&gt;fooTask</title>
<path fill="none" stroke="red" stroke-width="3" d="M73.34,-55.4C81.73,-55.4 90.73,-55.4 99.3,-55.4"></path>
<polygon fill="red" stroke="red" stroke-width="3" points="99.48,-58.9 109.48,-55.4 99.48,-51.9 99.48,-58.9"></polygon>
</g>
</g>
</svg>

</center>
</div>
<div class="paragraph">
<p>Similarly, if we change <code>bar.txt</code>, we would expect to see <code>barTask</code> re-evaluate while <code>fooTask</code> is cached.</p>
</div>
<div class="paragraph">
<p>So far so good. But what if instead of changing the <code>foo.txt</code> or <code>bar.txt</code> source files,
we instead change the <code>build.mill</code> configuration itself? For example, we may change the <code>.toUpperCase</code>
to <code>toLowerCase</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-diff hljs" data-lang="diff"> def fooTask = Task{
   println(&quot;evaluating fooTask&quot;)
-   os.read(fooSource().path).toUpperCase
+   os.read(fooSource().path).toLowerCase
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you make this change, you would want <code>fooTask</code> to re-evaluate since its implementation
changed, but <code>barTask</code> to not re-evaluate since because nothing we changed affected it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">&gt; ./mill show '{fooTask,barTask}'
evaluating fooTask
{
  &quot;fooTask&quot;: &quot;foo.txt contents&quot;,
  &quot;barTask&quot;: &quot;BAR.TXT CONTENTS&quot;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>What if instead of changing <code>fooTask</code> directly, I change <code>barHelper</code>
which <code>barTask</code> uses:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-diff hljs" data-lang="diff">-def barHelper(s: String) = s.toUpperCase
+def barHelper(s: String) = s.toLowerCase</code></pre>
</div>
</div>
<div class="paragraph">
<p>This isn’t directly changing either of <code>fooTask</code> or <code>barTask</code>, but instead
changes the <code>barHelper</code> helper method that is called by <code>barTask</code>. Again, we would
want <code>barTask</code> to re-evaluate to make use of the new helper method, while <code>fooTask</code>
can be cached:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">&gt; ./mill show '{fooTask,barTask}'
evaluating barTask
{
  &quot;fooTask&quot;: &quot;FOO.TXT CONTENTS&quot;,
  &quot;barTask&quot;: &quot;bar.txt contents&quot;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That looks straightforward enough, so what’s the issue?</p>
</div>
<div class="sect2">
<h3 id="_why_code_change_invalidation_is_hard"><a class="anchor" href="#_why_code_change_invalidation_is_hard"></a>Why Code Change Invalidation is Hard</h3>
<div class="paragraph">
<p>Mill <code>build.mill</code> files run on the JVM; the source code is written in Scala, but it
compiles to the same JVM bytecode that Java or Kotlin or any other JVM languages do.
When you look at the definition of a task such as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">def fooTask = Task{
  println(&quot;evaluating fooTask&quot;)
  os.read(fooSource().path).toUpperCase
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Task</code> takes a &quot;by-name&quot; block argument of type <code>⇒ T</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">def Task[T](block: =&gt; T): Task[T] = ???</code></pre>
</div>
</div>
<div class="paragraph">
<p>Essentially, this means when you call <code>Task{ ...​ }</code>, the <code>...​</code> is wrapped in a zero-argument
function <code>() ⇒ ...​</code> of type <code>Function0[T]</code> that you can call via <code>.apply()</code> returning a <code>T</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">def fooTask = Task{ () =&gt;
  println(&quot;evaluating fooTask&quot;)
  os.read(fooSource().path).toUpperCase
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&quot;By-name&quot; parameters are just a convenient way to define blocks of runnable code without
needing to tediously repeat the <code>() ⇒</code> in front of every one, but for all intents and
purposes the effect is the same: you get a <code>Function0[T]</code> that you can call via <code>.apply</code>
to get the value out of it. This <code>Function0</code> is what lets Mill decide whether or not it
needs to run the code in the block:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the inputs to the task are unchanged, Mill can
simply re-use the previous value and avoid running the <code>Function0</code></p>
</li>
<li>
<p>If the inputs to
the task were modified then Mill can call <code>.apply</code> on the <code>Function0</code> to compute the latest
value, and cache it.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The problem is, the <em>only</em> thing that a <code>Function0</code> lets you do is call <code>.apply()</code>!
In particular, <code>Function0</code> does not let you inspect
the function to look at its source code or implementation: like function values in any
language, all that is encapsulated and hidden away from you. How then can Mill detect that
the <code>.toUpperCase</code> in <code>fooTask</code> was replaced by <code>.toLowerCase</code>? Or that modifying
<code>barHelper</code> affects <code>barTask</code>, even if <code>barTask</code>'s own code block is unchanged?</p>
</div>
</div>
<div class="sect2">
<h3 id="_common_approximations"><a class="anchor" href="#_common_approximations"></a>Common Approximations</h3>
<div class="paragraph">
<p>Because deciding whether a code block has changed is difficult,
most build tools punt on the problem entirely:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Early versions of Mill simply invalidated all caches globally if a build file was changed.
This is conservatively correct - it will never invalidate too few caches! - but was definitely
overkill since most changes to build files did not affect most tasks</p>
</li>
<li>
<p>Many other build tools like Maven, Gradle or SBT simply do not automate caching and invalidation,
and leave it up to the implementor of the task to do so. That means the implementor has to do
their own book-keeping to track versions of both the task inputs and task implementations, making
sure to manually invalidate caches when the either changes. This is tedious and error prone,
resulting in cache invalidation problems ubiquitous enough that
<a href="https://stackoverflow.com/questions/4662452/in-maven-why-run-mvn-clean"><em>&quot;always run mvn clean&quot;</em></a>
has become a common practice.</p>
</li>
<li>
<p>Some build tools like Bazel split the problem: the &quot;arbitrary code&quot; in StarLark is not cached,
and the &quot;cached&quot; actions can only run in sub-processes with fixed executables and input flags
without access to the StarLark codebase. This works, but introduces an awkward boundary in
the middle of your build logic, forcing it to be written in two
languages and serializing data to send it back and forth across the process boundary.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>All these approaches are problematic: (1) is maximally conservative and pessimistic,
while (2) is maximally lasse-faire and optimistic, while (3) is workable but awkward.
None of these approaches are fatal - people have lived with build tools working
like this for decades - but we can do better.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_basic_calligraphy_analysis"><a class="anchor" href="#_basic_calligraphy_analysis"></a>Basic Calligraphy Analysis</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The basic idea behind Mill’s callgraph analysis is that JVM <code>Function0</code> objects
aren’t <em>completely</em> opaque: if you would like to you could pull up the <code>.class</code> file
describing each object on disk, and get some understanding of what the code block
or method is doing to do.</p>
</div>
<div class="sect2">
<h3 id="_looking_at_the_bytecode"><a class="anchor" href="#_looking_at_the_bytecode"></a>Looking at the Bytecode</h3>
<div class="paragraph">
<p>For example, consider <code>barTask</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">def barTask = Task{
  println(&quot;evaluating barTask&quot;)
  barHelper(os.read(barSource().path))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We mentioned earlier that body of the <code>Task</code> block is wrapped in an anonymous <code>Function0</code>
<code>() ⇒ ...​</code>. This anonymous function compiles to an <code>$$anonfun</code> method with the bytecode
below, which can be rendered using the <code>javap -c -p</code> command on the relevant compiled <code>.class</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">  private final mill.api.Result barTask$$anonfun$1$$anonfun$1(scala.collection.immutable.Seq, mill.api.TaskCtx);
    Code:
       0: getstatic     #183        // Field mill/api/Result$.MODULE$:Lmill/api/Result$;
       3: getstatic     #314        // Field scala/Predef$.MODULE$:Lscala/Predef$;
       6: ldc_w         #394        // String evaluating barTask
       9: invokevirtual #320        // Method scala/Predef$.println:(Ljava/lang/Object;)V
      12: aload_0
      13: getstatic     #325        // Field os/read$.MODULE$:Los/read$;
      16: aload_1
      17: iconst_0
      18: invokeinterface #330,  2  // InterfaceMethod scala/collection/immutable/Seq.apply:(I)Ljava/lang/Object;
      23: checkcast     #14         // class mill/api/PathRef
      26: invokevirtual #334        // Method mill/api/PathRef.path:()Los/Path;
      29: invokevirtual #337        // Method os/read$.apply:(Los/ReadablePath;)Ljava/lang/String;
      32: invokevirtual #396        // Method barHelper:(Ljava/lang/String;)Ljava/lang/String;
      35: invokevirtual #278        // Method mill/api/Result$.create:(Ljava/lang/Object;)Lmill/api/Result;
      38: areturn</code></pre>
</div>
</div>
<div class="paragraph">
<p>This bytecode contains a lot of <code>invokevirtual</code> and <code>invokeinterface</code> methods that specify,
after all the compiler’s work is done, which methods in the JVM bytecode actually need to be
called when this function is actually run. We can see the invocation of <code>scala/Predef$.println</code> and
<code>os/read$</code> in the bytecode, some <code>mill/api</code> helper methods, and also the call to <code>barHelper</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">      32: invokevirtual #396        // Method barHelper:(Ljava/lang/String;)Ljava/lang/String;</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also look at the <code>barHelper</code> method in the bytecode, which is defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">  public java.lang.String barHelper(java.lang.String);
    Code:
       0: aload_1
       1: invokevirtual #165        // Method java/lang/String.toUpperCase:()Ljava/lang/String;
       4: areturn</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>barHelper</code>'s bytecode contains a single call to <code>java/lang/String.toUpperCase</code>, which
is what we expect given its definition in the source code.</p>
</div>
</div>
<div class="sect2">
<h3 id="_constructing_callgraphs"><a class="anchor" href="#_constructing_callgraphs"></a>Constructing Callgraphs</h3>
<div class="paragraph">
<p>Just like the <em>build graph</em> of tasks we described earlier, the calls between methods
in our build codebase also form a graph: a <em>call graph</em>. For the small
example snippet above, the (simplified) callgraph looks like this</p>
</div>
<div class="paragraph">
<center>
<svg width="177px" height="76px" viewBox="0.00 0.00 177.05 75.80" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1.0 1.0) rotate(0.0) translate(4.0 71.8)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-71.8 173.05,-71.8 173.05,4 -4,4"></polygon>
<!-- barHelper -->
<g id="node1" class="node">
<title>barHelper</title>
<polygon fill="none" stroke="black" points="71.94,-24.7 0.02,-24.7 0.02,-0.1 71.94,-0.1 71.94,-24.7"></polygon>
<text text-anchor="middle" x="35.98" y="-8.2" font-family="Times,serif" font-size="14.00">barHelper</text>
</g>
<!-- barTask -->
<g id="node2" class="node">
<title>barTask</title>
<polygon fill="none" stroke="black" points="169.09,-24.7 107.92,-24.7 107.92,-0.1 169.09,-0.1 169.09,-24.7"></polygon>
<text text-anchor="middle" x="138.51" y="-8.2" font-family="Times,serif" font-size="14.00">barTask</text>
</g>
<!-- barHelper&#45;&gt;barTask -->
<g id="edge1" class="edge">
<title>barHelper-&gt;barTask</title>
<path fill="none" stroke="black" d="M72.14,-12.4C80.43,-12.4 89.33,-12.4 97.8,-12.4"></path>
<polygon fill="black" stroke="black" points="97.87,-15.9 107.87,-12.4 97.87,-8.9 97.87,-15.9"></polygon>
</g>
<!-- fooTask -->
<g id="node3" class="node">
<title>fooTask</title>
<polygon fill="none" stroke="black" points="66.85,-67.7 5.11,-67.7 5.11,-43.1 66.85,-43.1 66.85,-67.7"></polygon>
<text text-anchor="middle" x="35.98" y="-51.2" font-family="Times,serif" font-size="14.00">fooTask</text>
</g>
</g>
</svg>

</center>
</div>
<div class="paragraph">
<p>With this call graph, it is straightforward to do a breadth-first search starting from each task
to find all transitively called methods and hash their contents (the bytecode shown above).
Any change to this hash would indicate that a method’s implementation changed, and any tasks that
depend on it needs to re-evaluate. For example, the change we saw earlier to the <code>barHelper</code>
source code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-diff hljs" data-lang="diff">-def barHelper(s: String) = s.toUpperCase
+def barHelper(s: String) = s.toLowerCase</code></pre>
</div>
</div>
<div class="paragraph">
<p>Would result in a corresponding change in the <code>barHelper</code> bytecode:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-diff hljs" data-lang="diff">  public java.lang.String barHelper(java.lang.String);
    Code:
       0: aload_1
-      1: invokevirtual #165        // Method java/lang/String.toUpperCase:()Ljava/lang/String;
+      1: invokevirtual #165        // Method java/lang/String.toLowerCase:()Ljava/lang/String;
       4: areturn</code></pre>
</div>
</div>
<div class="paragraph">
<p>This would change the hash of <code>barHelper</code>, and from the callgraph
we can then see that <code>barTask</code> depends on <code>barHelper</code> and needs to be invalidated</p>
</div>
<div class="paragraph">
<center>
<svg width="177px" height="76px" viewBox="0.00 0.00 177.05 75.80" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1.0 1.0) rotate(0.0) translate(4.0 71.8)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-71.8 173.05,-71.8 173.05,4 -4,4"></polygon>
<!-- barHelper -->
<g id="node1" class="node">
<title>barHelper</title>
<polygon fill="none" stroke="red" stroke-width="3" points="71.94,-24.7 0.02,-24.7 0.02,-0.1 71.94,-0.1 71.94,-24.7"></polygon>
<text text-anchor="middle" x="35.98" y="-8.2" font-family="Times,serif" font-size="14.00">barHelper</text>
</g>
<!-- barTask -->
<g id="node2" class="node">
<title>barTask</title>
<polygon fill="none" stroke="red" stroke-width="3" points="169.09,-24.7 107.92,-24.7 107.92,-0.1 169.09,-0.1 169.09,-24.7"></polygon>
<text text-anchor="middle" x="138.51" y="-8.2" font-family="Times,serif" font-size="14.00">barTask</text>
</g>
<!-- barHelper&#45;&gt;barTask -->
<g id="edge1" class="edge">
<title>barHelper-&gt;barTask</title>
<path fill="none" stroke="red" stroke-width="3" d="M72.14,-12.4C80.43,-12.4 89.33,-12.4 97.8,-12.4"></path>
<polygon fill="red" stroke="red" stroke-width="3" points="97.87,-15.9 107.87,-12.4 97.87,-8.9 97.87,-15.9"></polygon>
</g>
<!-- fooTask -->
<g id="node3" class="node">
<title>fooTask</title>
<polygon fill="none" stroke="black" points="66.85,-67.7 5.11,-67.7 5.11,-43.1 66.85,-43.1 66.85,-67.7"></polygon>
<text text-anchor="middle" x="35.98" y="-51.2" font-family="Times,serif" font-size="14.00">fooTask</text>
</g>
</g>
</svg>

</center>
</div>
<div class="paragraph">
<p>The bytecode for a method is typically much more stable than the source code: it is not
affected by formatting, comments, local variable names, etc.. This means that if
the bytecode hash for a method changed, it likely means the implementation changed, and any
tasks that call that method (directly or transitively) need to be re-evaluated.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_object_oriented_callgraphs"><a class="anchor" href="#_object_oriented_callgraphs"></a>Object-Oriented Callgraphs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Although callgraph analysis on the static methods shown above is simple,
JVM languages like Java and Scala make heavy use of objects, classes, and subclassing.
Mill’s callgraph analyzer working on Scala sources compiled to JVM bytecode thus need
to handle these object-oriented language features.</p>
</div>
<div class="sect2">
<h3 id="_instance_methods"><a class="anchor" href="#_instance_methods"></a>Instance Methods</h3>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">class Qux(suffix0: String) {
  val suffix = suffix0 + suffix0 + suffix0
  def bazHelper(s: String) = s.toUpperCase + suffix
}

def barTask = Task{
  val qux = new Qux(&quot;!&quot;)
  qux.bazHelper(os.read(barSource().path))
} // BAR.TXT CONTENTS!!!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, we are calling <code>bazHelper</code> on the value in <code>barTask</code>. But the behavior of
a <code>qux.bazHelper()</code> doesn’t just depend on the implementation of <code>bazHelper</code> itself, but also:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The value <code>suffix</code> that was passed in when <code>new Qux</code> was constructed, in this case <code>&quot;!&quot;</code></p>
</li>
<li>
<p>The implementation of the <code>new Qux</code> constructor (often called <code>Qux#&lt;init&gt;</code> on the JVM)
which assigns <code>val suffix = suffix0 + suffix0 + suffix0</code> to construct the <code>suffix</code> used in
<code>bazHelper</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This actually turns out to work: the fact that you have <code>qux</code> means that you
must have called its constructor and passed in arguments (directly or indirectly):</p>
</div>
<div class="paragraph">
<center>
<svg width="210px" height="76px" viewBox="0.00 0.00 209.71 75.80" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1.0 1.0) rotate(0.0) translate(4.0 71.8)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-71.8 205.71,-71.8 205.71,4 -4,4"></polygon>
<!-- Qux#bazHelper -->
<g id="node1" class="node">
<title>Qux#bazHelper</title>
<polygon fill="none" stroke="black" points="104.43,-67.7 0.19,-67.7 0.19,-43.1 104.43,-43.1 104.43,-67.7"></polygon>
<text text-anchor="middle" x="52.31" y="-51.2" font-family="Times,serif" font-size="14.00">Qux#bazHelper</text>
</g>
<!-- barTask -->
<g id="node2" class="node">
<title>barTask</title>
<polygon fill="none" stroke="black" points="201.75,-45.7 140.58,-45.7 140.58,-21.1 201.75,-21.1 201.75,-45.7"></polygon>
<text text-anchor="middle" x="171.17" y="-29.2" font-family="Times,serif" font-size="14.00">barTask</text>
</g>
<!-- Qux#bazHelper&#45;&gt;barTask -->
<g id="edge1" class="edge">
<title>Qux#bazHelper-&gt;barTask</title>
<path fill="none" stroke="black" d="M104.57,-45.75C113.29,-44.11 122.22,-42.43 130.58,-40.85"></path>
<polygon fill="black" stroke="black" points="131.26,-44.29 140.44,-39 129.96,-37.41 131.26,-44.29"></polygon>
</g>
<!-- Qux#&lt;init&gt; -->
<g id="node3" class="node">
<title>Qux#&lt;init&gt;</title>
<polygon fill="none" stroke="black" points="92.88,-24.7 11.74,-24.7 11.74,-0.1 92.88,-0.1 92.88,-24.7"></polygon>
<text text-anchor="middle" x="52.31" y="-8.2" font-family="Times,serif" font-size="14.00">Qux#&lt;init&gt;</text>
</g>
<!-- Qux#&lt;init&gt;&#45;&gt;barTask -->
<g id="edge2" class="edge">
<title>Qux#&lt;init&gt;-&gt;barTask</title>
<path fill="none" stroke="black" d="M93.2,-19.57C105.17,-21.72 118.29,-24.08 130.26,-26.23"></path>
<polygon fill="black" stroke="black" points="129.96,-29.73 140.42,-28.05 131.19,-22.84 129.96,-29.73"></polygon>
</g>
</g>
</svg>

</center>
</div>
<div class="ulist">
<ul>
<li>
<p>Changes to the <code>Qux</code> constructor param <code>&quot;!&quot;</code> are part of the <code>barTask</code> task body</p>
</li>
<li>
<p>Changes to the <code>Qux#&lt;init&gt;</code> constructor are captured because <code>Qux#&lt;init&gt;</code> is called by <code>barTask</code>
to construct <code>qux</code> before using it</p>
</li>
<li>
<p>Changes to <code>Qux#bazHelper</code> are captured because <code>bazHelper</code> is called by <code>barTask</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Thus, the existing callgraph analysis above is sufficient to handle the various cases around
instance methods without modification.</p>
</div>
</div>
<div class="sect2">
<h3 id="_instance_fields"><a class="anchor" href="#_instance_fields"></a>Instance Fields</h3>
<div class="paragraph">
<p>A similar approach can be take to analyzing fields, which are defined via the <code>var</code> or <code>val</code> keyword
in contrast to methods defined via <code>def</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">class Qux(suffix0: String) {
  var suffix = suffix0
  def doubleSuffix() = {
    suffix = suffix + suffix
  }
}

def barTask = Task{
  val qux = new Qux(&quot;!&quot;)
  qux.doubleSuffix()
  qux.doubleSuffix()
  os.read(barSource().path) + qux.suffix
} // BAR.TXT CONTENTS!!!!</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, <code>barTask</code> references the <code>suffix</code> field directly, without going through
a <code>bazHelper</code> method. Method call graph analysis does not track fields, but it doesn’t
need to: a field can only get its value from the methods that set it, whether
the constructor (above setting <code>var suffix = suffix0</code>) or other methods (e.g. <code>def doubleSuffix</code>,
which sets <code>suffix = suffix + suffix</code>).</p>
</div>
<div class="paragraph">
<center>
<svg width="225px" height="76px" viewBox="0.00 0.00 225.29 75.80" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1.0 1.0) rotate(0.0) translate(4.0 71.8)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-71.8 221.29,-71.8 221.29,4 -4,4"></polygon>
<!-- Qux#&lt;init&gt; -->
<g id="node1" class="node">
<title>Qux#&lt;init&gt;</title>
<polygon fill="none" stroke="black" points="100.67,-67.7 19.53,-67.7 19.53,-43.1 100.67,-43.1 100.67,-67.7"></polygon>
<text text-anchor="middle" x="60.1" y="-51.2" font-family="Times,serif" font-size="14.00">Qux#&lt;init&gt;</text>
</g>
<!-- barTask -->
<g id="node2" class="node">
<title>barTask</title>
<polygon fill="none" stroke="black" points="217.34,-45.7 156.16,-45.7 156.16,-21.1 217.34,-21.1 217.34,-45.7"></polygon>
<text text-anchor="middle" x="186.75" y="-29.2" font-family="Times,serif" font-size="14.00">barTask</text>
</g>
<!-- Qux#&lt;init&gt;&#45;&gt;barTask -->
<g id="edge1" class="edge">
<title>Qux#&lt;init&gt;-&gt;barTask</title>
<path fill="none" stroke="black" d="M100.88,-48.38C115.22,-45.85 131.39,-42.99 145.74,-40.46"></path>
<polygon fill="black" stroke="black" points="146.58,-43.87 155.82,-38.68 145.36,-36.97 146.58,-43.87"></polygon>
</g>
<!-- Qux#doubleSuffix -->
<g id="node3" class="node">
<title>Qux#doubleSuffix</title>
<polygon fill="none" stroke="black" points="120.31,-24.7 -0.1,-24.7 -0.1,-0.1 120.31,-0.1 120.31,-24.7"></polygon>
<text text-anchor="middle" x="60.1" y="-8.2" font-family="Times,serif" font-size="14.00">Qux#doubleSuffix</text>
</g>
<!-- Qux#doubleSuffix&#45;&gt;barTask -->
<g id="edge2" class="edge">
<title>Qux#doubleSuffix-&gt;barTask</title>
<path fill="none" stroke="black" d="M120.51,-22.41C129.15,-23.86 137.86,-25.33 145.99,-26.7"></path>
<polygon fill="black" stroke="black" points="145.47,-30.16 155.91,-28.37 146.63,-23.26 145.47,-30.16"></polygon>
</g>
</g>
</svg>

</center>
</div>
<div class="paragraph">
<p>Since these methods are all already captured as part of the normal callgraph analysis,
it’s fine to ignore fields entirely: you will never
miss a code change that affects a field value because such code changes must occur in
methods which we already track.</p>
</div>
</div>
<div class="sect2">
<h3 id="_enclosing_fields"><a class="anchor" href="#_enclosing_fields"></a>Enclosing Fields</h3>
<div class="paragraph">
<p>A follow up example is what happens if the task block relies on a field (<code>val</code>) rather
than a method (<code>def</code>) in an enclosing <code>object</code>?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">object enclosing extends Module{
  val suffix = &quot;???&quot;
  def barTask = Task{
    os.read(barSource().path) + suffix
  } // bar.txt contents???
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem here is that the transitive callgraph of <code>barTask</code> is not sufficient:
not only do we need to call <code>barTask</code>, we first need to instantiate <code>object enclosing</code>
as well. This is similar to the <a href="#_instance_methods">Instance Methods</a> case we looked at above, but instead of
relying on some object instance that <code>barTask</code> instantiates and calls, we are looking at
<code>barTask</code>'s <em>own</em> object instance, that must have been instantiated earlier. Singleton
<code>object</code>s do not take constructor <em>parameters</em>, but in both cases
we need to account for the constructor <em>code</em> for the object on which we are calling the method.</p>
</div>
<div class="paragraph">
<p>In practice, this is straightforward: we just need to add an edge from the <code>enclosing#&lt;init&gt;</code>
constructor (and that of any other enclosing objects) to <code>barTask</code> when constructing the callgraph:</p>
</div>
<div class="paragraph">
<center>
<svg width="216px" height="119px" viewBox="0.00 0.00 216.20 118.80" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1.0 1.0) rotate(0.0) translate(4.0 114.8)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-114.8 212.2,-114.8 212.2,4 -4,4"></polygon>
<!-- Qux#bazHelper -->
<g id="node1" class="node">
<title>Qux#bazHelper</title>
<polygon fill="none" stroke="black" points="107.68,-110.7 3.43,-110.7 3.43,-86.1 107.68,-86.1 107.68,-110.7"></polygon>
<text text-anchor="middle" x="55.56" y="-94.2" font-family="Times,serif" font-size="14.00">Qux#bazHelper</text>
</g>
<!-- barTask -->
<g id="node2" class="node">
<title>barTask</title>
<polygon fill="none" stroke="black" points="208.25,-67.7 147.07,-67.7 147.07,-43.1 208.25,-43.1 208.25,-67.7"></polygon>
<text text-anchor="middle" x="177.66" y="-51.2" font-family="Times,serif" font-size="14.00">barTask</text>
</g>
<!-- Qux#bazHelper&#45;&gt;barTask -->
<g id="edge1" class="edge">
<title>Qux#bazHelper-&gt;barTask</title>
<path fill="none" stroke="black" d="M90.97,-86.08C105.42,-80.91 122.29,-74.86 137.23,-69.52"></path>
<polygon fill="black" stroke="black" points="138.49,-72.78 146.73,-66.12 136.13,-66.19 138.49,-72.78"></polygon>
</g>
<!-- Qux#&lt;init&gt; -->
<g id="node3" class="node">
<title>Qux#&lt;init&gt;</title>
<polygon fill="none" stroke="black" points="96.13,-67.7 14.99,-67.7 14.99,-43.1 96.13,-43.1 96.13,-67.7"></polygon>
<text text-anchor="middle" x="55.56" y="-51.2" font-family="Times,serif" font-size="14.00">Qux#&lt;init&gt;</text>
</g>
<!-- Qux#&lt;init&gt;&#45;&gt;barTask -->
<g id="edge2" class="edge">
<title>Qux#&lt;init&gt;-&gt;barTask</title>
<path fill="none" stroke="black" d="M96.22,-55.4C109.26,-55.4 123.77,-55.4 136.83,-55.4"></path>
<polygon fill="black" stroke="black" points="136.94,-58.9 146.94,-55.4 136.94,-51.9 136.94,-58.9"></polygon>
</g>
<!-- enclosing#&lt;init&gt; -->
<g id="node4" class="node">
<title>enclosing#&lt;init&gt;</title>
<polygon fill="none" stroke="black" points="111.17,-24.7 -0.06,-24.7 -0.06,-0.1 111.17,-0.1 111.17,-24.7"></polygon>
<text text-anchor="middle" x="55.56" y="-8.2" font-family="Times,serif" font-size="14.00">enclosing#&lt;init&gt;</text>
</g>
<!-- enclosing#&lt;init&gt;&#45;&gt;barTask -->
<g id="edge3" class="edge">
<title>enclosing#&lt;init&gt;-&gt;barTask</title>
<path fill="none" stroke="black" d="M90.97,-24.72C105.42,-29.89 122.29,-35.94 137.23,-41.28"></path>
<polygon fill="black" stroke="black" points="136.13,-44.61 146.73,-44.68 138.49,-38.02 136.13,-44.61"></polygon>
</g>
</g>
</svg>

</center>
</div>
</div>
<div class="sect2">
<h3 id="_virtual_methods"><a class="anchor" href="#_virtual_methods"></a>Virtual Methods</h3>
<div class="paragraph">
<p>The JVM bytecode has direct support for virtual method calls via <code>invokevirtual</code>: e.g.
a single call to <code>Qux.bazHelper()</code> may call out to any number of methods
defined in various subclasses of <code>Qux</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">abstract class Qux {
  def bazHelper(s: String): String
}

class Qux1(suffix: String) extends Qux {
  def bazHelper(s: String) = s.toUpperCase + suffix
}

class Qux2(prefix: String) extends Qux {
  def bazHelper(s: String) = prefix + s.toUpperCase
}

def barTask = Task{
  val qux: Qux = if (math.random() &gt; 0.5) new Qux1(&quot;!&quot;) else new Qux2(&quot;!&quot;)
  qux.bazHelper(os.read(barSource().path))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is not always obvious what implementation <code>qux.bazHelper</code> will end up calling: indeed
in this example it may end up calling different implementations when run at different times!
To resolve this, you need to analyze the various classes in your program,
so you can resolve such virtual callsites to possible definition sites in subclasses.</p>
</div>
<div class="paragraph">
<p>There are varying degrees of precision for which you can analyze virtual methods, e.g.
<em>Class Hierarchy Analysis</em> and <em>Rapid Type Analysis</em> described in
<a href="https://courses.cs.washington.edu/courses/cse501/04wi/papers/bacon-oopsla96.pdf">Fast Static Analysis of C++ Virtual Calls, OOPSLA96</a>,
or even more sophisticated dataflow approaches such as <a href="https://en.wikipedia.org/wiki/Pointer_analysis">Points-To Analysis</a>.
At a high level, the distinction between these is in how they look for subclasses
that may provide an implementation for a virtual method:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Class Hierarchy Analysis</strong>: Any class that implements that method <em>globally in your codebase</em></p>
</li>
<li>
<p><strong>Rapid Type Analysis</strong>: Any class that implements that method <em>that is instantiated as
part of the program starting from the <code>main</code> entrypoint</em></p>
</li>
<li>
<p><strong>Points-To Analysis</strong>: Any class that
implements that method that is <em>instantiated and passed to this specific callsite</em></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Mill uses a variant of (1) <em>Class Hierarchy Analysis</em>: we treat every Mill <code>Task</code> as a
potential entrypoint, and find all classes instantiated across your build codebase in one pass.
This is less precise than running the analysis separately for every <code>Task</code> that <em>Rapid Type
Analysis</em> would require, but is more precise than a naive <em>Class Hierarchy Analysis</em> that
doesn’t consider whether a class is instantiated or not.</p>
</div>
<div class="paragraph">
<p>For example, in the snippet below,
Mill is able to identify that <code>qux.bazHelper</code> may call <code>Qux1#bazHelper</code> or <code>Qux2#bazHelper</code>,
but not <code>Qux3#bazHelper</code> because there is no <code>new Qux3</code> being instantiated anywhere in our
codebase:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">abstract class Qux {
  def bazHelper(s: String): String
}

class Qux1(suffix: String) extends Qux {
  def bazHelper(s: String) = s.toUpperCase + suffix
}

class Qux2(prefix: String) extends Qux {
  def bazHelper(s: String) = prefix + s.toUpperCase
}

class Qux3(prefixSuffix: String) extends Qux {
  def bazHelper(s: String) = prefixSuffix + s.toUpperCase + prefixSuffix
}

def barTask = Task{
  val qux: Qux = if (math.random() &gt; 0.5) new Qux1(&quot;!&quot;) else new Qux2(&quot;!&quot;)
  qux.bazHelper(os.read(barSource().path))
}</code></pre>
</div>
</div>
<div class="paragraph">
<center>
<svg width="357px" height="140px" viewBox="0.00 0.00 357.33 139.80" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1.0 1.0) rotate(0.0) translate(4.0 135.8)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-135.8 353.33,-135.8 353.33,4 -4,4"></polygon>
<!-- Qux#bazHelper -->
<g id="node1" class="node">
<title>Qux#bazHelper</title>
<polygon fill="none" stroke="black" points="252.06,-45.7 147.81,-45.7 147.81,-21.1 252.06,-21.1 252.06,-45.7"></polygon>
<text text-anchor="middle" x="199.93" y="-29.2" font-family="Times,serif" font-size="14.00">Qux#bazHelper</text>
</g>
<!-- barTask -->
<g id="node2" class="node">
<title>barTask</title>
<polygon fill="none" stroke="black" points="349.38,-88.7 288.2,-88.7 288.2,-64.1 349.38,-64.1 349.38,-88.7"></polygon>
<text text-anchor="middle" x="318.79" y="-72.2" font-family="Times,serif" font-size="14.00">barTask</text>
</g>
<!-- Qux#bazHelper&#45;&gt;barTask -->
<g id="edge1" class="edge">
<title>Qux#bazHelper-&gt;barTask</title>
<path fill="none" stroke="black" d="M234.42,-45.72C248.12,-50.76 264.07,-56.63 278.33,-61.88"></path>
<polygon fill="black" stroke="black" points="277.29,-65.23 287.88,-65.4 279.71,-58.66 277.29,-65.23"></polygon>
</g>
<!-- Qux1#&lt;init&gt; -->
<g id="node3" class="node">
<title>Qux1#&lt;init&gt;</title>
<polygon fill="none" stroke="black" points="244,-131.7 155.87,-131.7 155.87,-107.1 244,-107.1 244,-131.7"></polygon>
<text text-anchor="middle" x="199.93" y="-115.2" font-family="Times,serif" font-size="14.00">Qux1#&lt;init&gt;</text>
</g>
<!-- Qux1#&lt;init&gt;&#45;&gt;barTask -->
<g id="edge2" class="edge">
<title>Qux1#&lt;init&gt;-&gt;barTask</title>
<path fill="none" stroke="black" d="M234.42,-107.08C248.12,-102.04 264.07,-96.17 278.33,-90.92"></path>
<polygon fill="black" stroke="black" points="279.71,-94.14 287.88,-87.4 277.29,-87.57 279.71,-94.14"></polygon>
</g>
<!-- Qux2#&lt;init&gt; -->
<g id="node4" class="node">
<title>Qux2#&lt;init&gt;</title>
<polygon fill="none" stroke="black" points="244,-88.7 155.87,-88.7 155.87,-64.1 244,-64.1 244,-88.7"></polygon>
<text text-anchor="middle" x="199.93" y="-72.2" font-family="Times,serif" font-size="14.00">Qux2#&lt;init&gt;</text>
</g>
<!-- Qux2#&lt;init&gt;&#45;&gt;barTask -->
<g id="edge3" class="edge">
<title>Qux2#&lt;init&gt;-&gt;barTask</title>
<path fill="none" stroke="black" d="M244.11,-76.4C255.15,-76.4 266.97,-76.4 277.83,-76.4"></path>
<polygon fill="black" stroke="black" points="277.9,-79.9 287.9,-76.4 277.9,-72.9 277.9,-79.9"></polygon>
</g>
<!-- Qux1#bazHelper -->
<g id="node5" class="node">
<title>Qux1#bazHelper</title>
<polygon fill="none" stroke="black" points="111.43,-67.7 0.19,-67.7 0.19,-43.1 111.43,-43.1 111.43,-67.7"></polygon>
<text text-anchor="middle" x="55.81" y="-51.2" font-family="Times,serif" font-size="14.00">Qux1#bazHelper</text>
</g>
<!-- Qux1#bazHelper&#45;&gt;Qux#bazHelper -->
<g id="edge4" class="edge">
<title>Qux1#bazHelper-&gt;Qux#bazHelper</title>
<path fill="none" stroke="black" d="M111.76,-46.89C120.18,-45.59 128.92,-44.24 137.47,-42.91"></path>
<polygon fill="black" stroke="black" points="138.05,-46.37 147.39,-41.38 136.98,-39.45 138.05,-46.37"></polygon>
</g>
<!-- Qux2#bazHelper -->
<g id="node6" class="node">
<title>Qux2#bazHelper</title>
<polygon fill="none" stroke="black" points="111.43,-24.7 0.19,-24.7 0.19,-0.1 111.43,-0.1 111.43,-24.7"></polygon>
<text text-anchor="middle" x="55.81" y="-8.2" font-family="Times,serif" font-size="14.00">Qux2#bazHelper</text>
</g>
<!-- Qux2#bazHelper&#45;&gt;Qux#bazHelper -->
<g id="edge5" class="edge">
<title>Qux2#bazHelper-&gt;Qux#bazHelper</title>
<path fill="none" stroke="black" d="M111.76,-20.52C120.18,-21.76 128.92,-23.05 137.47,-24.32"></path>
<polygon fill="black" stroke="black" points="136.99,-27.79 147.39,-25.78 138.01,-20.86 136.99,-27.79"></polygon>
</g>
</g>
</svg>

</center>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_other_complications"><a class="anchor" href="#_other_complications"></a>Other Complications</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_library_methods"><a class="anchor" href="#_library_methods"></a>Library Methods</h3>
<div class="paragraph">
<p>Performance is a big constraint in Mill’s analysis. In particular, we don’t want to have
to analyze the entire Java or Scala standard libraries, because that would be very
expensive. Mill thus only constructs a call graph for code written and compiled locally
as part of your build, modelling upstream libraries in a simplified fashion
(similar to
<a href="https://plg.uwaterloo.ca/~olhotak/pubs/ecoop13.pdf">Whole-Program Analysis without the Whole Program, ECOOP 2013</a>).
In practice this means:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>We avoid generating a detailed callgraph of methods in upstream libraries. Instead, we only
capture the class inheritance hierarchies of classes whose methods are called from your Mill build</p>
</li>
<li>
<p>For calls to external methods for which we did not analyze the bytecode, we conservatively assume that
they could potentially call any other external methods defined in the receiver class, the function parameter
types, or any of their superclasses, and thus any locally-defined overrides for those external methods.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Essentially, we assume that any upstream library methods that we pass objects to -
either as parameters or as the method receiver - could call any other methods on
those objects. Consider the following case:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">class MyException extends Exception{
  override def printStackTrace(ps: java.io.PrintStream) = {ps.println(&quot;dummy&quot;)}
}

class MyOutputStream extends java.io.OutputStream{ def write(b: Int) = println(b) }

def barTask = Task{
  val ex: Exception = new MyException
  val stream: OutputStream = new MyOutputStream
  ex.printStackTrace(new java.io.PrintStream(b))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we are defining our own subclass of <code>Exception</code> and <code>OutputStream</code>, with their own
overrides of <code>def printStackTrace</code> and <code>def write</code> respectively. However, when we end up
calling <code>ex.printStackTrace</code>, we are calling <code>printStackTrace</code> on the super-type <code>Exception</code>,
and <code>def write</code> is not called at all in our code since its calls live upstream in
<code>PrintStream</code> and <code>OutputStream</code>! By the rules above, we are able to capture the <em>possibility</em>
of these calls:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The call to <code>new PrintStream(b: OutputStream)</code> we treat as being able to call any method
on <code>PrintStream</code> or <code>OutputStream</code>, and in any sub-classes, hence <code>MyOutputStream#write</code>
is callable from here</p>
</li>
<li>
<p>The call to <code>Exception#printStackTrace</code> may reach any <code>def printStackTrace</code> defined in a
subclass of <code>Exception</code> in our local code, hence <code>MyException#printStackTrace</code> is callable
from here</p>
</li>
</ol>
</div>
<div class="paragraph">
<center>
<svg width="499px" height="162px" viewBox="0.00 0.00 498.86 161.80" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1.0 1.0) rotate(0.0) translate(4.0 157.8)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-157.8 494.86,-157.8 494.86,4 -4,4"></polygon>
<!-- MyException#&lt;init&gt; -->
<g id="node1" class="node">
<title>MyException#&lt;init&gt;</title>
<polygon fill="none" stroke="black" points="375.86,-153.7 242.52,-153.7 242.52,-129.1 375.86,-129.1 375.86,-153.7"></polygon>
<text text-anchor="middle" x="309.19" y="-137.2" font-family="Times,serif" font-size="14.00">MyException#&lt;init&gt;</text>
</g>
<!-- barTask -->
<g id="node2" class="node">
<title>barTask</title>
<polygon fill="none" stroke="black" points="490.9,-88.7 429.73,-88.7 429.73,-64.1 490.9,-64.1 490.9,-88.7"></polygon>
<text text-anchor="middle" x="460.32" y="-72.2" font-family="Times,serif" font-size="14.00">barTask</text>
</g>
<!-- MyException#&lt;init&gt;&#45;&gt;barTask -->
<g id="edge1" class="edge">
<title>MyException#&lt;init&gt;-&gt;barTask</title>
<path fill="none" stroke="black" d="M367.24,-129.03C376.29,-126.32 385.41,-123.12 393.77,-119.4 408.48,-112.85 423.59,-103.17 435.59,-94.66"></path>
<polygon fill="black" stroke="black" points="437.71,-97.44 443.73,-88.72 433.59,-91.79 437.71,-97.44"></polygon>
</g>
<!-- MyOutputStream#&lt;init&gt; -->
<g id="node3" class="node">
<title>MyOutputStream#&lt;init&gt;</title>
<polygon fill="none" stroke="black" points="387.14,-110.7 231.24,-110.7 231.24,-86.1 387.14,-86.1 387.14,-110.7"></polygon>
<text text-anchor="middle" x="309.19" y="-94.2" font-family="Times,serif" font-size="14.00">MyOutputStream#&lt;init&gt;</text>
</g>
<!-- MyOutputStream#&lt;init&gt;&#45;&gt;barTask -->
<g id="edge2" class="edge">
<title>MyOutputStream#&lt;init&gt;-&gt;barTask</title>
<path fill="none" stroke="black" d="M386.94,-87.08C398.17,-85.42 409.33,-83.77 419.41,-82.29"></path>
<polygon fill="black" stroke="black" points="420.09,-85.72 429.47,-80.8 419.07,-78.8 420.09,-85.72"></polygon>
</g>
<!-- PrintStream#&lt;init&gt; -->
<g id="node4" class="node">
<title>PrintStream#&lt;init&gt;</title>
<polygon fill="none" stroke="black" points="371.53,-67.7 246.85,-67.7 246.85,-43.1 371.53,-43.1 371.53,-67.7"></polygon>
<text text-anchor="middle" x="309.19" y="-51.2" font-family="Times,serif" font-size="14.00">PrintStream#&lt;init&gt;</text>
</g>
<!-- PrintStream#&lt;init&gt;&#45;&gt;barTask -->
<g id="edge3" class="edge">
<title>PrintStream#&lt;init&gt;-&gt;barTask</title>
<path fill="none" stroke="black" d="M371.71,-64.06C387.85,-66.34 404.83,-68.73 419.5,-70.79"></path>
<polygon fill="black" stroke="black" points="419.34,-74.3 429.73,-72.23 420.31,-67.37 419.34,-74.3"></polygon>
</g>
<!-- Exception#printStackTrace -->
<g id="node5" class="node">
<title>Exception#printStackTrace</title>
<polygon fill="none" stroke="black" points="393.86,-24.7 224.53,-24.7 224.53,-0.1 393.86,-0.1 393.86,-24.7"></polygon>
<text text-anchor="middle" x="309.19" y="-8.2" font-family="Times,serif" font-size="14.00">Exception#printStackTrace</text>
</g>
<!-- Exception#printStackTrace&#45;&gt;barTask -->
<g id="edge4" class="edge">
<title>Exception#printStackTrace-&gt;barTask</title>
<path fill="none" stroke="black" d="M366.76,-24.71C375.96,-27.44 385.25,-30.66 393.77,-34.4 408.07,-40.68 422.82,-49.84 434.69,-58.01"></path>
<polygon fill="black" stroke="black" points="432.97,-61.08 443.16,-64 437.01,-55.37 432.97,-61.08"></polygon>
</g>
<!-- MyOutputStream#write -->
<g id="node6" class="node">
<title>MyOutputStream#write</title>
<polygon fill="none" stroke="black" points="169.05,-67.7 19.56,-67.7 19.56,-43.1 169.05,-43.1 169.05,-67.7"></polygon>
<text text-anchor="middle" x="94.3" y="-51.2" font-family="Times,serif" font-size="14.00">MyOutputStream#write</text>
</g>
<!-- MyOutputStream#write&#45;&gt;PrintStream#&lt;init&gt; -->
<g id="edge5" class="edge">
<title>MyOutputStream#write-&gt;PrintStream#&lt;init&gt;</title>
<path fill="none" stroke="black" d="M169.16,-55.4C191.04,-55.4 214.95,-55.4 236.67,-55.4"></path>
<polygon fill="black" stroke="black" points="236.81,-58.9 246.81,-55.4 236.81,-51.9 236.81,-58.9"></polygon>
</g>
<!-- MyException#printStackTrace -->
<g id="node7" class="node">
<title>MyException#printStackTrace</title>
<polygon fill="none" stroke="black" points="188.41,-24.7 0.2,-24.7 0.2,-0.1 188.41,-0.1 188.41,-24.7"></polygon>
<text text-anchor="middle" x="94.3" y="-8.2" font-family="Times,serif" font-size="14.00">MyException#printStackTrace</text>
</g>
<!-- MyException#printStackTrace&#45;&gt;Exception#printStackTrace -->
<g id="edge6" class="edge">
<title>MyException#printStackTrace-&gt;Exception#printStackTrace</title>
<path fill="none" stroke="black" d="M188.68,-12.4C197.27,-12.4 205.98,-12.4 214.57,-12.4"></path>
<polygon fill="black" stroke="black" points="214.6,-15.9 224.6,-12.4 214.6,-8.9 214.6,-15.9"></polygon>
</g>
</g>
</svg>

</center>
</div>
<div class="paragraph">
<p>Since Mill does not do <em>Points-To Analysis</em> or other <em>Data-flow Analyses</em>, it isn’t able
to determine that the value <code>ex</code> is of class <code>MyException</code>, or that the value <code>stream</code>
is of class <code>MyOutputStream</code>, and so it must treat them broadly as <code>Exception</code> and <code>OutputStream</code>
instances that could be of any sub-class. This may result in false positives with Mill treating method as callable
when it really isn’t, invalidating more caches than it needs to, but it will never result in
Mill missing a potential call and failing to invalidate a task cache when it should have done so.</p>
</div>
</div>
<div class="sect2">
<h3 id="_lambdas_and_single_abstract_methods"><a class="anchor" href="#_lambdas_and_single_abstract_methods"></a>Lambdas and Single-Abstract-Methods</h3>
<div class="paragraph">
<p>Mill special-cases handling of inline functions (e.g. <code>() ⇒ ...​</code>) and single-abstract method
instances (e.g. <code>new Runnable{ def run() = ...​ }</code>) and treats them as if they were called
immediately at their definition site.</p>
</div>
<div class="paragraph">
<p>Ideally, we would consider each method called if there is
a call-site that could reach it <em>and</em> if its defining class is instantiated, but analyzing
that precisely (also called <em>Rapid Type Analysis</em>) would be too expensive.</p>
</div>
<div class="paragraph">
<p>For most methods, our simpler <em>Class Hierarchy Analysis</em> only considers whether a call-site
could reach a definition, without caring about whether the defining class is instantiated. But
this has a pathological case for widely-used simple interfaces. Consider the following example
where <code>fooTask</code> calls <code>fooHelper</code> in a lambda, and <code>barTask</code> calls <code>barHelper</code> is a lambda:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">def fooHelper(s: String) = s.toLowerCase
def fooTask = Task{
  println(&quot;evaluating fooTask&quot;)
  os.read.lines(fooSource().path).map(s =&gt; fooHelper(s))
}

def barHelper(s: String) = s.toUpperCase
def barTask = Task{
  println(&quot;evaluating barTask&quot;)
  os.read.lines(barSource().path).map(s =&gt; barHelper(s))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we handled lambdas via <em>Class Hierarchy Analysis</em>, with our simplified handling of
<a href="#_library_methods">Library Methods</a>, then:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Every lambda that takes a single parameter is a subclass of <code>Function1</code> with an <code>apply</code> method</p>
</li>
<li>
<p>Every callsite of <code>.map</code> from the standard library receives a <code>Function1</code>, and
thus may call <code>apply</code> on any definition of <code>Function</code> in user code</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This results in a callgraph as follows, where every lambda callsite could potentially call
every lambda. This is conservatively correct, but imprecise enough to be useless.</p>
</div>
<div class="paragraph">
<center>
<svg width="326px" height="76px" viewBox="0.00 0.00 325.50 75.80" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1.0 1.0) rotate(0.0) translate(4.0 71.8)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-71.8 321.5,-71.8 321.5,4 -4,4"></polygon>
<!-- fooHelper -->
<g id="node1" class="node">
<title>fooHelper</title>
<polygon fill="none" stroke="black" points="72.62,-67.7 0.13,-67.7 0.13,-43.1 72.62,-43.1 72.62,-67.7"></polygon>
<text text-anchor="middle" x="36.37" y="-51.2" font-family="Times,serif" font-size="14.00">fooHelper</text>
</g>
<!-- Function0#apply -->
<g id="node2" class="node">
<title>Function0#apply</title>
<polygon fill="none" stroke="black" points="219.57,-45.7 108.81,-45.7 108.81,-21.1 219.57,-21.1 219.57,-45.7"></polygon>
<text text-anchor="middle" x="164.19" y="-29.2" font-family="Times,serif" font-size="14.00">Function0#apply</text>
</g>
<!-- fooHelper&#45;&gt;Function0#apply -->
<g id="edge1" class="edge">
<title>fooHelper-&gt;Function0#apply</title>
<path fill="none" stroke="black" d="M72.76,-49.21C80.89,-47.79 89.78,-46.24 98.72,-44.67"></path>
<polygon fill="black" stroke="black" points="99.55,-48.08 108.8,-42.91 98.34,-41.19 99.55,-48.08"></polygon>
</g>
<!-- fooTask -->
<g id="node3" class="node">
<title>fooTask</title>
<polygon fill="none" stroke="black" points="317.44,-67.7 255.69,-67.7 255.69,-43.1 317.44,-43.1 317.44,-67.7"></polygon>
<text text-anchor="middle" x="286.57" y="-51.2" font-family="Times,serif" font-size="14.00">fooTask</text>
</g>
<!-- Function0#apply&#45;&gt;fooTask -->
<g id="edge2" class="edge">
<title>Function0#apply-&gt;fooTask</title>
<path fill="none" stroke="black" d="M219.74,-43.37C228.4,-44.95 237.22,-46.56 245.47,-48.07"></path>
<polygon fill="black" stroke="black" points="245.09,-51.56 255.56,-49.92 246.35,-44.67 245.09,-51.56"></polygon>
</g>
<!-- barTask -->
<g id="node5" class="node">
<title>barTask</title>
<polygon fill="none" stroke="black" points="317.15,-24.7 255.98,-24.7 255.98,-0.1 317.15,-0.1 317.15,-24.7"></polygon>
<text text-anchor="middle" x="286.57" y="-8.2" font-family="Times,serif" font-size="14.00">barTask</text>
</g>
<!-- Function0#apply&#45;&gt;barTask -->
<g id="edge4" class="edge">
<title>Function0#apply-&gt;barTask</title>
<path fill="none" stroke="black" d="M219.74,-23.88C228.59,-22.34 237.6,-20.77 246,-19.3"></path>
<polygon fill="black" stroke="black" points="246.64,-22.74 255.89,-17.58 245.44,-15.85 246.64,-22.74"></polygon>
</g>
<!-- barHelper -->
<g id="node4" class="node">
<title>barHelper</title>
<polygon fill="none" stroke="black" points="72.34,-24.7 0.41,-24.7 0.41,-0.1 72.34,-0.1 72.34,-24.7"></polygon>
<text text-anchor="middle" x="36.37" y="-8.2" font-family="Times,serif" font-size="14.00">barHelper</text>
</g>
<!-- barHelper&#45;&gt;Function0#apply -->
<g id="edge3" class="edge">
<title>barHelper-&gt;Function0#apply</title>
<path fill="none" stroke="black" d="M72.42,-18.25C80.56,-19.61 89.47,-21.1 98.44,-22.59"></path>
<polygon fill="black" stroke="black" points="98.1,-26.08 108.54,-24.28 99.25,-19.18 98.1,-26.08"></polygon>
</g>
</g>
</svg>

</center>
</div>
<div class="paragraph">
<p>As a compromise, for lambdas and SAM types, we instead use the other heuristic: we instead
consider them called <em>once they are instantiated</em>, ignoring whether or not there is a callsite.
This is still conservatively correct, and can still have false positives if someone instantiates
a lambda or SAM they never call. But people generally don’t do that, and so empirically it
provides a much more precise callgraph.</p>
</div>
<div class="paragraph">
<center>
<svg width="179px" height="76px" viewBox="0.00 0.00 178.62 75.80" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1.0 1.0) rotate(0.0) translate(4.0 71.8)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-71.8 174.62,-71.8 174.62,4 -4,4"></polygon>
<!-- fooHelper -->
<g id="node1" class="node">
<title>fooHelper</title>
<polygon fill="none" stroke="black" points="72.62,-24.7 0.13,-24.7 0.13,-0.1 72.62,-0.1 72.62,-24.7"></polygon>
<text text-anchor="middle" x="36.37" y="-8.2" font-family="Times,serif" font-size="14.00">fooHelper</text>
</g>
<!-- fooTask -->
<g id="node2" class="node">
<title>fooTask</title>
<polygon fill="none" stroke="black" points="170.56,-24.7 108.81,-24.7 108.81,-0.1 170.56,-0.1 170.56,-24.7"></polygon>
<text text-anchor="middle" x="139.68" y="-8.2" font-family="Times,serif" font-size="14.00">fooTask</text>
</g>
<!-- fooHelper&#45;&gt;fooTask -->
<g id="edge1" class="edge">
<title>fooHelper-&gt;fooTask</title>
<path fill="none" stroke="black" d="M72.81,-12.4C81.08,-12.4 89.96,-12.4 98.42,-12.4"></path>
<polygon fill="black" stroke="black" points="98.48,-15.9 108.48,-12.4 98.48,-8.9 98.48,-15.9"></polygon>
</g>
<!-- barHelper -->
<g id="node3" class="node">
<title>barHelper</title>
<polygon fill="none" stroke="black" points="72.34,-67.7 0.41,-67.7 0.41,-43.1 72.34,-43.1 72.34,-67.7"></polygon>
<text text-anchor="middle" x="36.37" y="-51.2" font-family="Times,serif" font-size="14.00">barHelper</text>
</g>
<!-- barTask -->
<g id="node4" class="node">
<title>barTask</title>
<polygon fill="none" stroke="black" points="170.27,-67.7 109.1,-67.7 109.1,-43.1 170.27,-43.1 170.27,-67.7"></polygon>
<text text-anchor="middle" x="139.68" y="-51.2" font-family="Times,serif" font-size="14.00">barTask</text>
</g>
<!-- barHelper&#45;&gt;barTask -->
<g id="edge2" class="edge">
<title>barHelper-&gt;barTask</title>
<path fill="none" stroke="black" d="M72.52,-55.4C80.97,-55.4 90.06,-55.4 98.71,-55.4"></path>
<polygon fill="black" stroke="black" points="98.98,-58.9 108.98,-55.4 98.98,-51.9 98.98,-58.9"></polygon>
</g>
</g>
</svg>

</center>
</div>
<div class="paragraph">
<p>With the adjusted handling of lambdas and SAM types, with the various lambdas assumed to
be called immediately where-ever they were defined, the callgraph becomes a lot more
precise and useful,</p>
</div>
</div>
<div class="sect2">
<h3 id="_task_returning_methods"><a class="anchor" href="#_task_returning_methods"></a>Task-returning Methods</h3>
<div class="paragraph">
<p>We special case methods that return <code>Task</code> to not participate in the callgraph analysis.
By removing <code>Task</code> methods from the callgraph analysis, we are essentially making the
assumption that these methods do not have side effects, and any change will be tracked at
runtime anyway by the <em>build graph</em> we discussed at the start of this article.</p>
</div>
<div class="paragraph">
<p>Allowing <code>Task</code> methods to participate is problematic because these methods are often
defined as part of <code>abstract class</code>s or <code>trait</code>s in upstream libraries with many
such methods. With the simplified handling of <a href="#_library_methods">Library Methods</a> above, this results
in any call to a <code>Task</code> method potentially calling every other <code>Task</code> method, which
again while conservatively correct renders the callgraph imprecise enough to be useless.</p>
</div>
<div class="paragraph">
<p>The assumption that methods returning <code>Task</code> do not have side effects is
not enforced: there is nothing to stop you from performing side effects and mutating
variables in a method that returns a <code>Task</code>. But in practice nobody does that, so this
turns out to be a fine assumption to make.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_limitations"><a class="anchor" href="#_limitations"></a>Limitations</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_no_data_flow_analysis"><a class="anchor" href="#_no_data_flow_analysis"></a>No Data Flow Analysis</h3>
<div class="paragraph">
<p>The biggest limitation of using method <em>callgraph analysis</em> to detect code changes affecting
tasks is the lack of <em>dataflow analysis</em>: we are simply aggregating all methods that get
called (transitively) by a task, but we don’t actually know if those methods actually
affect the task output. For example, consider the following snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">def barSource = Task.Source(&quot;bar.txt&quot;)
class Qux(suffix0: String) {
  val suffix = suffix0 + suffix0 + suffix0
  def bazHelper(s: String) = s.toUpperCase + suffix
}

def barTask = Task{
  println(&quot;evaluating barTask&quot;)
  val qux = new Qux(&quot;!&quot;)
  qux.bazHelper(os.read(barSource().path))
} // BAR.TXT CONTENTS!!!</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Qux#&lt;init&gt;</code> method has the following bytecode:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">  public Qux(java.lang.String);
       0: aload_0
       1: invokespecial #13         // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
       4: aload_0
       5: new           #15         // class java/lang/StringBuilder
       8: dup
       9: ldc           #16         // int 0
      11: invokespecial #19         // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:(I)V
      14: aload_1
      15: invokevirtual #23         // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      18: aload_1
      19: invokevirtual #23         // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      22: aload_1
      23: invokevirtual #23         // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      26: invokevirtual #27         // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      29: putfield      #29         // Field suffix:Ljava/lang/String;
      32: return</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we modify this by adding a second unused field:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-diff hljs" data-lang="diff"> class Qux(suffix0: String) {
   val suffix = suffix0 + suffix0 + suffix0
+  val otherSuffix = suffix0
   def bazHelper(s: String) = s.toUpperCase + suffix
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This results in a corresponding change to the bytecode to initialize the new field:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-diff hljs" data-lang="diff">  public Qux(java.lang.String);
       0: aload_0
       1: invokespecial #14         // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
       4: aload_0
       5: new           #16         // class java/lang/StringBuilder
       8: dup
       9: ldc           #17         // int 0
      11: invokespecial #20         // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:(I)V
      14: aload_1
      15: invokevirtual #24         // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      18: aload_1
      19: invokevirtual #24         // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      22: aload_1
      23: invokevirtual #24         // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      26: invokevirtual #28         // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      29: putfield      #30         // Field suffix:Ljava/lang/String;
+     32: aload_0
+     33: aload_1
+     34: putfield      #32         // Field otherSuffix:Ljava/lang/String;
      37: return</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which affects <code>barTask</code>, because our callgraph has <code>Qux#&lt;init&gt;</code> being called by <code>barTask</code></p>
</div>
<div class="paragraph">
<center>
<svg width="210px" height="76px" viewBox="0.00 0.00 209.71 75.80" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1.0 1.0) rotate(0.0) translate(4.0 71.8)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-71.8 205.71,-71.8 205.71,4 -4,4"></polygon>
<!-- Qux#bazHelper -->
<g id="node1" class="node">
<title>Qux#bazHelper</title>
<polygon fill="none" stroke="black" points="104.43,-67.7 0.19,-67.7 0.19,-43.1 104.43,-43.1 104.43,-67.7"></polygon>
<text text-anchor="middle" x="52.31" y="-51.2" font-family="Times,serif" font-size="14.00">Qux#bazHelper</text>
</g>
<!-- barTask -->
<g id="node2" class="node">
<title>barTask</title>
<polygon fill="none" stroke="red" stroke-width="3" points="201.75,-45.7 140.58,-45.7 140.58,-21.1 201.75,-21.1 201.75,-45.7"></polygon>
<text text-anchor="middle" x="171.17" y="-29.2" font-family="Times,serif" font-size="14.00">barTask</text>
</g>
<!-- Qux#bazHelper&#45;&gt;barTask -->
<g id="edge1" class="edge">
<title>Qux#bazHelper-&gt;barTask</title>
<path fill="none" stroke="black" d="M104.57,-45.75C113.29,-44.11 122.22,-42.43 130.58,-40.85"></path>
<polygon fill="black" stroke="black" points="131.26,-44.29 140.44,-39 129.96,-37.41 131.26,-44.29"></polygon>
</g>
<!-- Qux#&lt;init&gt; -->
<g id="node3" class="node">
<title>Qux#&lt;init&gt;</title>
<polygon fill="none" stroke="red" stroke-width="3" points="92.88,-24.7 11.74,-24.7 11.74,-0.1 92.88,-0.1 92.88,-24.7"></polygon>
<text text-anchor="middle" x="52.31" y="-8.2" font-family="Times,serif" font-size="14.00">Qux#&lt;init&gt;</text>
</g>
<!-- Qux#&lt;init&gt;&#45;&gt;barTask -->
<g id="edge2" class="edge">
<title>Qux#&lt;init&gt;-&gt;barTask</title>
<path fill="none" stroke="red" stroke-width="3" d="M93.2,-19.57C105.17,-21.72 118.29,-24.08 130.26,-26.23"></path>
<polygon fill="red" stroke="red" stroke-width="3" points="129.96,-29.73 140.42,-28.05 131.19,-22.84 129.96,-29.73"></polygon>
</g>
</g>
</svg>

</center>
</div>
<div class="paragraph">
<p>However, if you actually track the dataflow of the code, we would realize that
the field <code>otherSuffix</code> is not used by <code>barTask</code> at all! Only <code>suffix</code> is used.
Thus although our <code>Qux#&lt;init&gt;</code> was affected by the code change, <code>barTask</code> isn’t
actually affected, and so invalidating <code>barTask</code> and forcing a re-evaluation would
be wasteful and unnecessary.</p>
</div>
<div class="paragraph">
<p>This is perhaps the largest gap in the callgraph analysis we present here: while
we are able to analyze the dependencies between <em>methods</em> based on how they call each
other via <code>invokevirtual</code> or <code>invokespecial</code> bytecodes, we are unable to analyze
the dependencies between the <em>fields</em> that those methods set or the <em>values</em> that they
return. This can result in false positives where changes to constructors or other
methods cause our tasks to invalidate unnecessarily.</p>
</div>
</div>
<div class="sect2">
<h3 id="_reflection"><a class="anchor" href="#_reflection"></a>Reflection</h3>
<div class="paragraph">
<p>Another major limitation in this analysis is that it assumes that all method calls
in your program are statically specified in the bytecode. This is not true of JVM applications
in general: anyone can call <code>Class.getMethod(methodName).invoke()</code> with a dynamically
computed <code>methodName: String</code>, leaving static bytecode analysis with no way to figure out
what method is actually being called:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">def barSource = Task.Source(&quot;bar.txt&quot;)
class Qux(suffix0: String) {
  val suffix = suffix0 + suffix0 + suffix0
  def bazHelper(s: String) = s.toUpperCase + suffix
}

def barTask = Task{
  println(&quot;evaluating barTask&quot;)
  val qux = new Qux(&quot;!&quot;)
  val b = &quot;baz&quot;
  val h = &quot;helper&quot;
  classOf[Qux]
    .getMethod(b + h.capitalize, classOf[String])
    .invoke(qux, os.read(barSource().path))
} // BAR.TXT CONTENTS!!!</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the <code>getMethod</code> call takes the method name as <code>b + h.capitalize</code>, but in
general it could require arbitrary runtime computation to decide what method to call. While
it is possible to figure out this out in some cases (e.g. the Graal Native Image analyzer gives a
<a href="https://www.graalvm.org/jdk21/reference-manual/native-image/dynamic-features/Reflection/#automatic-detection">best effort attempt</a> at doing so)
there will always be scenarios where the reflection cannot be figured out statically.</p>
</div>
<div class="paragraph">
<p>Unlike the limitation above that results in false
positives, this limitation can result in false negatives where a method called by a
task changes and the task does not re-evaluate, because the method call happened via
<code>getMethod.invoke</code> which our analyzer cannot understand.</p>
</div>
<div class="paragraph">
<p>Although in theory this could be an issue, in typical Scala code (which <code>build.mill</code> files
are written in) runtime reflection is relatively rare. Scala codebases and libraries tend
to perform a lot of their work at compile-time: inferring types, resolving implicit parameters,
expanding macros, and so on. While that means the compiler is more complicated, it also means
the bytecode that gets output by the compiler is much simpler, without
the runtime reflection/classloading/classpath-scanning logic often present in Java codebases.
Thus, Mill can analyze the JVM bytecode emitted by a Scala program with high confidence
that the callgraph defined in the bytecode gives a complete and accurate picture of how
the methods in the program call each other.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_evaluation"><a class="anchor" href="#_evaluation"></a>Evaluation</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_precision"><a class="anchor" href="#_precision"></a>Precision</h3>
<div class="paragraph">
<p>To test out how well this works in practice, I ran a number of manual tests to exercise
the callgraph analysis, using Mill’s own Mill build as the test case.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Adding a whitespace at the top of <code>build.mill</code>, to offset everyone’s line numbers without changing their logic,
invalidates <code>16/8154</code> tasks, all downstream of <code>millVersion</code> which is invalidated by the dirty hash of
the repo checkout changing</p>
</li>
<li>
<p>Changing <code>scalajslib.worker[1].mvnDeps</code> by re-ordering them, invalidates <code>17/8154</code> tasks
(just the ones above, + the one edited)</p>
</li>
<li>
<p>Changing <code>MillScalaModule#scalacOptions</code> by removing <code>-feature</code>, invalidates <code>836/8154</code> tasks</p>
</li>
<li>
<p>Changing <code>contrib.playlib.WorkerModule#sources</code> generating a temporary file, invalidates <code>37/8154</code>
tasks, mostly stuff in <code>contrib.playlib.worker[_]</code></p>
</li>
<li>
<p>Changing a constant <code>Deps.scalaVersion</code> ends up invalidating ~<code>4343/8154</code> tasks. I skimmed through the
results and they seem reasonable: all <code>.scalaVersion</code> and <code>.compile</code> tasks end up invalidated, while
many external tasks aren’t invalidated because they don’t have any local code to be affected by the
callgraph analysis and their upstream build graph is not affected by <code>Deps.scalaVersion</code> (e.g.
<code>integration.test.javacOptions</code>,` contrib.codeartifact.mandatoryScalacOptions`)</p>
</li>
<li>
<p>Adding a new <code>val abc = 123</code> to the root module invalidates everything, which is expected since it
changes the constructor of build which could potentially affect any module nested within it, and
Mill has <a href="#_no_data_flow_analysis">No Data Flow Analysis</a> to determine that this change in the module constructor has no effect.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In general, Mill’s fine-grained task invalidation via bytecode callgraph analysis
works as expected: in many cases where the change is trivial it is able to narrow down the
effect of the change and reduce the number of tasks we need to invalidate, although for
wide-ranging changes (e.g. <code>Deps.scalaVersion</code>) it still ends up invalidating a large number
of tasks, and there are some known limitations around the treatment of <code>val</code> fields where the
invalidation is less fine grained than it could be. Compared to earlier versions of Mill
which aggressively invalidated all caches on every single change, this was a big improvement!</p>
</div>
</div>
<div class="sect2">
<h3 id="_performance"><a class="anchor" href="#_performance"></a>Performance</h3>
<div class="paragraph">
<p>Performance-wise, ad-hoc benchmarks on com-lihaoyi/mill’s own build show a
~5% increase in <code>build.mill</code> compilation times due to the cost of the bytecode callgraph analysis.</p>
</div>
<div class="paragraph">
<p>Mill’s callgraph analysis is written as a post-processing step on the <code>.class</code> files that are
generated by the Scala compiler that Mill uses to compile it’s <code>build.mill</code> and <code>package.mill</code>
files. The analysis computes a hash for every method representing its own implementation and that
of transitively called methods, and saves that to a <code>methodCodeHashSignatures.json</code> file for
the Mill evaluator to include in Task cache keys at runtime. Thus it is easy to separate
the time taken for each phase, which I have done below:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;" />
<col style="width: 33.3333%;" />
<col style="width: 33.3334%;" />
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">methodCodeHashSignatures</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">compile</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cold</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">685ms</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12,148ms</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hot</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">253ms</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4,143ms</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>This slowdown is not negligible, but it is
acceptable: the cost is only paid when the <code>build.mill</code> is re-compiled, and it will
likely end up saving much more time in tasks that we can avoid running (e.g. a
single no-op Zinc incremental compile may be 100s of milliseconds). The bytecode callgraph
analysis can likely be further optimized in future if necessary.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion"><a class="anchor" href="#_conclusion"></a>Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Mill’s callgraph bytecode analysis landed in <a href="https://github.com/com-lihaoyi/mill/pull/2417">#2417</a>
in Mill <a href="https://github.com/com-lihaoyi/mill/blob/main/changelog.adoc#0112---2023-08-28">0.11.2</a>.
The implementation is surprisingly small: ~1k lines of code for the main implementation using
the <a href="https://asm.ow2.io/">OW2 ASM library</a> for bytecode parsing, and ~6k lines
of test cases. That small amount of code took several months to research and write and debug,
but since then it has worked great without any major issues.</p>
</div>
<div class="paragraph">
<p>Although the callgraph analysis can be imprecise and sometimes unpredictable, as long as it
is conservatively correct it won’t cause any semantic problems. Mill builds are already meant
to be composed of pure build tasks, so a task re-evaluating spuriously won’t cause any behavioral
changes other than having to wait slightly longer for your CLI commands to finish.</p>
</div>
<div class="paragraph">
<p>One nice side effect of working on JVM classfiles and bytecode is that the analysis
did not need to change when upgrading from Scala 2 to Scala 3, whereas an approach based
on Scala compiler internals (e.g. <a href="https://plg.uwaterloo.ca/~olhotak/pubs/ecoop14.pdf">Constructing Call Graphs of Scala Programs, ECOOP 2014</a>)
would have had to be re-implemented from scratch. It also means Mill can handle both Java
and Scala code (and upstream libraries) using the same analysis.</p>
</div>
<div class="paragraph">
<p>Future work may include</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Rolling out some version of this analysis to application code, rather than just build configuration code.
In particular, we could use this same approach to select the relevant tests to run based on what code changes
the developer is making, and there is an <a href="https://github.com/com-lihaoyi/mill/issues/4109">open bounty to implement that</a></p>
</li>
<li>
<p>Implementing data-flow analysis. As mentioned above, the fact that we only analyze callgraphs and not dataflow
is a major weakness in this analysis, which results in a lot of spurious task invalidations. Dataflow analysis on
JVM bytecode is very common, and an implementation would greatly increase the precision of Mill’s analysis</p>
</li>
</ol>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="11-jvm-test-parallelism.html">Strategies for Efficiently Parallelizing JVM Test Suites</a></span>
  <span class="next"><a href="9-mill-faster-assembly-jars.html">Fast Incremental JVM Assembly Jar Creation with Mill</a></span>
</nav>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../_/js/site.js" data-ui-root-path="../_"></script>
<script async="async" src="../_/js/vendor/highlight.js"></script>
<script src="../_/js/vendor/lunr.js"></script>
<script src="../_/js/search-ui.js" id="search-ui-script" data-site-root-path=".." data-snippet-length="100" data-stylesheet="../_/css/search.css"></script>
<script async="async" src="../search-index.js"></script>
  
</body></html>