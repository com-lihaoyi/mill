<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Mill as a Direct Style Build Tool :: The Mill Build Tool</title>
    <link rel="canonical" href="https://mill-build.org/blog/12-direct-style-build-tool.html">
    <link rel="prev" href="index.html">
    <link rel="next" href="11-jvm-test-parallelism.html">
    <meta name="generator" content="Antora 3.1.9">
    <link rel="stylesheet" href="../_/css/site.css">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1C582ZJR85"></script>
    <script>function gtag(){dataLayer.push(arguments)};window.dataLayer=window.dataLayer||[];gtag('js',new Date());gtag('config','G-1C582ZJR85')</script>
<link rel="icon" href="../_/favicon.png" type="image/x-icon">
  </head>
  <body class="article">
<header class="header">
  <style>
  /* auto-hyphenation is super ugly */
  *{
    hyphens: manual !important;
  }

  /* Reduce font size from 17px to something reasonable */
  .doc {
   font-size: 16px !important;
  }
  .doc pre {
   font-size: 14px !important;
  }
  /* Shrink unreasonably large top bar */
  nav.navbar{
    height: 2.5rem;
  }
  body.article{
    padding-top: 2.5rem;
  }
  div.nav-container{
    top: 2.5rem;
  }
  div.toolbar{
    top: 2.5rem;
  }
  aside.nav{
    top: 2.5rem;
    height: calc(100vh - 2.5rem);
  }
  </style>
  <script>
  gtag('config', 'AW-16649289906');

  document.addEventListener('DOMContentLoaded', function() {
  const links = document.querySelectorAll('a');
    links.forEach(link => {
      if (link.textContent.trim().toLowerCase() === 'download') {
        link.addEventListener('click', function(event) {
          console.log("download link clicked")
          gtag('event', 'conversion', {'send_to': 'AW-16649289906/rsphCKfVq8QZELKBgIM-'});
        });
      }
    });
  });
  </script>
  <nav class="navbar">
    <div class="navbar-brand">
      <!-- TODO: add mill icon -->
      <a class="navbar-item" href="https://mill-build.org"><img src="../_/logo-white.svg" height="20" />&nbsp;The Mill Build Tool</a>
      <div class="navbar-item search">
        <input id="search-input" type="text" placeholder="Search the docs">
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/com-lihaoyi/mill">GitHub</a>
        <a class="navbar-item" href="https://mill-build.org/blog/index.html">Blog</a>
        <a class="navbar-item" href="https://mill-build.org/api/latest/index.html">API</a>
        <a class="navbar-item" href="https://github.com/com-lihaoyi/mill/issues">Issues</a>
        <a class="navbar-item" href="https://github.com/com-lihaoyi/mill/discussions">Discuss</a>


            <!--
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Documentation</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#"></a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Plugins</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Resource A</a>
            <a class="navbar-item" href="#">Resource B</a>
            <a class="navbar-item" href="#">Resource C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
        -->
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="blog" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
<ul class="nav-list">

  <li class="nav-item" data-depth="0">
<ul class="nav-list">

  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="12-direct-style-build-tool.html">Mill as a Direct Style Build Tool</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="11-jvm-test-parallelism.html">Strategies for Efficiently Parallelizing JVM Test Suites</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="10-bytecode-callgraph-analysis.html">Invalidating build caches using JVM bytecode callgraph analysis</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="9-mill-faster-assembly-jars.html">Fast Incremental JVM Assembly Jar Creation with Mill</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="8-what-is-a-build-tool.html">What does a Build Tool do?</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="7-graal-native-executables.html">How to Compile Java into Native Binaries with Mill and Graal</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="6-garbage-collector-perf.html">Understanding JVM Garbage Collector Performance</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="5-executable-jars.html">How JVM Executable Assembly Jars Work</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="4-flaky-tests.html">How To Manage Flaky Tests in your CI Workflows</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="3-selective-testing.html">Faster CI with Selective Testing</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="2-monorepo-build-tool.html">Why Use a Monorepo Build Tool?</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="1-java-compile.html">How Fast Does Java Compile?</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">The Mill Build Engineering Blog</span>
    <span class="version"></span>
  </div>
  <ul class="components">
    <li class="component">
      <div class="title"><a href="../mill/index.html">Mill Documentation</a></div>
      <ul class="versions">
        <li class="version">
          <a href="../mill/main-branch/index.html">main-branch</a>
        </li>
        <li class="version">
          <a href="../mill/dev-1.0.0-M1-51-eb0851/index.html">dev-1.0.0-M1-51-eb0851</a>
        </li>
        <li class="version is-latest">
          <a href="../mill/index.html">0.12.14</a>
        </li>
        <li class="version">
          <a href="../mill/0.11.x/index.html">0.11.13</a>
        </li>
        <li class="version">
          <a href="../mill/0.10.15/index.html">0.10.15</a>
        </li>
        <li class="version">
          <a href="../mill/0.9.12/index.html">0.9.12</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <div class="title"><a href="index.html">The Mill Build Engineering Blog</a></div>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">

<div class="toolbar" role="navigation" style="position: fixed; top: 2.5rem; height: 2rem; left: 0px;">
<button class="nav-toggle"></button>
</div>
<div class="toolbar" style="position: fixed; top: 2.5rem; height: 1.5rem; right: 0px; ">
<div class="edit-this-page"><a href="https://github.com/com-lihaoyi/mill/edit/main/out/website/blogFolder.dest/modules/ROOT/pages/12-direct-style-build-tool.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Mill as a Direct Style Build Tool</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><em>Li Haoyi, 10 May 2025</em></p>
</div>
<div class="paragraph">
<p><a href="https://mill-build.org">Mill</a> is a JVM build tool that targets Java/Scala/Kotlin and has
potential to serve the large-monorepo codebases that Bazel currently serves. Mill has good
traction among its users, benchmarks that demonstrate 3-6x faster builds than its competitors,
and a unique "direct-style" design that make it easy to use and extend. This page discusses
one of the most interesting design decisions in Mill, and how it sets Mill apart from
other build tools on the market.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_is_a_build_tool"><a class="anchor" href="#_what_is_a_build_tool"></a>What is a Build Tool?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A build tool is a program that coordinates the various tasks necessary to compile,
package, test, and run a codebase: maybe you need to run a compiler, download some dependencies,
package an executable or container. While a small codebase can get by with a shell script that
runs every task every time one at a time, such a naive approach gets slower
and slower as a codebase grows and the build tasks necessarily get more numerous and complex.</p>
</div>
<div class="paragraph">
<p>In order to prevent development from grinding to a halt, you need to begin skipping the
build tasks you do not need at any point in time, and caching
and parallelizing those that you do. This often starts
off as some ad-hoc if-else statements in a shell script, but manually maintaining
skipping/caching/parallelization logic is tedious and error-prone. At some point it becomes
worthwhile to use an purpose built tool to do it for you, and that is when you turn
to build tools like <a href="https://maven.apache.org/">Maven</a>, <a href="https://www.gnu.org/software/make/">Make</a>,
<a href="https://mill-build.org/">Mill</a>, or <a href="https://bazel.build/">Bazel</a>. For this article,
we will mostly discuss Mill.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_is_mill"><a class="anchor" href="#_what_is_mill"></a>What is Mill?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Mill build tool was started in 2017, an exploration of the ideas I
found when learning to use Google&#8217;s <a href="https://bazel.build/">Bazel</a> build tool.
At a glance, Mill looks similar to other build tools you may be familiar with, with a
<code>build.mill</code> file in the root of a project defining the dependencies and testing
setup for a module:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">package build
import mill._, javalib._

object foo extends JavaModule {
  def mvnDeps = Seq(
    mvn"net.sourceforge.argparse4j:argparse4j:0.9.0",
    mvn"org.thymeleaf:thymeleaf:3.1.1.RELEASE"
  )

  object test extends JavaTests with TestModule.Junit4
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The syntax may be a bit unfamiliar, but anyone familiar with programming can probably guess
what this build means: a <code>JavaModule</code> with two ivy dependencies <code>argparse4j</code> and <code>thymeleaf</code>,
and a <code>test</code> submodule supporting <code>Junit4</code>.
This build can then be compiled, tested, run, or packaged into an assembly from the command line:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-console hljs" data-lang="console">&gt; /mill foo.compile
compiling 1 Java source...

&gt; /mill foo.run --text hello
&lt;h1&gt;hello&lt;/h1&gt;

&gt; ./mill foo.test
Test foo.FooTest.testEscaping finished, ...
Test foo.FooTest.testSimple finished, ...
0 failed, 0 ignored, 2 total, ...

&gt; ./mill show foo.assembly
".../out/foo/assembly.dest/out.jar"

&gt; ./out/foo/assembly.dest/out.jar --text hello
&lt;h1&gt;hello&lt;/h1&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mill was originally a Scala build tool competing with <a href="https://scala-sbt.org/"><code>sbt</code></a>, and by 2023 it
had reached around 5-10% market share in the Scala community
(<a href="https://www.jetbrains.com/lp/devecosystem-2023/scala/">Jetbrains Survey</a>,
<a href="https://scalasurvey2023.virtuslab.com/">VirtusLabs Survey</a>).
It recently grew first-class Java support, demonstrating
<a href="../mill/comparisons/why-mill.html" class="xref page">3-6x speedups</a> over existing Java build tools
like Maven or Gradle. Mill also has gained experimental support for Java-adjacent platforms
like <a href="../mill/kotlinlib/intro.html" class="xref page">Kotlin</a> and
<a href="../mill/android/java.html" class="xref page">Android</a>, and has demonstrated the ability to branch out into supporting
more distant toolchains like <a href="../mill/extending/example-typescript-support.html" class="xref page">Typescript</a>
and <a href="../mill/extending/example-python-support.html" class="xref page">Python</a>.</p>
</div>
<div class="paragraph">
<p>Mill also works well with <a href="../mill/large/large.html" class="xref page">large builds</a>: its build logic can be
<a href="../mill/large/multi-file-builds.html" class="xref page">split into multiple folders</a>, is incrementally compiled,
lazily initialized, and automatically cached and parallelized. That means that even large
codebases can remain fast and responsive: Mill&#8217;s own build easily manages over 400 modules,
and the tool can likely handle thousands of modules without issue.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_react_js_of_build_tools"><a class="anchor" href="#_the_react_js_of_build_tools"></a>The React.js of Build Tools</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We&#8217;ve briefly covered what Mill is above, but one question remains: why Mill?
Why not one of the other 100 build tools out there?</p>
</div>
<div class="paragraph">
<p>Mill is unique in that it shares many of its core design decisions with <a href="https://react.dev/">React.js</a>,
the popular Javascript UI framework. I was among the first external users of React when I
introduced it to Dropbox in 2014, and while people gripe about it today, React was
really a revolution in how Javascript UIs were implemented. UI flows that used to take
weeks suddenly took days, requiring a fraction of the code and complexity that they
previously took to implement</p>
</div>
<div class="paragraph">
<p>React&#8217;s two most important innovations are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Letting users write "direct style" code to define their UI - Javascript functions that
directly returned the HTML structure you wanted - rather than a "code behind"
approach of registering callbacks to mutate the UI in response to events</p>
</li>
<li>
<p>Using a single "general purpose" programming language for your UI, rather than splitting
your logic into multiple special-purpose domain-specific languages</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>While React does a huge number of clever things -
<a href="https://legacy.reactjs.org/docs/faq-internals.html">virtual dom diffing</a>,
<a href="https://react.dev/learn/writing-markup-with-jsx">JSX</a>,
<a href="https://react.dev/reference/react-dom/client/hydrateRoot">de/re-hydration</a>,
etc. - all of those are only in service of the two fundamental ideas. e.g. At Dropbox we
used React for years without JSX, and many of the later frameworks inspired by React
provide a similar experience but use other techniques to replace virtual dom diffing.
Furthermore, React isn&#8217;t limited to the HTML UIs, with the same techniques being
used to manage <a href="https://reactnative.dev/">mobile app UIs</a>,
<a href="https://github.com/vadimdemedes/ink">terminal UIs</a>, and many other scenarios</p>
</div>
<div class="paragraph">
<p>Build tools and interactive UIs are on one hand different, but on the other hand
very similar: you are trying to update a large stateful system (whether a HTML page
or filesystem build artifacts) to your desired state in response to change in inputs
(whether user-clicks or source-file-edits). Like with React in 2014, these two ideas are
not widespread among build tools today in 2024. But many of the same downstream benefits apply,
and these ideas give Mill some unique properties as a build tool.</p>
</div>
<div class="sect2">
<h3 id="_direct_style_builds"><a class="anchor" href="#_direct_style_builds"></a>Direct-Style Builds</h3>
<div class="paragraph">
<p>One key aspect of React.js is that you wrote your code to generate your web UI "directly":</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Before React, you would write Javascript code whose purpose was to mutate some HTML properties
to set up a forest of callbacks and event handlers. These would then be executed when a user
interacted with your website, causing further mutations to the HTML UI. This would often
recursively trigger other callbacks with further mutations, and you as the developer would
somehow need to ensure this all converges to the UI state that you desire.</p>
</li>
<li>
<p>In React, you had normal functions containing normal code that executed top-to-bottom,
each returning a JSX HTML snippet - really just a Javascript object - with the top-level
component eventually returning a snippet representing the entire UI. React would handle
all the update logic for you in an efficient manner, incrementally caching and optimizing
things automatically. The developer just naively returns the UI structure they want from
their React code and React.js does all the rest</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Before React you always had a tradeoff: do you re-render the whole UI every update (which
is easy to implement naively, but wasteful and disruptive to users) or do you do fine-grained UI
updates (which was difficult to implement, but efficient and user-friendly). React eliminated that
tradeoff, letting the developer write "naive" code as if they were re-rendering the entire
UI, while automatically optimizing it to be performant and provide a first-class user experience.</p>
</div>
<div class="paragraph">
<p>Mill&#8217;s approach as a build tool is similar:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Most existing build tools involve registering "task" callbacks to tell the build tool what
to do when certain actions happen or certain files change. These callbacks mutate the filesystem
in an ad-hoc manner, often recursively triggering further callbacks. It is up to the developer
to make sure that these callbacks and filesystem updates end up converging such that
your build outputs ends up containing the files you want.</p>
</li>
<li>
<p>With Mill, you instead write "direct-style" code: normal functions that call other
functions and end up returning the final metadata or files that were generated.
Mill handles the work of computing these functions efficiently: automatically caching,
parallelizing, and optimizing your build. The developer writes naive code computing and
returning the files they want, and Mill does all the rest to make it efficient and performant</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Earlier we saw a hello-world Mill build using the built in module types like <code>JavaModule</code>,
but if we remove these built in classes we can see how Mill works under the hood. Consider
the following Mill tasks that define some source files, use the <code>javac</code> executable to compile
them into classfiles, and then the <code>jar</code> executable to package them together into an assembly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">def mainClass: T[Option[String]] = Some("foo.Foo")

def sources = Task.Source("src")
def resources = Task.Source("resources")

def compile = Task {
  val allSources = os.walk(sources().path)
  os.proc("javac", allSources, "-d", Task.dest).call()
  PathRef(Task.dest)
}

def assembly = Task {
  for(p &lt;- Seq(compile(), resources())) os.copy(p.path, Task.dest, mergeFolders = true)

  val mainFlags = mainClass().toSeq.flatMap(Seq("-e", _))
  os.proc("jar", "-c", mainFlags, "-f", Task.dest / "assembly.jar", ".")
    .call(cwd = Task.dest)

  PathRef(Task.dest / "assembly.jar")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This code defines the following task graph, with the boxes being the tasks
and the arrows representing the <em>data-flow</em> between them:</p>
</div>
<div class="paragraph">
<center>
<svg width="280px" height="119px"
 viewBox="0.00 0.00 280.41 118.80" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1.0 1.0) rotate(0.0) translate(4.0 114.8)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-114.8 276.41,-114.8 276.41,4 -4,4"/>
<!-- sources -->
<g id="node1" class="node">
<title>sources</title>
<polygon fill="white" stroke="black" points="57.97,-110.7 0.01,-110.7 0.01,-86.1 57.97,-86.1 57.97,-110.7"/>
<text text-anchor="middle" x="28.99" y="-94.2" font-family="Times,serif" font-size="14.00">sources</text>
</g>
<!-- compile -->
<g id="node2" class="node">
<title>compile</title>
<polygon fill="white" stroke="black" points="161.74,-110.7 100.54,-110.7 100.54,-86.1 161.74,-86.1 161.74,-110.7"/>
<text text-anchor="middle" x="131.14" y="-94.2" font-family="Times,serif" font-size="14.00">compile</text>
</g>
<!-- sources&#45;&gt;compile -->
<g id="edge1" class="edge">
<title>sources&#45;&gt;compile</title>
<path fill="none" stroke="black" d="M58.15,-98.4C68.15,-98.4 79.6,-98.4 90.38,-98.4"/>
<polygon fill="black" stroke="black" points="90.44,-101.9 100.44,-98.4 90.44,-94.9 90.44,-101.9"/>
</g>
<!-- assembly -->
<g id="node3" class="node">
<title>assembly</title>
<polygon fill="white" stroke="black" points="272.46,-67.7 204.26,-67.7 204.26,-43.1 272.46,-43.1 272.46,-67.7"/>
<text text-anchor="middle" x="238.36" y="-51.2" font-family="Times,serif" font-size="14.00">assembly</text>
</g>
<!-- compile&#45;&gt;assembly -->
<g id="edge2" class="edge">
<title>compile&#45;&gt;assembly</title>
<path fill="none" stroke="black" d="M161.73,-86.31C172.86,-81.76 185.69,-76.51 197.6,-71.65"/>
<polygon fill="black" stroke="black" points="198.96,-74.87 206.89,-67.85 196.31,-68.39 198.96,-74.87"/>
</g>
<!-- resources -->
<g id="node4" class="node">
<title>resources</title>
<polygon fill="white" stroke="black" points="165.5,-67.7 96.79,-67.7 96.79,-43.1 165.5,-43.1 165.5,-67.7"/>
<text text-anchor="middle" x="131.14" y="-51.2" font-family="Times,serif" font-size="14.00">resources</text>
</g>
<!-- resources&#45;&gt;assembly -->
<g id="edge3" class="edge">
<title>resources&#45;&gt;assembly</title>
<path fill="none" stroke="black" d="M165.72,-55.4C174.73,-55.4 184.6,-55.4 194.06,-55.4"/>
<polygon fill="black" stroke="black" points="194.09,-58.9 204.09,-55.4 194.09,-51.9 194.09,-58.9"/>
</g>
<!-- mainClass -->
<g id="node5" class="node">
<title>mainClass</title>
<polygon fill="white" stroke="black" points="168.47,-24.7 93.81,-24.7 93.81,-0.1 168.47,-0.1 168.47,-24.7"/>
<text text-anchor="middle" x="131.14" y="-8.2" font-family="Times,serif" font-size="14.00">mainClass</text>
</g>
<!-- mainClass&#45;&gt;assembly -->
<g id="edge4" class="edge">
<title>mainClass&#45;&gt;assembly</title>
<path fill="none" stroke="black" d="M162.29,-24.72C173.3,-29.22 185.92,-34.38 197.63,-39.17"/>
<polygon fill="black" stroke="black" points="196.62,-42.53 207.2,-43.08 199.27,-36.05 196.62,-42.53"/>
</g>
</g>
</svg>

</center>
</div>
<div class="paragraph">
<p>This example does not use any of Mill&#8217;s builtin support for building Java or
Scala projects, and instead builds a pipeline "from scratch" using Mill
tasks and <code>javac</code>/<code>jar</code> subprocesses. We define <code>Task.Source</code> folders and
plain <code>Task</code>s that depend on them, implementing entirely in our own code.</p>
</div>
<div class="paragraph">
<p>Two things are worth noting about this code:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It looks almost identical to the equivalent "naive" code you would write without using
a build tool! If you remove the <code>Task{&#8230;&#8203;}</code> wrappers, you could run the code and it would
behave as a naive script running top-to-bottom every time and generating your
<code>assembly.jar</code> from scratch. But Mill allows you to take such naive code and turn it
into a build pipeline with parallelism, caching, invalidation, and so on.</p>
</li>
<li>
<p>You do not see any logic at all related to parallelism, caching, invalidation in the code
at all! No <code>mtime</code> checks, no computing cache keys, no locks, no serializing and
de-serializing of data on disk. Mill handles all this for you automatically, so you just
need to write your "naive" code and Mill will provide all the "build tool stuff" for free.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This direct-style code has some surprising benefits: IDEs often not understand how registered
callbacks recursively trigger one another, but they <em>do</em> understand function calls, and so
they should be able to seamlessly navigate up and down your build graph just by following
those functions. Below, we can see IntelliJ resolve <code>compile</code> to the exact <code>def compile</code>
definition in <code>build.foo</code>, allowing us to jump to it if we want to see what it does:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../mill/_images/unique/IntellijDefinition.png" alt="IntellijDefinition"></span></p>
</div>
<div class="paragraph">
<p>In the <code>JavaModule</code> example earlier, IntelliJ is able to see the <code>def mvnDeps</code> configuration
override, and find the exact override definitions in the parent class hierarchy:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../mill/_images/unique/IntellijOverride.png" alt="IntellijOverride"></span></p>
</div>
<div class="paragraph">
<p>This "direct style" doesn&#8217;t just make navigating your build easy for IDEs: human programmers
are <em>also</em> used to navigating in and out of function calls, up and down class hierarchies,
and so on. Thus for a developer configuring or maintaining their build system, Mill&#8217;s direct
style means they easier time understanding what is going on, especially compared to the
classic "callbacks forests" you may have come to expect from build tools. However,
both of these benefits require that the IDE and the human understands the code in the
first place, which leads to the second major design decision:</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_a_single_general_purpose_language"><a class="anchor" href="#_using_a_single_general_purpose_language"></a>Using a Single General Purpose Language</h3>
<div class="paragraph">
<p>React.js makes users use Javascript to implement their HTML UIs. While a common approach
now in 2024, it is hard to overstate how controversial and unusual this design decision
was at the time.</p>
</div>
<div class="paragraph">
<p>In 2014, web UIs were implemented in some HTML <em>templating language</em> with separate CSS
source files, and "code behind" Javascript logic hooked in. This allowed separation of
concerns: a graphic designer could edit the HTML and CSS without needing to know
Javascript, and a programmer could edit the Javascript without needing to be an expert
in HTML/CSS. And so writing frontend code in three languages in three separate files
was the best practice, and so it was since the inception of the web two decades prior.</p>
</div>
<div class="paragraph">
<p>React.js flipped all that on its head: everything was Javascript! UI components were Javascript
objects first, containing Javascript functions that returned HTML snippets (which
were really <em>also</em> Javascript objects). CSS was often in-lined at the use site, perhaps
with constants fetched from a <a href="https://cssinjs.org/">CSS-in-JS</a> library. This was a total
departure from the previous two decades of web development best practices.</p>
</div>
<div class="paragraph">
<p>While controversial,
this approach had two huge advantages:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It broke the hard language barriers between HTML/CSS/JS, allowing more flexible
ways of organizing and grouping code in order to meet the
needs of the particular UI. While seemingly trivial, it makes a huge difference
to have one file in one language containing everything you need to know about a
UI component, rather than needing to tab between three files in three different languages.</p>
</li>
<li>
<p>It removed the separate second-class "templating language". While the "platonic ideal"
was people writing HTML/CSS/JS, the HTML often ended up being <a href="https://jinja.palletsprojects.com/">Jinja2</a>,
<a href="https://haml.info/">HAML</a>, or <a href="https://mustache.github.io/">Mustache</a> templates instead,
and the CSS usually ended up being replaced by <a href="https://sass-lang.com/">SASS</a> or
<a href="https://lesscss.org/">LESS</a>. While Javascript was by no means perfect, having
everything in a single "real" programming language was a breath of fresh air
over tabbing between three different languages each with their own half-baked version
of language features like if-else, loops, functions, etc.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The story for build tools is similar: the traditional wisdom has been
to implement your build logic in some limited "build language", in the past often
XML (e.g. for <a href="https://maven.apache.org/">Maven</a>, <a href="https://github.com/dotnet/msbuild">MSBuild</a>),
nowadays often JSON/TOML/YAML (e.g. <a href="https://github.com/rust-lang/cargo">Cargo</a>), with
logic split out into separate shell scripts or plugins. While this worked, it always
had issues:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Like web development, build tools <em>also</em> had the logic split between multiple
languages. Templated-Bash-in-Yaml is a common outcome, Bazel makes you write
<a href="https://bazel.build/reference/be/make-variables">make-interpolated Bash in pseudo-Python</a>,
Maven makes you choose between XML+Java to write plugins or
Bash-in-XML <a href="https://maven.apache.org/plugins/maven-antrun-plugin/">Ant scripts</a>.
Most build tools using "simple" config languages would inevitably find logic pushed
into shell scripts within the build, or the entire build tool itself wrapped in a shell
script to provide the flexibility a project needs</p>
</li>
<li>
<p>These "simple build languages" would always start off simple, but eventually grow
real programming language features: not just if-else, loops, functions, inheritance, but
also package managers, package repositories, profilers, debuggers, and
more. These were always ad-hoc, designed and implemented in their own weird and
idiosyncratic ways, and generally inferior to the same feature or tool provided by
a real programming language.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><em>"Config metadata turns into templating language turns into general-purpose language"</em>
is a tale as old as time. Whether it&#8217;s HTML templating using <a href="https://jinja.palletsprojects.com/en/stable/templates/">Jinja2</a>,
CI configuration using <a href="https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/evaluate-expressions-in-workflows-and-actions">Github Actions Config Expressions</a>,
or infrastructure-as-code systems like <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference.html">Cloudformation Functions</a>
or <a href="https://helm.sh/docs/chart_best_practices/templates/">Helm Charts</a>. While the allure
of using a "simple" config language is strong, many systems inevitably end up growing
so many programming-language features that you would have been better off using a
general-purpose language to start off with.</p>
</div>
<div class="paragraph">
<p>Mill follows React.js with its "One General-Purpose Language" approach:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Mill tasks are just method definitions</p>
</li>
<li>
<p>Mill task dependencies are just method calls</p>
</li>
<li>
<p>Mill modules are just objects</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>While this is not strictly true - Mill tasks and Mill modules have a small amount of extra
logic necessary to handling caching parallelization and other build tool necessities - it is
true enough that these details are often completely transparent to the user.</p>
</div>
<div class="paragraph">
<p>This has the same benefits that React.js had from using a general-purpose language throughout:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>You can directly write code to wire up and perform your build logic all in one language,
without the nested Bash-nested-in-Mustache-templates-nested-in-YAML monstrosities common when
insufficiently flexible config languages are chosen.</p>
</li>
<li>
<p>You <em>already know</em> how programming languages works: not just conditionals loops and functions,
but also classes, inheritance, overrides, typechecking, IDE navigation, package repositories
and library ecosystem (in Mill&#8217;s case, you can use everything on Java&#8217;s Maven Central repository).
Rather than dealing with half-baked versions of these features that specialized languages
inevitable grow, Mill lets you use the real thing right off the bat.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For example, in Mill you may not be familiar with the bundled libraries and APIs, but your
IDE can help you understand them:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../mill/_images/unique/IntellijDocs.png" alt="IntellijDocs"></span></p>
</div>
<div class="paragraph">
<p>And if you make an error, e.g. you typo-ed <code>resources</code> as <code>reources</code>, your IDE will
immediately flag it for you even before you run the build:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../mill/_images/unique/IntellijError.png" alt="IntellijError"></span></p>
</div>
<div class="paragraph">
<p>While all IDEs have good support for understanding JSON/TOML/YAML/XML, the support for
understanding <em>a particular tool&#8217;s dialect of templated-bash-in-yaml</em> is much more spotty.
Even IntelliJ, the gold standard, usually cannot provide more than basic assistance
editing templated-bash-in-yaml configs file. In contrast, IDE support
for a widely-used general purpose programming language is much more solid.</p>
</div>
<div class="paragraph">
<p>As another example, if you need a production-quality templating engine to use in your build
system, you have a buffet of options. The common Java
Thymeleaf templating engine is available with a single import, as is the popular Scalatags templating engine.
Rather than being limited to what the build tool has built-in or what third-party plugins
someone on the internet has published, you have at your fingertips any library in the huge JVM
ecosystem, and can use them in exactly the same way you would in any Java/Scala/Kotlin application.</p>
</div>
</div>
<div class="sect2">
<h3 id="_what_about_other_build_tools"><a class="anchor" href="#_what_about_other_build_tools"></a>What About Other Build Tools?</h3>
<div class="paragraph">
<p>There are existing build tools that use some of the ideas above, but perhaps none of them
have both, which is necessary to take full advantage:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Tools like <a href="https://gradle.org/">Gradle</a>, <a href="https://ruby.github.io/rake/">Rake</a>, or <a href="https://gulpjs.com/">Gulp</a> may be written
in a single language, but are not direct-style: they still rely on you registering a forest
of callbacks performing filesystem mutations, and manually ensuring that they are wired up to
converge to the state you want. This means that although that a human programmer or an IDE
like IntelliJ may be able to navigate around the Groovy/Kotlin/Ruby code used to configure the
build, both human and machine often have trouble tracing through the forest of mutating callbacks
to figure out what is actually happening</p>
</li>
<li>
<p>Tools like <a href="https://github.com/rust-lang/cargo">Cargo</a>, <a href="https://maven.apache.org/">Maven</a>, or <code>go build</code>
are very inflexible. This leads either to embedded shell scripts (or embedded-shell-scripts-as-XML
such as the <a href="https://maven.apache.org/plugins/maven-antrun-plugin/">Maven AntRun Plugin</a>!), or
having the build tool <code>mvn</code>/<code>cargo</code>/<code>go</code> being itself wrapped in shell scripts (or even another
build tool like Bazel!)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Mill&#8217;s direct style code and use of a general-purpose language makes it unique among
build tools, just like how React.js was unique among UI frameworks when it was first released
in 2014. With these two key design features, Mill makes understanding and maintaining your build
an order of magnitude easier than traditional tools, democratizing project builds so anyone
can contribute without needing to be experts.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_where_can_mill_go"><a class="anchor" href="#_where_can_mill_go"></a>Where can Mill Go?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Above, we discussed some of the unique design decisions of Mill, and the value they
provide to users. In this section we will discuss where Mill can fit into the larger
build-tool ecosystem.
I think Mill has legs to potentially grow 10x to 100x bigger than it is today. There are
three main areas where I think Mill can grow into:</p>
</div>
<div class="sect2">
<h3 id="_a_modern_javajvm_build_tool"><a class="anchor" href="#_a_modern_javajvm_build_tool"></a>A Modern Java/JVM Build Tool</h3>
<div class="paragraph">
<p>Mill is a JVM build tool, and the JVM platform hosts many rich communities and ecosystems:
the Java folks, offshoots like Android, other languages like Kotlin and Scala. All these
ecosystems rely on tools like Maven or Gradle to build their code, and I believe Mill
can provide a better alternative. Even today, there are already many advantages of
using Mill over the incumbent build tools:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Mill today runs the equivalent local workflows <a href="../mill/comparisons/maven.html" class="xref page">3-6x faster than Maven</a>
and <a href="../mill/comparisons/gradle.html" class="xref page">2-4x faster than Gradle</a>, with automatic parallelization and caching for
every part of your build</p>
</li>
<li>
<p>Mill today provides better ease of use than Maven or Gradle, with IDE support for
navigating your build graph and visualizing what your build is doing</p>
</li>
<li>
<p>Mill today makes extending your build 10x easier than Maven or Gradle, directly
using the same JVM libraries you already know without being beholden to third-party plugins</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The JVM is a flexible platform, and although Java/Kotlin/Scala/Android
are superficially different, underneath there is a ton of similarity. Concepts like
classfiles, jars, assemblies, classpaths, dependency management and publishing
artifacts, IDEs, debuggers, profilers, many third-party libraries, are all shared and identical
between the various JVM languages. Mill provides a first class Java and Scala experience,
with growing support for Kotlin and Android. Mill&#8217;s easy extensibility
means integrating new tools into Mill takes hours rather than days or weeks.</p>
</div>
<div class="paragraph">
<p>In the last 15-20 years, we have learned a lot about build tooling, and the field
has developed significantly:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://bazel.build/">Bazel</a>, <a href="https://buck.build/">Buck</a>, <a href="https://www.pantsbuild.org/">Pants</a>
have emerged to manage large codebases</p>
</li>
<li>
<p><a href="https://webpack.js.org/">Webpack</a>, <a href="https://www.snowpack.dev/">Snowpack</a>, <a href="https://esbuild.github.io/">ESBuild</a>,
<a href="https://nx.dev/">Nx</a>, <a href="https://turbo.build/">TurboRepo</a>, <a href="https://vite.dev/">Vite</a> have emerged for Javascript</p>
</li>
<li>
<p><a href="https://astral.sh/">Astral</a>, <a href="https://python-poetry.org/">Poetry</a>, and others have emerged for Python</p>
</li>
<li>
<p>We have seen papers published like <a href="https://www.microsoft.com/en-us/research/uploads/prod/2018/03/build-systems.pdf">Build Systems A La Carte</a>,
that thoroughly explore the design space for how a build tool might work.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>But there are no build tools in the Java/JVM ecosystem that really take advantage of these
newer designs and techniques: ideas like having a build graph, automatic caching, automatic
parallelization, side-effect-free build tasks, and so on. While Maven (from 2004) and Gradle
(2008) have been slowly trying to move in these directions, they are also constrained by
their two decades of legacy that limits how fast they can evolve.</p>
</div>
<div class="paragraph">
<p>Mill could be the modern Java/JVM build tool: providing 10x speedups over Maven or Gradle,
10x better ease of use, 10x better extensibility. Today Mill already provides a compelling
Java build experience. With some focused effort, I think Mill can be not just a <em>good</em>
option, but the <em>better</em> option for Java projects going forward!</p>
</div>
</div>
<div class="sect2">
<h3 id="_an_easier_monorepo_build_tool"><a class="anchor" href="#_an_easier_monorepo_build_tool"></a>An Easier Monorepo Build Tool</h3>
<div class="paragraph">
<p>Many companies are using Bazel today. Of the companies I interviewed from my Silicon Valley
network, 25 out of 30 are using or trying to use Bazel.
Bazel is an incredibly powerful tool: it provides <a href="https://bazel.build/docs/sandboxing">sandboxing</a>,
parallelization, <a href="https://bazel.build/remote/caching">remote caching</a>,
<a href="https://bazel.build/remote/rbe">remote execution</a>. These are all things that are
useful or even necessary as your organization and codebase grows. I even wrote about the
benefits on my company blog at the time:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.databricks.com/blog/2019/02/27/speedy-scala-builds-with-bazel-at-databricks.html">Speedy Scala Builds with Bazel at Databricks</a></p>
</li>
<li>
<p><a href="https://www.databricks.com/blog/2019/07/23/fast-parallel-testing-at-databricks-with-bazel.html">Fast Parallel Testing with Bazel at Databricks</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There is no doubt that if set up correctly, Bazel is a great experience that "just
works", and with a single command you can do anything that you could want to do in a codebase.</p>
</div>
<div class="paragraph">
<p>But of those 25 companies I interviewed, basically everyone was having a hard time adopting Bazel.
From my own experience, both of my prior employers (Dropbox and Databricks) both took
<code>O(1 person decade)</code> of work to adopt Bazel. I have met <em>multiple</em> Silicon Valley dev-tools teams that
spent months doing a Bazel proof-of-concept only to give up due to the difficulty. Bazel is
a ferociously complex tool, and although some of that complexity is inherent, much of it is
incidental, and some of it is to support projects at a scale beyond what most teams would encounter.</p>
</div>
<div class="paragraph">
<p>I think there is room for a lightweight monorepo build tool that provides maybe 50% of Bazel&#8217;s
functionality, but at 10% the complexity:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Most companies are not Google, don&#8217;t operate at Google-scale, do not have Google-level
problems, and may not need all the most advanced features that Bazel provides</p>
</li>
<li>
<p>Bazel itself is not getting any simpler over time - instead is getting more complex with
additional features and functionality, as tends to happen to projects over time</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Mill provides many of the same things Bazel does: automatic <a href="../mill/depth/execution-model.html" class="xref page">caching</a>,
parallelization, <a href="../mill/depth/sandboxing.html" class="xref page">sandboxing</a>,
extensibility. Mill
can already work with a wide variety of programming languages,
from JVM languages like <a href="../mill/javalib/intro.html" class="xref page">Java</a>/<a href="../mill/scalalib/intro.html" class="xref page">Scala</a>/<a href="../mill/kotlinlib/intro.html" class="xref page">Kotlin</a>
to <a href="../mill/extending/example-typescript-support.html" class="xref page">Typescript</a> and
<a href="../mill/extending/example-python-support.html" class="xref page">Python</a>. Mill&#8217;s features are not as
highly-scalable as their Bazel equivalents, but they are provided in a lighter-weight,
easier-to-use fashion suitable for organizations with less than 1,000 engineers
who cannot afford the <code>O(1 person decade)</code> it takes to adopt Bazel in their organization.</p>
</div>
<div class="paragraph">
<p>For most companies, their problems with Bazel aren&#8217;t its scalability or feature set,
but its complexity. While Mill can never compete with Bazel for the largest-scale deployments
by its most sophisticated users, the bulk of users operate at a somewhat smaller scale and
need something easier than Bazel. Mill could be that easy monorepo build tool for them to use.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_next_steps_for_mill_going_forward"><a class="anchor" href="#_next_steps_for_mill_going_forward"></a>Next Steps For Mill Going Forward</h2>
<div class="sectionbody">
<div class="paragraph">
<p>10 years ago React.js democratized front-end Web UIs: what previously took intricate
surgery to properly wire up event handlers and UI mutations in three separate languages
became a straightforward task of naively returning the UI you want to render. Previously
challenging tasks (e.g. "make a loading bar that is kept in sync with the text on screen as
a file is uploaded") became trivial, and now anyone can probably fumble through a basic
interactive website without getting lost in callback hell.</p>
</div>
<div class="paragraph">
<p>I think Mill has a chance to do the same thing for build systems. Like Web UIs 10 years ago,
configuring and maintaining a build-system often requires juggling multiple different
templating/config/scripting languages in an intricate dance of callbacks and filesystem
mutations. Like React.js, Mill collapses all this complexity, letting you write naive
"direct-style" code in a single language while getting all the benefits of caching and
parallelism, making previously challenging build pipelines implementations trivial.</p>
</div>
<div class="paragraph">
<p>Fundamentally, there are holes in the build-tool market that are not well served:
the Java folks deserve something more modern than Maven or Gradle, and the Monorepo folks need
something easier to use than Bazel. I think Mill has a decent shot at occupying each
of these two niches, and even if it is only able to succeed in one that would
still be significant.</p>
</div>
<div class="paragraph">
<p>Going forward, I expect to pursue both paths: Mill as a better Java build tool, Mill as
an easier Monorepo build tool, leveraging Mill&#8217;s unique direct style to make the build
tool experience easier. If anyone out there is interested in collaborating on improving
the build tool, <a href="https://github.com/com-lihaoyi/mill/discussions">reach out on Github</a> or Discord and let me know!!</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="index.html">The Mill Build Engineering Blog</a></span>
  <span class="next"><a href="11-jvm-test-parallelism.html">Strategies for Efficiently Parallelizing JVM Test Suites</a></span>
</nav>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../_/js/site.js" data-ui-root-path="../_"></script>
<script async src="../_/js/vendor/highlight.js"></script>
<script src="../_/js/vendor/lunr.js"></script>
<script src="../_/js/search-ui.js" id="search-ui-script" data-site-root-path=".." data-snippet-length="100" data-stylesheet="../_/css/search.css"></script>
<script async src="../search-index.js"></script>
  </body>
</html>
