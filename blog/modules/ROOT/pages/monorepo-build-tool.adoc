// tag::header[]

# What's Needed in a Monorepo Build Tool?


Software build tools mostly fall into two categories:

1. Single-language build tools targeting a single technology, e.g.
   Maven (Java), Poetry (Python), Npm (Javascript)

2. Monorepo build tools targeting large codebases, e.g. Bazel, Pants, Buck

There are some tools that blur the line (e.g. Gradle and Mill), but one question
that comes up constantly is why do people use Monorepo build tools at all? Tools
like Bazel are orders of magnitude more complicated and hard to use than tools
like Poetry or Npm, so why do people use Bazel at all?
https://knowyourmeme.com/memes/is-he-stupid-is-she-smart-are-they-stupid[Are they stupid?]

It turns out that Monorepo build tools like Bazel do a lot of non-obvious things that other
build tools don't, that become important in larger codebases (100-10,000 active developers).
These features are generally irrelevant for smaller projects, which explains why most people
do not miss them. But past a certain size of codebase and engineering organization these
features become crucial. We'll explore some of the core features of "Monorepo Build Tools"
below:

// end::header[]

## Automatic caching of everything.

In most build tools, caching is opt in, so the core build/compile steps usually end up getting
cached but everything else is not and ends up being wastefully recomputed all the time. In Bazel,
caching is the default so everything is cached. Even tests are cached so if you run a test twice on
the same code and inputs (transitively), the second time it is skipped

## Dependency based test selection

You can use bazel query to determine the possible targets and tests affected by a code change,
allowing you to trivially set up CI to only run tests downstream of a PR diff and skip unrelated
ones. Any large codebase that doesn't use Bazel ends up re-inventing this manually, e.g. consider
this code in apache/spark that re-implements this in a Python script that wraps `mvn` or `sbt`
(which are build tools that do not provide this functionality)
https://github.com/apache/spark/blob/290b4b31bae2e02b648d2c5ef61183f337b18f8f/dev/sparktestsupport/modules.py#L108-L126

## Automatic sandboxing of your build steps in CGroup/NS containers

This ensures your build steps do not make use of un-declared files. In most build tools, this
kind of mistake results in confusing nondeterministic parallelism and cache invalidation
problems down the road, where e.g. your build step may rely on a file on disk but not realize
it needs to re-compute when the file changes. In Bazel, these mis-configurations result in a
deterministic error up front

## Resource Sandboxing of build steps
Bazel has the ability to limit CPU/Memory usage as well, which eliminates the noisy neighbour
problem and ensures a build step or test gets the same compute footprint whether run alone
during development or 96x parallel on a CI worker (https://github.com/bazelbuild/bazel/pull/21322).
Otherwise it's common for tests to pass when run during manual development then timeout or OOM
when run in CI under resource pressure due to other tests hogging the CPU or RAM

## Built in support for seamless shared caches

For example, I can compile something on my laptop, you download it to your laptop for usage.
This also applies to tests: e.g. if TestFoo was run in CI on master, if i pull master and
run all tests without changing the Foo code, TestFoo is skipped and uses the CI result

## Built in support for shared compute clusters

This menas that I can run "compile" on my laptop and it automatically happens in the cloud
on 96 core machines, or I run a lot of tests (e.g. after a big refactor) on my laptop and it
automatically gets farmed out to run 1024x parallel on the cluster (which despite running faster
shouldn't cost any more than running 1x parallel, since it costs 1024x as much per-second but
should finish in 1024x fewer seconds!)

## Support for deep integration between multiple languages
For example, you may be building a Go binary and Rust library which are both used in a Python
executable, which is then tested using a Bash script and deployed as part of a Java backend
server. Most build tools support one language well and others not at all, Bazel supports them
all (not perfect but adequately)

## Who Needs Monorepo Build Tools?

If you never hit these needs, you don't need a Monorepo build tool like Bazel, and you
probably shouldn't use it because it is ferociously complicated. But if you do hit these
needs, most other build tools simply do not cut it at all.

https://mill-build.org[Mill] is a JVM build tool that is trying to support some of these
use cases and provide a simpler alternative in , but Bazel really is a high bar to reach
in terms of features that support large monorepos.


