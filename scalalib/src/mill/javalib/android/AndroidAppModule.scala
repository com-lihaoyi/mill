package mill.javalib.android

import mill._
import mill.api.PathRef
import mill.scalalib.JavaModule

/**
 * Trait for building Android applications using the Mill build tool.
 *
 * This trait defines all the necessary steps for building an Android app from Java sources,
 * integrating both Android-specific tasks and generic Java tasks by extending the
 * [[AndroidSdkModule]] (for Android SDK interactions) and [[JavaModule]] (for standard Java tasks).
 *
 * It provides a structured way to handle various steps in the Android app build process,
 * including compiling Java sources, creating DEX files, generating resources, packaging
 * APKs, optimizing, and signing APKs.
 *
 * The overall build process includes:
 *
 * 1. Compilation: Compiles the Java source code into `.class` files.
 *
 * 2. Packaging: Packages the compiled `.class` files into a JAR file.
 *
 * 3. Conversion to DEX: Converts the JAR file into DEX format (Android's runtime format).
 *
 * 4. APK Creation: Packages the DEX files and other resources into an APK.
 *
 * 5. Optimization: Optimizes the APK for better performance using zipalign.
 *
 * 6. Signing: Signs the APK with a digital signature for distribution.
 *
 * By following these steps, developers can automate their Android application build
 * workflow using Mill and the Android SDK.
 *
 * Resources for further reading:
 *
 * [[https://com-lihaoyi.github.io/mill Mill Documentation]]
 *
 * [[https://developer.android.com/studio Android Studio Documentation]]
 */
trait AndroidAppModule extends JavaModule {

  /**
   * Abstract method to provide access to the Android SDK configuration.
   *
   * The `AndroidSdkModule` provides access to important SDK tools such as `aapt` (for packaging resources),
   * `d8` (for compiling to DEX), `zipalign` (for APK optimization), and `apksigner` (for APK signing).
   *
   * This method must be implemented by the concrete class to specify the SDK paths.
   *
   * @return The Android SDK module that is used across the project.
   */
  def androidSdkModule: AndroidSdkModule

  /**
   * Defines the name of the Android application.
   *
   * The name is used as part of the APK file name (e.g., `HelloWorld.apk`), and also
   * helps distinguish different builds. It defaults to "HelloWorld", but can be
   * overridden for custom app names.
   *
   * @return The name of the Android application as a String.
   */
  def androidAppName: T[String] = Task { "HelloWorld" }

  /**
   * Generates the Android resources (such as layouts, strings, and other assets) needed for the application.
   *
   * This method uses the Android `aapt` tool to compile resources specified in the project's `AndroidManifest.xml`
   * and any additional resource directories. It creates the necessary R.java files and other compiled resources
   * for Android. These generated resources are crucial for the app to function correctly on Android devices.
   *
   * For more details on the aapt tool, refer to:
   * [[https://developer.android.com/tools/aapt2 aapt Documentation]]
   *
   * @return A `PathRef` pointing to the directory where the generated resources are stored.
   */
  def androidResources: T[PathRef] = Task {
    val genDir: os.Path = T.dest // Directory to store generated resources.

    os.call(Seq(
      androidSdkModule.aaptPath().path.toString, // Call aapt tool
      "package",
      "-f",
      "-m",
      "-J",
      genDir.toString, // Generate R.java files
      "-M",
      (millSourcePath / "src/main/AndroidManifest.xml").toString, // Use AndroidManifest.xml
      "-I",
      androidSdkModule.androidJarPath().path.toString // Include Android SDK JAR
    ))

    PathRef(genDir)
  }

  /**
   * Adds the Android SDK JAR file to the classpath during the compilation process.
   *
   * This method makes sure that the Android framework classes (like `android.view.View`)
   * are available when compiling the Java sources.
   *
   * For more Information please check: JavaModule [[unmanagedClasspath]]
   *
   * @return A collection of paths that make up the unmanaged classpath, which includes the Android JAR.
   */
  def unmanagedClasspath: T[Agg[PathRef]] = Task {
    Agg(androidSdkModule.androidJarPath())
  }

  /**
   * Combines standard Java source directories with additional sources generated by
   * the Android resource generation step.
   *
   * This method ensures that generated files like `R.java` (which contain references to resources)
   * are included in the source set and compiled correctly.
   *
   * For more Information please check: JavaModule [[generatedSources]]
   *
   * @return A sequence of source paths including both regular sources and generated ones.
   */
  def generatedSources: T[Seq[PathRef]] = Task {
    super.generatedSources() ++ Seq(androidResources())
  }

  /**
   * Packages the compiled Java `.class` files into a JAR file using the D8 tool.
   *
   * The D8 compiler is used here to package and optimize the Java bytecode into a format
   * suitable for Android (DEX). D8 converts the Java `.class` files into a jar file which is
   * suitable for DEX (Dalvik Executable) format and is required for Android runtime.
   *
   * Why use D8 instead of standard JAR packaging:
   *
   * D8 Compiler: Converts Java bytecode into jar(with DEX support) files, optimized for Android.
   *
   *   - Provides performance optimizations for Android devices, such as desugaring,
   *     which enables newer Java language features.
   *
   *   - Results in smaller APK sizes, leading to faster and more efficient apps.
   *
   * Standard JAR Command: Simply packages `.class` files without applying Android-specific
   * optimizations. It lacks the performance and size benefits provided by D8.
   *
   * Conclusion: Using D8 for creating JARs ensures smaller, faster applications optimized
   * for the Android ecosystem.
   *
   * For more details on the d8 tool, refer to:
   * [[https://developer.android.com/tools/d8 d8 Documentation]]
   *
   * @return A `PathRef` pointing to the generated JAR file.
   */
  def androidJar: T[PathRef] = Task {
    val jarFile: os.Path = T.dest / "my_classes.jar"

    os.call(
      Seq(
        androidSdkModule.d8Path().path.toString, // Call d8 tool
        "--output",
        jarFile.toString, // Output JAR file
        "--no-desugaring" // Disable desugaring
      ) ++ os.walk(compile().classes.path).filter(_.ext == "class").map(
        _.toString
      ) // Get class files
    )

    PathRef(jarFile)
  }

  /**
   * Converts the generated JAR file into a DEX file using the `d8` tool.
   *
   * DEX (Dalvik Executable) files are the binary format for Android applications. This method
   * takes the JAR file created in the previous step and converts it into one or more DEX files.
   *
   * This step is crucial because Android devices do not execute `.class` files directly;
   * they require the code to be in DEX format.
   *
   * @return A `PathRef` pointing to the folder containing the generated DEX files.
   */
  def androidDex: T[PathRef] = Task {
    val dexOutputDir: os.Path = T.dest

    os.call(
      Seq(androidSdkModule.d8Path().path.toString, "--output", dexOutputDir.toString) ++
        Seq(
          androidJar().path.toString, // Use the JAR file from the previous step
          androidSdkModule.androidJarPath().path.toString // Include Android framework classes
        )
    )

    PathRef(dexOutputDir)
  }

  /**
   * Packages the DEX files and Android resources into an unsigned APK using the `aapt` tool.
   *
   * The `aapt` tool takes the DEX files (compiled code) and resources (such as layouts and assets),
   * and packages them into an APK (Android Package) file. This APK file is unsigned and requires
   * further processing to be distributed.
   *
   * @return A `PathRef` pointing to the unsigned APK file.
   */
  def androidApk: T[PathRef] = Task {
    val unsignedApk: os.Path = T.dest / s"${androidAppName().toString}.unsigned.apk"

    os.call(
      Seq(
        androidSdkModule.aaptPath().path.toString,
        "package",
        "-f",
        "-M",
        (millSourcePath / "src/main/AndroidManifest.xml").toString, // Path to AndroidManifest.xml
        "-I",
        androidSdkModule.androidJarPath().path.toString, // Include Android JAR
        "-F",
        unsignedApk.toString // Output APK
      ) ++ Seq(androidDex().path.toString) // Include DEX files
    )

    PathRef(unsignedApk)
  }

  /**
   * Optimizes the APK using the `zipalign` tool for better performance.
   *
   * The `zipalign` tool ensures that all uncompressed data in the APK is aligned on a 4-byte boundary.
   * This is required for better performance on Android devices. This step is done after the APK
   * is created but before it is signed.
   *
   * For more details on the zipalign tool, refer to:
   * [[https://developer.android.com/tools/zipalign zipalign Documentation]]
   *
   * @return A `PathRef` pointing to the aligned APK file.
   */
  def androidAlignApk: T[PathRef] = Task {
    val alignedApk: os.Path = T.dest / s"${androidAppName().toString}.aligned.apk"

    os.call(
      Seq(
        androidSdkModule.zipalignPath().path.toString, // Call zipalign tool
        "-f",
        "-p",
        "4", // Force overwrite, align with 4-byte boundary
        androidApk().path.toString, // Use the unsigned APK
        alignedApk.toString // Output aligned APK
      )
    )

    PathRef(alignedApk)
  }

  /**
   * Signs the APK using a keystore to generate a final, distributable APK.
   *
   * The signing step is mandatory to distribute Android applications. It adds a cryptographic
   * signature to the APK, verifying its authenticity. This method uses the `apksigner` tool
   * along with a keystore file to sign the APK.
   *
   * If no keystore is available, a new one is generated using the `keytool` utility.
   *
   * For more details on the apksigner tool, refer to:
   * [[https://developer.android.com/tools/apksigner apksigner Documentation]]
   *
   * @return A `PathRef` pointing to the signed APK.
   */
  def androidApp: T[PathRef] = Task {
    val signedApk: os.Path = millSourcePath / s"${androidAppName().toString}.apk"

    os.call(
      Seq(
        androidSdkModule.apksignerPath().path.toString,
        "sign", // Call apksigner tool
        "--ks",
        androidKeystore().path.toString, // Path to keystore
        "--ks-key-alias",
        "androidkey", // Key alias
        "--ks-pass",
        "pass:android", // Keystore password
        "--key-pass",
        "pass:android", // Key password
        "--out",
        signedApk.toString, // Output signed APK
        androidAlignApk().path.toString // Use aligned APK
      )
    )

    PathRef(signedApk)
  }

  /**
   * Generates a new keystore file if it does not exist.
   *
   * A keystore is required to sign the APK for distribution. This method checks if a keystore
   * exists, and if not, generates a new one using the `keytool` utility. The keystore holds
   * the cryptographic keys used to sign the APK.
   *
   * For more details on the keytool utility, refer to:
   * [[https://docs.oracle.com/javase/8/docs/technotes/tools/windows/keytool.html keytool Documentation]]
   *
   * @return A `PathRef` pointing to the keystore file.
   */
  def androidKeystore: T[PathRef] = Task {
    val keystoreFile: os.Path = T.dest / "keystore.jks"

    if (!os.exists(keystoreFile)) {
      os.call(
        Seq(
          "keytool",
          "-genkeypair",
          "-keystore",
          keystoreFile.toString, // Generate keystore
          "-alias",
          "androidkey", // Alias for key in the keystore
          "-dname",
          "CN=MILL, OU=MILL, O=MILL, L=MILL, S=MILL, C=IN", // Key details
          "-validity",
          "10000", // Valid for 10,000 days
          "-keyalg",
          "RSA",
          "-keysize",
          "2048", // RSA encryption, 2048-bit key
          "-storepass",
          "android",
          "-keypass",
          "android" // Passwords
        )
      )
    }

    PathRef(keystoreFile)
  }
}
