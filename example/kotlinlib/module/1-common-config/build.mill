//// SNIPPET:BUILD
package build
import mill._, kotlinlib._

object `package` extends RootModule with KotlinModule {
  // You can have arbitrary numbers of third-party dependencies
  def ivyDeps = Agg(
    ivy"org.jetbrains.kotlinx:kotlinx-html-jvm:0.11.0"
  )

  def kotlinVersion = "1.9.24"

  // Choose a main class to use for `.run` if there are multiple present
  def mainClass = Some("foo.Foo2Kt")

  // Add (or replace) source folders for the module to use
  def sources = T.sources{
    super.sources() ++ Seq(PathRef(millSourcePath / "custom-src"))
  }

  // Add (or replace) resource folders for the module to use
  def resources = T.sources{
    super.resources() ++ Seq(PathRef(millSourcePath / "custom-resources"))
  }

  // Generate sources at build time
  def generatedSources: T[Seq[PathRef]] = Task {
    for(name <- Seq("A", "B", "C")) os.write(
      T.dest / s"Foo$name.kt",
      s"""
         |package foo
         |
         |object Foo$name {
         |  val VALUE: String = "hello $name"
         |}
      """.stripMargin
    )

    Seq(PathRef(T.dest))
  }

  // Pass additional JVM flags when `.run` is called or in the executable
  // generated by `.assembly`
  def forkArgs: T[Seq[String]] = Seq("-Dmy.custom.property=my-prop-value")

  // Pass additional environmental variables when `.run` is called. Note that
  // this does not apply to running externally via `.assembly
  def forkEnv: T[Map[String, String]] = Map("MY_CUSTOM_ENV" -> "my-env-value")
}
// If you want to better understand how the various upstream tasks feed into
// a task of interest, such as `run`, you can visualize their relationships via
/** Usage
> mill visualizePlan run
*/
//
// image::basic/VisualizePlanJava.svg[VisualizePlanJava.svg]
//
// (right-click open in new tab to see full sized)
//
//// SNIPPET:FATAL_WARNINGS
//
