// == Re-usable PythonModule
// This example illustrates the `PythonModule` trait for managing Python scripts within multiple Mill objects.

// ==== Using Same PythonModule for Multiple Objects

// `PythonModule` automates essential tasks in Python project management within Mill,
// such as setting up virtual environments, managing source files, performing type checks, and running scripts.

package build
import mill._

/** `PythonModule`: Trait for basic Python support in Mill */
trait PythonModule extends Module {

  def sources: T[PathRef] = Task.Source(millSourcePath / "src")
  def mainFileName: T[String] = Task { "main.py" }

  def setup: T[PathRef] = Task {
    val pythonVenv = Task.dest / "venv" / "bin" / "python3"

    os.call(("python3", "-m", "venv", Task.dest / "venv"))
    os.call((pythonVenv, "-m", "pip", "install", "mypy"))

    PathRef(pythonVenv)
  }

  def typeCheck: T[PathRef] = Task {
    val pythonVenv = setup().path

    os.call(
      (pythonVenv, "-m", "mypy", "--strict", sources().path / mainFileName()),
      stdout = os.Inherit
    )

    PathRef(pythonVenv)
  }

  def run(args: mill.define.Args) = Task.Command {
    val pythonVenv = typeCheck().path

    os.call(
      (pythonVenv, sources().path / mainFileName(), args.value),
      stdout = os.Inherit
    )
  }

}

// ==== Example

// Below are three objects extending `PythonModule`, each representing a unique configuration.

object foo extends PythonModule {
  override def mainFileName: T[String] = Task { "foo.py" }
  object bar extends PythonModule {
    override def mainFileName: T[String] = Task { "bar.py" }
    // Inherits PythonModule features
  }
}

object qux extends PythonModule {
  override def mainFileName: T[String] = Task { "qux.py" }
  // Independent, but uses PythonModule methods
}

// We have used three different Python Scripts `foo/src/foo.py`, `foo/bar/src/bar.py`, `qux/src/qux.py`

/** See Also: foo/src/foo.py */
/** See Also: foo/bar/src/bar.py */
/** See Also: qux/src/qux.py */

// Use the following commands to run each module, displaying unique outputs per configuration:

/** Usage

> ./mill foo.run Mill 
Hello, Mill Foo!

> ./mill foo.bar.run Mill 
Hello, Mill Foo Bar!

> ./mill qux.run Mill
Hello, Mill Qux!

*/

// The Final working build, with a build graph that looks like this:

// ```graphviz
// digraph G {
//   rankdir=LR
//   node [shape=box width=0 height=0 style=filled fillcolor=white]
//   subgraph cluster_3 {
//     style=dashed
//     label=qux
//     "qux.setup" -> "qux.typeCheck" -> "qux.run"
//     "qux.sources" -> "qux.typeCheck"
//     "qux.mainFileName" -> "qux.typeCheck"
//     "qux.sources" -> "qux.run"
//     "qux.mainFileName" -> "qux.run"
//   }
//   subgraph cluster_1 {
//     subgraph cluster_2 {
//       style=dashed
//       label=bar
//       "bar.setup" -> "bar.typeCheck" -> "bar.run"
//       "bar.sources" -> "bar.typeCheck"
//       "bar.mainFileName" -> "bar.typeCheck"
//       "bar.sources" -> "bar.run"
//       "bar.mainFileName" -> "bar.run"
//     }
//     style=dashed
//     label=foo
//     "foo.setup" -> "foo.typeCheck" -> "foo.run"
//     "foo.sources" -> "foo.typeCheck"
//     "foo.mainFileName" -> "foo.typeCheck"
//     "foo.sources" -> "foo.run"
//     "foo.mainFileName" -> "foo.run"
//   }
// }
// ```

// Next, we will look at how to Manage `Module Dependencies` for `Python` in `Mill`.
