// == Re-usable PythonModule
// This Example demonstrates the use of a `PythonModule` trait to manage Python Scripts within
// different objects in a Mill build.

// ==== Using Same PythonModule for Mutiple Objects

// The PythonModule trait simplifies Python project management within the Mill build tool by providing essential
// functionalities such as installing pip, managing source files, compiling code, and executing Python scripts.
// It ensures that users have a streamlined workflow by automating the setup of necessary tools 
// and organizing project files effectively. 

package build
import mill._

trait PythonModule extends Module {

  /** Installs pip if it's not already installed. */
  def installPip: T[PathRef] = Task {
    val pipFile = Task.dest / "get-pip.py"
    val pipPath = os.home / ".local" / "bin" / "pip3"

    if (!os.exists(pipPath)) {
      os.call(Seq("wget", "-q", "https://bootstrap.pypa.io/get-pip.py", "-O", s"$pipFile"))
      os.call(Seq(
        "python3",
        s"$pipFile",
        "--user",
        "--break-system-packages",
        "--no-warn-script-location"
      ))

      os.call(Seq(
        pipPath.toString,
        "install",
        "pip",
        "--break-system-packages",
        "--no-warn-script-location"
      ))
    } else {
      println("pip is already installed, skipping installation.")
    }
    PathRef(Task.dest)
  }

  /** Returns the path to the source directory containing Python files. */
  def sources: T[PathRef] = Task.Source(millSourcePath / "src")

  /** Collects and returns all Python source files as PathRefs. */
  def allSources: T[Seq[PathRef]] = Task {
    os.walk(sources().path).filter(_.ext == "py").map(PathRef(_))
  }

  /** Compiles the project by installing pip and returning the main file Directory. */
  def compile: T[PathRef] = Task {
    installPip()
    val mainFileDir = sources().path
    
    PathRef(mainFileDir)
  }
  
  /** Returns the name of the main Python file. */
  def mainFileName: T[String] = Task { "main.py" }
  
  /** Runs the compiled main Python file with optional command-line arguments. */
  def run(args: mill.define.Args) = Task.Command {
    os.call(
      Seq(
        "python3",
        s"${compile().path / mainFileName()}"
      ) ++ args.value,
      stdout = os.Inherit
    )
  }
}

// ==== Example

// The script defines three key objects that extend the `PythonModule` trait, each object encapsulating a distinct runtime configuration.
// By allowing objects like foo, bar, and qux to extend the PythonModule, it promotes code reuse and modular design, 
// enabling easy access to common functionalities while facilitating customization for specific needs.

object foo extends PythonModule{
  override def mainFileName: T[String] = Task { "foo.py" }
  object bar extends PythonModule{
    override def mainFileName: T[String] = Task { "bar.py" }
    // Inherits all functionalities of PythonModule
  }
}

object qux extends PythonModule{
  override def mainFileName: T[String] = Task { "qux.py" }
  // Functions independently but has access to PythonModule methods
}

// We have used three different Python Scripts `foo/src/foo.py`, `foo/bar/src/bar.py`, `qux/src/qux.py` 

/** See Also: foo/src/foo.py */
/** See Also: foo/bar/src/bar.py */
/** See Also: qux/src/qux.py */


// Run the following commands to run each module, displaying unique outputs based on the configuration of each object:

/** Usage

> ./mill foo.run Mill 
Hello, Mill Foo!

> ./mill foo.bar.run Mill 
Hello, Mill Foo Bar!

> ./mill qux.run Mill
Hello, Mill Qux!

*/

// The Final minimal working build, with a build graph that looks like this:

// ```graphviz
// digraph G {
//   rankdir=LR
//   node [shape=box width=0 height=0 style=filled fillcolor=white]
//   subgraph cluster_3 {
//     style=dashed
//     label=qux
//     "qux.installPip" -> "qux.compile"
//     "qux.sources" -> "qux.compile" -> "qux.run"
//     "qux.mainFileName" -> "qux.run"
//   }
//   subgraph cluster_1 {
//     subgraph cluster_2 {
//       style=dashed
//       label=bar
//       "bar.installPip" -> "bar.compile"
//       "bar.sources" -> "bar.compile" -> "bar.run"
//       "bar.mainFileName" ->  "bar.run"
//     }
//     style=dashed
//     label=foo
//     "foo.installPip" -> "foo.compile"
//     "foo.sources" -> "foo.compile" -> "foo.run"
//     "foo.mainFileName" -> "foo.run"
//   }
// }
// ```

// Next, we will look at how to Create Virtual Environment and Install Module Dependencies.