// == Re-usable PythonModule
// This Example demonstrates the use of a `PythonModule` trait to manage Python environments and dependencies within different objects in a Mill build. 
// This approach enables flexible, modular management of Python scripts and virtual environments across multiple objects, providing each with its own configuration and runtime settings.

// === Using Same PythonModule for Mutiple Objects

// This build script provides a reusable `PythonModule` trait designed to manage Python environments and dependencies in a Mill build.
// This trait can be extended by different objects to create specific configurations and tasks, allowing you to customize the execution context for each Python module in a Mill project.

package build
import mill._

/**
 * A trait for managing Python environments and dependencies in a Mill build.
 */
trait PythonModule extends Module {

  /** Specifies dependencies to install in the virtual environment. */
  def dependencies: T[Seq[String]] = Task { Seq.empty[String] }

  /** Specifies command-line options to pass to the main Python file. */
  def options: T[Seq[String]] = Task { Seq.empty[String] }

  /** Specifies the name of the virtual environment directory. */
  def venvName: T[String] = Task { "venv" }

  /** Specifies the name of the main Python file. */
  def mainFileName: T[String] = Task { "main.py" }

  /** Defines the path to the sources directory. */
  def sources: T[PathRef] = Task.Source(millSourcePath / "src")

  /** Collects all Python source files from the sources directory. */
  def allSources: T[Seq[PathRef]] = Task {
    os.walk(sources().path).filter(_.ext == "py").map(PathRef(_))
  }

  /** Path to the requirements file, configurable by the user. */
  def requirementsPath: T[PathRef] = Task {
    PathRef(millSourcePath / "src" / "requirements.txt")
  }

  /** Reads dependencies from the specified requirements file. */
  def requirementsDependencies: T[Seq[String]] = Task {
    val reqFile = requirementsPath().path
    if (os.exists(reqFile)) {
      os.read.lines(reqFile).map(_.trim).filter(_.nonEmpty)
    } else {
      Seq.empty[String]
    }
  }

  /** Installs pip using a downloaded script. */
  def installPip: T[Unit] = Task {
    val pipFile = T.dest / "get-pip.py"
    val pipPath = os.home / ".local" / "bin" / "pip3"

    if (!os.exists(pipPath)) {
      os.call(Seq("wget", "-q", "https://bootstrap.pypa.io/get-pip.py", "-O", s"$pipFile"))
      os.call(Seq(
        "python3",
        s"$pipFile",
        "--user",
        "--break-system-packages",
        "--no-warn-script-location"
      ))

      os.call(Seq(
        pipPath.toString,
        "install",
        "pip",
        "--break-system-packages",
        "--no-warn-script-location"
      ))
    } else {
      println("pip is already installed, skipping installation.")
    }
  }

  /** Creates a virtual environment using the installed Python version. */
  def createVenv: T[PathRef] = Task {
    installPip()
    val venvDir = T.dest / venvName()

    os.call(Seq(
      "python3",
      "-m",
      "pip",
      "install",
      "virtualenv",
      "--break-system-packages",
      "--no-warn-script-location"
    ))
    os.call(Seq("python3", "-m", "virtualenv", venvDir.toString))

    PathRef(venvDir)
  }

  /** Activates the created virtual environment. */
  def activateVenv: T[PathRef] = Task {
    val venvBin = createVenv().path / "bin"
    os.call(Seq("bash", "-c", s"source ${venvBin / "activate"}"))
    PathRef(venvBin)
  }

  /** Installs specified dependencies in the virtual environment. */
  def installDependencies: T[PathRef] = Task {
    val pythonVenv = activateVenv().path / "python3"

    val pythonDependencies: Seq[String] = dependencies() ++ requirementsDependencies()

    if (pythonDependencies.nonEmpty) {
      os.call(Seq(
        pythonVenv.toString,
        "-m",
        "pip",
        "install"
      ) ++ pythonDependencies ++ Seq(
        "--break-system-packages",
        "--no-warn-script-location"
      ))
    }

    PathRef(pythonVenv)
  }

  /** Retrieves the path to the main Python file, ensuring it exists. */
  def mainFile: T[PathRef] = Task {

    val mainFilePath = allSources().find(_.path.last == mainFileName()) match {
      case Some(mainFile) => mainFile.path
      case None =>
        throw new java.io.FileNotFoundException(
          s"Main file '${mainFileName()}' not found in sources."
        )
    }
    PathRef(mainFilePath)
  }

  /** Executes the main Python file using the virtual environment. */
  def compile: T[Unit] = Task {
    val pythonVenv = installDependencies().path
    val mainFilePath = mainFile().path
    val args = options()

    val result = os.call(Seq(pythonVenv.toString, mainFilePath.toString) ++ args)

    T.log.info(result.out.text())
    if (result.exitCode != 0) {
      T.log.error(s"Error: ${result.err.text()}")
    }
  }

}

// === Example

// The script defines three key objects that extend the `PythonModule` trait, each object encapsulating a distinct runtime configuration.

// The `foo` object extends `PythonModule` and provides basic Python environment and script execution capabilities.
// The `options` method in `foo` has been overridden to pass custom command-line arguments to the main Python script.
// Inside `foo`, a nested object `bar` further extends `PythonModule`. It overrides `options` to add additional arguments,
// illustrating how nested configurations can be achieved by extending the trait within different contexts.

object foo extends PythonModule{
  override def options: T[Seq[String]] = Task { Seq[String]("Mill", "Foo") }
    
  object bar extends PythonModule{
    override def options: T[Seq[String]] = Task { Seq[String]("Mill", "Foo", "Bar") }
  }
}

// The `qux` object is another standalone object extending `PythonModule` and provides its own set of options,
// allowing for a separate execution path and configuration from `foo` and `foo.bar`.

object qux extends PythonModule{
  override def options: T[Seq[String]] = Task { Seq[String]("Mill", "Qux") }
}

// Run the following commands to compile and execute each module, displaying unique outputs based on the configuration of each object:

/** Usage

> ./mill foo.compile
Hello, Mill Foo!

> ./mill foo.bar.compile
Hello, Mill Foo Bar!

> ./mill qux.compile
Hello, Mill Qux!

*/

// All python Scripts are same as below:

/** See Also: foo/src/main.py */
