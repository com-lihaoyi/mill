// == Python Pex Support

// This script introduces support for `Pex` packaging in the `PythonModule` trait.
// Pex (Python EXecutable) enables bundling Python applications into single-file executables,
// allowing easy distribution and execution without additional dependencies. In this setup,
// the `PythonModule` trait includes a `compilePex` task, which leverages the Pex library to create a `.pex` file,
// incorporating all specified dependencies and the main Python file.

// === Using PythonModule For Pex Support 

// The `PythonModule` trait with Pex support includes:

// - `dependencies`: Lists core dependencies, including Pex, which are installed in the virtual environment.
// - `options`: Optional command-line arguments for the Python script.
// - `requirementsPath`: Path to `requirements.txt`, allowing flexible addition of dependencies.
// - `compilePex`: This new task creates a `.pex` file, combining all dependencies and the specified main Python file into a standalone, executable format.

package build
import mill._

/**
 * A trait for managing Python environments and dependencies in a Mill build.
 */
trait PythonModule extends Module {

  def moduleDeps: Seq[PythonModule] = Nil

  /** Specifies dependencies to install in the virtual environment. */
  def dependencies: T[Seq[String]] = Task { Seq.empty[String] }

  /** Specifies the name of the virtual environment directory. */
  def venvName: T[String] = Task { "venv" }

  /** Specifies the name of the main Python file. */
  def mainFileName: T[String] = Task { "main.py" }

  /** Defines the path to the sources directory. */
  def sources: T[PathRef] = Task.Source(millSourcePath / "src")

  /** Collects all Python source files from the sources directory. */
  def allSources: T[Seq[PathRef]] = Task {
    os.walk(sources().path).filter(_.ext == "py").map(PathRef(_))
  }

  /** Path to the requirements file, configurable by the user. */
  def requirementsPath: T[PathRef] = Task {
    PathRef(millSourcePath / "src" / "requirements.txt")
  }

  /** Reads dependencies from the specified requirements file. */
  def requirementsDependencies: T[Seq[String]] = Task {
    val reqFile = requirementsPath().path
    if (os.exists(reqFile)) {
      os.read.lines(reqFile).map(_.trim).filter(_.nonEmpty)
    } else {
      Seq.empty[String]
    }
  }

  /** Installs pip using a downloaded script. */
  def installPip: T[Unit] = Task {
    val pipFile = T.dest / "get-pip.py"
    val pipPath = os.home / ".local" / "bin" / "pip3"

    if (!os.exists(pipPath)) {
      os.call(Seq("wget", "-q", "https://bootstrap.pypa.io/get-pip.py", "-O", s"$pipFile"))
      os.call(Seq(
        "python3",
        s"$pipFile",
        "--user",
        "--break-system-packages",
        "--no-warn-script-location"
      ))

      os.call(Seq(
        pipPath.toString,
        "install",
        "pip",
        "--break-system-packages",
        "--no-warn-script-location"
      ))
    } else {
      println("pip is already installed, skipping installation.")
    }
  }

  /** Creates a virtual environment using the installed Python version. */
  def createVenv: T[PathRef] = Task {
    installPip()
    val venvDir = T.dest / venvName()

    os.call(Seq(
      "python3",
      "-m",
      "pip",
      "install",
      "virtualenv",
      "--break-system-packages",
      "--no-warn-script-location"
    ))
    os.call(Seq("python3", "-m", "virtualenv", venvDir.toString))

    PathRef(venvDir)
  }

  /** Activates the created virtual environment. */
  def activateVenv: T[PathRef] = Task {
    val venvBin = createVenv().path / "bin"
    os.call(Seq("bash", "-c", s"source ${venvBin / "activate"}"))
    PathRef(venvBin)
  }
  
  def finalDependencies: T[Seq[String]] = Task {
    val upstreamDependencies = Task.traverse(moduleDeps)(_.finalDependencies)()
    (dependencies().map(_.toString) ++ requirementsDependencies().map(_.toString) ++ upstreamDependencies.flatten.map(_.toString)).distinct
  }

  /** Installs specified dependencies in the virtual environment. */
  def installDependencies: T[PathRef] = Task {
    val pythonVenv = activateVenv().path / "python3"

    if (finalDependencies().nonEmpty) {
      os.call(Seq(
        pythonVenv.toString,
        "-m",
        "pip",
        "install"
      ) ++ finalDependencies() ++ Seq(
        "--break-system-packages",
        "--no-warn-script-location"
      ))
    }

    PathRef(pythonVenv)
  }

  /** Executes the main Python file using the virtual environment. */
  def compile: T[(PathRef, PathRef)] = Task {
    val pythonVenv = installDependencies().path
    val mainFileDir = sources().path
    
    (PathRef(pythonVenv), PathRef(mainFileDir))
  }
  
  def run(args: mill.define.Args) = Task.Command {
    
    val pexFile = T.dest / "result.pex"

    val upstream = Task.traverse(moduleDeps)(_.compile)().zip(moduleDeps)
    for(((_, mainFileDir), mod) <- upstream) {
      val destinationPath = Task.dest / mod.millSourcePath.subRelativeTo(build.millSourcePath)
      os.copy.over(mainFileDir.path / os.up, destinationPath)
    }

    os.call(
      Seq(
        compile()._1.path.toString,
        "-m",
        "pex",
      ) ++ finalDependencies() ++ Seq(
        "-c",
        s"${compile()._2.path / mainFileName()}",
        "-o",
        pexFile.toString
      ) ++ args.value,
      env = Map("PYTHONPATH" -> Task.dest.toString)
    )
  }

  // /** Executes the main Python file with pex Library using the virtual environment. */
  // def compilePex: T[PathRef] = Task {
  //   val pythonVenv = installDependencies().path
  //   val mainFilePath = mainFile().path
  //   val args = options()
  //   val pexFile = T.dest / "result.pex"

  //   val result = os.call(
  //     Seq(
  //       pythonVenv.toString,
  //       "-m",
  //       "pex",
  //       "-r",
  //       requirementsPath().path.toString,
  //       "-c",
  //       mainFilePath.toString,
  //       "-o",
  //       pexFile.toString
  //     ) ++ args
  //   )

  //   println(result)
  //   T.log.info(result.out.text())
  //   if (result.exitCode != 0) {
  //     T.log.error(s"Error: ${result.err.text()}")
  //   }

  //   PathRef(pexFile)
  // }

}

// == Example
// The object `pex` inherits from `PythonModule` and defines its dependencies:

// - `pex`: An object demonstrating Pex usage by defining project dependencies within `requirements.txt`. Running `pex.compilePex` creates a `.pex` file, suitable for easy distribution.


object pex extends PythonModule{

  override def dependencies: T[Seq[String]] = Task{ Seq("pex") }

  // Project Dependencies are present in the requirements.txt file.
  // These dependencies are used in the main.py file.
  // After compilation this will create .pex file.
}


// To compile the project and create a `.pex` executable, use the following command:

/** Usage

> ./mill show pex.run
".../out/pex/compilePex.dest/result.pex"

*/

// This generates the `result.pex` file, which packages all dependencies and can be executed as a standalone application.

// To Run the result.pex file, First Provide the executable permission(+x) to result.pex and then run using `./result.pex` command.

// Source Files For this Example: 
/** See Also: pex/src/main.py */
/** See Also: pex/src/requirements.txt */
// User can Customize these Scripts According to their Need.