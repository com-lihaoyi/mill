// This example expands `TypeScriptModule` to include support for custom
// NPM module dependencies. Previously, `def npmInstall` was hardcoded to
// install `typescript` and `@types/node`, because that was what was needed
// to compile Typescript against the builtin Node.js APIs. In this example,
// we add a `def npmDeps` task, that is aggregated using `Task.traverse` into
// `def transitiveNpmDeps`, that are then included in the body of `def npmInstall`.
// The `npmInstall` destination folder in then used both in `def compile` to
// provide the `tsc` compiler and supporting installed type definitions, as well
// as in `def run` in order to provide the necessary files to the `node` runtime.

package build
import mill._

trait TypeScriptModule extends Module{
  def moduleDeps: Seq[TypeScriptModule] = Nil

  def npmDeps: T[Seq[String]] = Task{ Seq.empty[String] }

  def transitiveNpmDeps: T[Seq[String]] = Task{
    Task.traverse(moduleDeps)(_.npmDeps)().flatten ++ npmDeps()
  }

  def npmInstall = Task{
    os.call((
      "npm", "install", "--save-dev",
      "typescript@5.6.3", "@types/node@22.7.8", transitiveNpmDeps()
    ))
    PathRef(Task.dest)
  }

  def sources = Task.Source(millSourcePath / "src")
  def allSources = Task{ os.walk(sources().path).filter(_.ext == "ts").map(PathRef(_)) }

  def compile: T[(PathRef, PathRef)] = Task{
    val nodeTypes = npmInstall().path / "node_modules/@types"
    val javascriptOut = Task.dest / "javascript"
    val declarationsOut = Task.dest / "declarations"

    val upstreamPaths =
      for(((jsDir, dTsDir), mod) <- Task.traverse(moduleDeps)(_.compile)().zip(moduleDeps))
        yield (mod.millSourcePath.subRelativeTo(build.millSourcePath) + "/*", dTsDir.path)

    val allPaths = upstreamPaths ++ Seq("*" -> sources().path, "*" -> npmInstall().path)

    os.write(
      Task.dest / "tsconfig.json",
      ujson.Obj(
        "compilerOptions" -> ujson.Obj(
          "outDir" -> javascriptOut.toString,
          "declaration" -> true,
          "declarationDir" -> declarationsOut.toString,
          "typeRoots" -> ujson.Arr(nodeTypes.toString),
          "paths"  -> ujson.Obj.from(allPaths.map{case (k, v) => (k, ujson.Arr(s"$v/*"))})
        ),
        "files" -> allSources().map(_.path.toString),
      )
    )

    os.call((npmInstall().path / "node_modules/typescript/bin/tsc"))

    (PathRef(javascriptOut), PathRef(declarationsOut))
  }

  def mainFileName = Task{ s"${millSourcePath.last}.js" }

  def run(args: mill.define.Args) = Task.Command{
    val upstream = Task.traverse(moduleDeps)(_.compile)().zip(moduleDeps)
    for(((jsDir, tTsDir), mod) <- upstream) {
      os.copy(jsDir.path, Task.dest / mod.millSourcePath.subRelativeTo(build.millSourcePath))
    }
    val mainFile = compile()._1.path / mainFileName()
    os.call(
      ("node", mainFile, args.value),
      stdout = os.Inherit,
      env = Map("NODE_PATH" -> Seq(".", compile()._1.path, npmInstall().path).mkString(":"))
    )
  }
}

// With these changes to `TypeScriptModule`, we can then override `def npmDeps`
// in the `foo.bar` module, and it will automatically get used both for the
// `compile` task of `foo.bar` as well as the `run` task of `qux`.

object foo extends TypeScriptModule{
  object bar extends TypeScriptModule{
    def npmDeps = Seq("immutable@4.3.7")
  }
}
object qux extends TypeScriptModule{
  def moduleDeps = Seq(foo, foo.bar)
}

/** See Also: foo/src/foo.ts */
/** See Also: foo/bar/src/bar.ts */
/** See Also: qux/src/qux.ts */

// We can then invoke the `qux.run` method on each module from the command line:

/** Usage

> mill qux.run James Bond prof
Hello James Bond Professor

*/
