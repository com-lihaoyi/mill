// == Basic Python Pipeline 

// This Example demonstrates integration of https://www.python.org[Python]
// compilation into a Mill build to compile https://www.python.org[Python] Scripts. Mill
// does not come bundled with https://www.python.org[Python] integration, so here we begin setting
// one up from first principles using the Basic `Python3`(Already Present in OS) command Line.

// === Python Setup
//
// First, we need to use the `Python3` CLI tool to create virtual environment and
// install `mypy` for Type Checking using the official Python Virtual Environment
// https://packaging.python.org/en/latest/guides/installing-using-pip-and-virtual-environments[Documentation].

// `MyPy` is a static type checker that uses Python `type hints` to enforce `type correctness` and `catch errors` during development.

package build
import mill._

def createVenv: T[PathRef] = Task {
  val venvDir = T.dest / "venv"

  os.call(
    Seq(
      "python3",
      "-m",
      "venv",
      venvDir.toString
    )
  )

  PathRef(venvDir)
}

def setup: T[PathRef] = Task {
  // creating virtual environment
  val pythonVenv = createVenv().path / "bin" / "python3"
  
  // installing mypy for Type Checking
  os.call(
    Seq(
      pythonVenv.toString,
      "-m",
      "pip",
      "install",
      "mypy"
    )
  )
  PathRef(pythonVenv)
}

// The `createVenv` task ensures the Python virtual environment creation process using the official documentaion.
// After this, we need to install python `mypy` library for Type Checking and Error Checking before actual run of the code, 
// using the offical https://mypy.readthedocs.io/en/stable[Documentation] for `mypy` 

// === Defining our Sources

// Next, We define the `sources` task to help gather source files for processing. 
// `sources` sets a base directory for Python source files and enable easy access to Python files in a project,
// making it straightforward to retrieve all relevant code files for tasks like building, testing, or analysis.

def sources: T[PathRef] = Task.Source(millSourcePath / "src")

// === Type Checking

// The `mainFileName` Task provides the name for the main python script file for running and 
// The `typeCheck` Task  ensures that the python setup is set and Checks the main file for error free code.
// This task is considered as a part of code which is responsible for Error Checking of the Main Script 
// and setting up setup for python script runable environment.

def mainFileName: T[String] = Task { "main.py" }
def typeCheck: T[PathRef] = Task {
  val pythonVenv = setup().path

  os.call(
    Seq(
      pythonVenv.toString,
      "-m",
      "mypy",
      "--strict",
      s"${sources().path / mainFileName()}"
    ),
    stdout = os.Inherit
  )

  PathRef(pythonVenv)
}

// At this point, we have a minimal working build, with a build graph that looks like this:
//
// ```graphviz
// digraph G {
//   rankdir=LR
//   node [shape=box width=0 height=0 style=filled fillcolor=white]
//   createVenv -> setup -> typeCheck
//   sources -> typeCheck
//   mainFileName -> typeCheck
// }
// ```

// When `typeCheck` task sets up the Setup for Virtual Environment and checks the main file for error free code 
// then we have `main.py` and running this file will result in either a generic greeting 
// or a personalized one based on the command-line arguments passed, allowing for flexible interaction with the user.

/** See Also: src/main.py */


// === Running

// The `run` function executes the main Python file (`main.py`) and accepts command-line arguments from the user. 
// It uses `os.call` to run the Python interpreter(from Virtual Environment) with the main file's path 
// and any additional arguments. The output is shown in the console, allowing for real-time interaction.
  
def run(args: mill.define.Args) = Task.Command {
  val pythonVenv = typeCheck().path
  
  os.call(
    Seq(
      pythonVenv.toString,
      s"${sources().path / mainFileName()}"
    ) ++ args.value,
    stdout = os.Inherit
  )
}

// Note that we use `stdout = os.Inherit` since we want to display any output to the user,
// rather than capturing it for use in our command.

// ```graphviz
// digraph G {
//   rankdir=LR
//   node [shape=box width=0 height=0 style=filled fillcolor=white]
//   createVenv -> setup -> typeCheck -> run
//   sources -> typeCheck
//   mainFileName -> typeCheck
//   sources -> run
//   mainFileName -> run
//   mainFileName [color=green, penwidth=3]
//   run [color=green, penwidth=3]
// }
// ```

// Running run command will return the result to the console.

/** Usage

> ./mill typeCheck
Success: no issues found in 1 source file

> ./mill run Mill Python
Hello, Mill Python!

*/

// Uncomment the Result variable line(Line Number:13) in the `src/main.py` code to see `typeCheck` error

// So that's a minimal example of implementing a `Basic Python
// pipeline` locally. Next, we will look at turning it into a `PythonModule` that
// can be re-used
