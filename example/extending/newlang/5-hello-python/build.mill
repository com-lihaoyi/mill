// == Basic Python Pipeline 

// This Example demonstrates integration of https://www.python.org[Python]
// compilation into a Mill build to compile https://www.python.org[Python] Scripts. Mill
// does not come bundled with https://www.python.org[Python] integration, so here we begin setting
// one up from first principles using the Basic `Python3`(Already Present in OS) command Line


// === Installing Python Pip
//
// First, we need to use the `Python3` CLI tool to install `Pip` 
// using the official https://bootstrap.pypa.io/get-pip.py[get-pip.py] Code:

package build
import mill._

def installPip: T[PathRef] = Task {
  val pipFile = Task.dest / "get-pip.py"
  val pipPath = os.home / ".local" / "bin" / "pip3"

  if (!os.exists(pipPath)) {
    os.call(Seq("wget", "-q", "https://bootstrap.pypa.io/get-pip.py", "-O", s"$pipFile"))
    os.call(Seq(
      "python3",
      s"$pipFile",
      "--user",
      "--break-system-packages",
      "--no-warn-script-location"
    ))

    os.call(Seq(
      pipPath.toString,
      "install",
      "pip",
      "--break-system-packages",
      "--no-warn-script-location"
    ))
  } else {
    println("pip is already installed, skipping installation.")
  }
  PathRef(Task.dest)
}

// The `installPip` task ensures the Python package manager `pip` 
// is available in a user’s environment without requiring admin permissions.
// It checks if `pip` is already installed in the user’s home directory. If not,
// it downloads a setup script (`https://bootstrap.pypa.io/get-pip.py[get-pip.py]`) from Python’s official repository,
// runs it to install `pip` specifically for the user, and updates `pip` to the latest version.
// This allows Python packages to be managed locally without needing system-level access.

// === Defining our Sources

// Next, We define the `sources` and `allSources` tasks to help gather Python files for processing. 
// `sources` sets a base directory for Python source files,
// while `allSources` searches this directory (and its subdirectories) to collect all `.py` files.
// Together, they enable easy access to Python files in a project,
// making it straightforward to retrieve all relevant code files for tasks like building, testing, or analysis.

def sources: T[PathRef] = Task.Source(millSourcePath / "src")

def allSources: T[Seq[PathRef]] = Task {
  os.walk(sources().path).filter(_.ext == "py").map(PathRef(_))
}

// === Compilation

// The `mainFileName` and `compile` Tasks work to manage
// a project’s main Python file, `"main.py"`. `mainFileName` defines this file's expected name,
// while `mainFile` searches through source files to locate it, throwing an error if it’s missing.
// `compile` then ensures `pip` is installed, retrieves the main file path, and returns it for further processing.
// Together, these functions prepare the main entry file and dependencies, making the project ready for execution or packaging.

def mainFileName: T[String] = Task { "main.py" }

def compile: T[PathRef] = Task {
  installPip()
  val mainFileDir = sources().path

  PathRef(mainFileDir)
}

// At this point, we have a minimal working build, with a build graph that looks like this:
//
// ```graphviz
// digraph G {
//   rankdir=LR
//   node [shape=box width=0 height=0 style=filled fillcolor=white]
//   pipInstall -> compile
//   sources -> allSources -> compile
//   mainFileName -> mainFile -> compile
// }
// ```

// In relation to all tasks,
// `main.py` Script serves as the executable part of the project. These Tasks ensure that
// main file is correctly located and validated. When `compile` retrieves its path and
// prepares it for execution, running this file will result in either a generic greeting 
// or a personalized one based on the command-line arguments passed, allowing for flexible interaction with the user.

/** See Also: src/main.py */


// === Running

// The `run` function executes the main Python file (`main.py`) and accepts command-line arguments from the user. 
// It uses `os.call` to run the Python interpreter with the main file's path and any additional arguments.
// The output is shown in the console, allowing for real-time interaction.
// This function builds on the earlier steps by using the validated main file from the
// `compile` function, ensuring smooth execution of the project's main functionality.

def run(args: mill.define.Args) = Task.Command {
  os.call(
    Seq(
      "python3",
      s"${compile().path / mainFileName()}"
    ) ++ args.value,
    stdout = os.Inherit
  )
}

// Note that we use `stdout = os.Inherit` since we want to display any output to the user, rather than capturing it for use in our command.

// ```graphviz
// digraph G {
//   rankdir=LR
//   node [shape=box width=0 height=0 style=filled fillcolor=white]
//   pipInstall -> compile
//   sources -> allSources -> compile -> run
//   mainFileName -> mainFile -> compile
//   compile [color=green, penwidth=3]
//   run [color=green, penwidth=3]
// }
// ```

/** Usage
 
> ./mill run Mill Python
Hello, Mill Python!

*/

// So that's a minimal example of implementing a `Basic Python
// pipeline` locally. Next, we will look at turning it into a `PythonModule` that
// can be re-used