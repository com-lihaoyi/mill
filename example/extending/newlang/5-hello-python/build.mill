// == Python Integration in Mill

// This Example shows how to integrate https://www.python.org[Python] into a Mill build, enabling Python script compilation.
// Mill does not come bundled with Python support, so we will set up integration using `python3`, which is generally pre-installed.

// === Python initialization Setup
//
// First, The `setup` task creates a Python virtual environment and installs `mypy` for type-checking.

// `mypy` verifies type correctness using Python's `type hints`, helping to catch errors in development.

// Guides:
// https://packaging.python.org/en/latest/guides/installing-using-pip-and-virtual-environments[Python virtual environment]
// & https://mypy.readthedocs.io/en/stable[mypy]

package build
import mill._

def setup: T[PathRef] = Task {
  val pythonVenv = Task.dest / "venv" / "bin" / "python3"

  os.call(("python3", "-m", "venv", Task.dest / "venv"))
  os.call((pythonVenv, "-m", "pip", "install", "mypy"))

  PathRef(pythonVenv)
}

// === Defining our Sources

// The `sources` task specifies the directory for Python source files (`src` folder).
// This setup facilitates organizing and accessing Python files needed for building, testing, or analysis.

def sources: T[PathRef] = Task.Source(millSourcePath / "src")

// === Type Checking

// The `typeCheck` task verifies that the code in the main Python file passes type checks.
// It checks for errors before execution to ensure a reliable setup for running Python scripts.

def typeCheck: T[PathRef] = Task {
  val pythonVenv = setup().path

  os.call(
    (pythonVenv, "-m", "mypy", "--strict", sources().path),
    stdout = os.Inherit
  )

  PathRef(pythonVenv)
}

// At this point, we have a minimal working build, with a build graph that looks like this:
//
// ```graphviz
// digraph G {
//   rankdir=LR
//   node [shape=box width=0 height=0 style=filled fillcolor=white]
//   setup -> typeCheck
//   sources -> typeCheck
//   mainFileName -> typeCheck
// }
// ```

// Here is the `main.py` file
/** See Also: src/main.py */

// === Running

// The `mainFileName` task defines the name of the main Python script (`main.py`).

// The `run` function runs the main file with user-provided command-line arguments.
// It uses the virtual environment's Python interpreter to execute the script, with output displayed in the console.

def mainFileName: T[String] = Task { "main.py" }
def run(args: mill.define.Args) = Task.Command {
  val pythonVenv = typeCheck().path

  os.call(
    (pythonVenv, sources().path / mainFileName(), args.value),
    stdout = os.Inherit
  )
}

// Note that we use `stdout = os.Inherit` since we want to display any output to the user,
// rather than capturing it for use in our command.

// ```graphviz
// digraph G {
//   rankdir=LR
//   node [shape=box width=0 height=0 style=filled fillcolor=white]
//   setup -> typeCheck -> run
//   sources -> typeCheck
//   mainFileName -> typeCheck
//   sources -> run
//   mainFileName -> run
//   mainFileName [color=green, penwidth=3]
//   run [color=green, penwidth=3]
// }
// ```

// Running run command will return the result to the console.

/** Usage

> ./mill typeCheck
Success: no issues found in 1 source file

> ./mill run Mill Python
Hello, Mill Python!
15

> sed -i.bak 's/add/addd/g' build.mill

> ./mill typeCheck # if we make a typo in a method name, mypy flags it
error: ...Name "addd" is not defined...

*/

// This completes a basic `Python integration in Mill`.
// Next steps could involve transforming this into a `reusable PythonModule`
