// == Basic Python Pipeline 

// This Example demonstrates integration of https://www.python.org[Python]
// compilation into a Mill build to compile https://www.python.org[Python] Scripts. Mill
// does not come bundled with https://www.python.org[Python] integration, so here we begin setting
// one up from first principles using the Basic `Python3`(Already Present in OS) command Line


// === Installing Python Pip
//
// First, we need to use the `Python3` CLI tool to install `Pip` 
// using the official https://bootstrap.pypa.io/get-pip.py[get-pip.py] Code:

package build
import mill._

// def installPip: T[PathRef] = Task {
//   val pipFile = Task.dest / "get-pip.py"
//   val pipPath = os.home / ".local" / "bin" / "pip3"

//   if (!os.exists(pipPath)) {
//     os.call(Seq("wget", "-q", "https://bootstrap.pypa.io/get-pip.py", "-O", s"$pipFile"))
//     os.call(Seq(
//       "python3",
//       s"$pipFile",
//       "--user",
//       "--break-system-packages",
//       "--no-warn-script-location"
//     ))

//     os.call(Seq(
//       pipPath.toString,
//       "install",
//       "pip",
//       "--break-system-packages",
//       "--no-warn-script-location"
//     ))
//   } else {
//     println("pip is already installed, skipping installation.")
//   }
//   PathRef(Task.dest)
// }

// The `installPip` task ensures the Python package manager `pip` 
// is available in a user’s environment without requiring admin permissions.
// It checks if `pip` is already installed in the user’s home directory. If not,
// it downloads a setup script (`https://bootstrap.pypa.io/get-pip.py[get-pip.py]`) from Python’s official repository,
// runs it to install `pip` specifically for the user, and updates `pip` to the latest version.
// This allows Python packages to be managed locally without needing system-level access.

// === Defining our Sources

// Next, We define the `sources` and `allSources` tasks to help gather Python files for processing. 
// `sources` sets a base directory for Python source files,
// while `allSources` searches this directory (and its subdirectories) to collect all `.py` files.
// Together, they enable easy access to Python files in a project,
// making it straightforward to retrieve all relevant code files for tasks like building, testing, or analysis.

def sources: T[PathRef] = Task.Source(millSourcePath / "src")

// def allSources: T[Seq[PathRef]] = Task {
//   os.walk(sources().path).filter(_.ext == "py").map(PathRef(_))
// }

// === Compilation

// The `compile` Task  ensures `pip` is installed, retrieves the main file directory, and returns it for further processing.
// This task is considered as a part of code which is responsible for all compilation of sources and pre-requirements.

// def compile: T[PathRef] = Task {
//   // installPip()
//   val mainFileDir = sources().path
  
//   PathRef(mainFileDir)
// }

// At this point, we have a minimal working build, with a build graph that looks like this:
//
// ```graphviz
// digraph G {
//   rankdir=LR
//   node [shape=box width=0 height=0 style=filled fillcolor=white]
//   installPip -> compile
//   sources -> compile
// }
// ```

// When `compile` task installs pip and gives the path for main file directory
// then we have `main.py` in this path and running this file will result in either a generic greeting 
// or a personalized one based on the command-line arguments passed, allowing for flexible interaction with the user.

/** See Also: src/main.py */


// === Running

// The `run` function executes the main Python file (`main.py`) and accepts command-line arguments from the user. 
// It uses `os.call` to run the Python interpreter with the main file's path and any additional arguments.
// The output is shown in the console, allowing for real-time interaction.
  
def mainFileName: T[String] = Task { "main.py" }

def run(args: mill.define.Args) = Task.Command {
  os.call(
    Seq(
      "python3",
      s"${sources().path / mainFileName()}"
    ) ++ args.value,
    stdout = os.Inherit
  )
}

// Note that we use `stdout = os.Inherit` since we want to display any output to the user, rather than capturing it for use in our command.

// ```graphviz
// digraph G {
//   rankdir=LR
//   node [shape=box width=0 height=0 style=filled fillcolor=white]
//   installPip -> compile
//   sources -> compile -> run
//   mainFileName -> run
//   mainFileName [color=green, penwidth=3]
//   run [color=green, penwidth=3]
// }
// ```

// Running run command will return the result to the console.

/** Usage
 
> ./mill run Mill Python
Hello, Mill Python!

*/

// So that's a minimal example of implementing a `Basic Python
// pipeline` locally. Next, we will look at turning it into a `PythonModule` that
// can be re-used
