// == Python MyPy Support

// This Example extends `PythonModule` trait for `MyPy` support, offering structured `type-checking` in Python projects using Mill.

// `MyPy` is a static type checker that uses Python `type hints` to enforce `type correctness` and `catch errors` during development.

// ==== Extending `PythonModule` for `MyPy` Support

// This Example creates the `runMyPy` Task to run `MyPy`:
// 
// - def `runMyPy` Task checks the python file before the actual excetution of the file
//   for `type-checking` and logs out success or error based on file defination.

package build
import mill._

/**
 * A trait for managing Python environments and dependencies in a Mill build.
 */
trait PythonModule extends Module {

  /** List of module dependencies required by this module. */
  def moduleDeps: Seq[PythonModule] = Nil

  /** Specifies dependencies to install in the virtual environment. */
  def dependencies: T[Seq[String]] = Task { Seq.empty[String] }

  /** Specifies the name of the virtual environment directory. */
  def venvName: T[String] = Task { "venv" }

  /** Specifies the name of the main Python file. */
  def mainFileName: T[String] = Task { "main.py" }

  /** Defines the path to the sources directory. */
  def sources: T[PathRef] = Task.Source(millSourcePath / "src")

  // /** Collects all Python source files from the sources directory. */
  // def allSources: T[Seq[PathRef]] = Task {
  //   os.walk(sources().path).filter(_.ext == "py").map(PathRef(_))
  // }

  /** Path to the requirements file, configurable by the user. */
  def requirementsPath: T[PathRef] = Task.Source(millSourcePath / "requirements.txt")


  /** Reads dependencies from the specified requirements file. */
  def requirementsDependencies: T[Seq[String]] = Task {
    val reqFile = requirementsPath().path
    if (os.exists(reqFile)) {
      os.read.lines(reqFile).map(_.trim).filter(_.nonEmpty)
    } else {
      Seq.empty[String]
    }
  }

  // /** Installs pip using a downloaded script. */
  // def installPip: T[Unit] = Task {
  //   val pipFile = T.dest / "get-pip.py"
  //   val pipPath = os.home / ".local" / "bin" / "pip3"

  //   if (!os.exists(pipPath)) {
  //     os.call(Seq("wget", "-q", "https://bootstrap.pypa.io/get-pip.py", "-O", s"$pipFile"))
  //     os.call(Seq(
  //       "python3",
  //       s"$pipFile",
  //       "--user",
  //       "--break-system-packages",
  //       "--no-warn-script-location"
  //     ))

  //     os.call(Seq(
  //       pipPath.toString,
  //       "install",
  //       "pip",
  //       "--break-system-packages",
  //       "--no-warn-script-location"
  //     ))
  //   } else {
  //     println("pip is already installed, skipping installation.")
  //   }
  // }

  /** Creates a virtual environment using the installed Python version. */
  def createVenv: T[PathRef] = Task {
    // installPip()
    val venvDir = T.dest / venvName()

    // os.call(Seq(
    //   "python3",
    //   "-m",
    //   "pip",
    //   "install",
    //   "virtualenv",
    //   "--break-system-packages",
    //   "--no-warn-script-location"
    // ))
    os.call(Seq("python3", "-m", "venv", venvDir.toString))

    PathRef(venvDir)
  }

  // /** Activates the created virtual environment. */
  // def activateVenv: T[PathRef] = Task {
  //   val venvBin = createVenv().path / "bin"
  //   os.call(Seq("bash", "-c", s"source ${venvBin / "activate"}"))
  //   PathRef(venvBin)
  // }

  /** Collects all dependencies for installation, including requirements and module dependencies. */
  def finalDependencies: T[Seq[String]] = Task {

    val upstreamDependencies = Task.traverse(moduleDeps)(_.finalDependencies)()

    (dependencies().map(_.toString) ++ requirementsDependencies().map(
      _.toString
    ) ++ upstreamDependencies.flatten.map(_.toString)).distinct

  }

  /** Installs specified dependencies in the virtual environment. */
  def installDependencies: T[PathRef] = Task {
    val pythonVenv = createVenv().path / "bin" / "python3"

    if (finalDependencies().nonEmpty) {
      os.call(Seq(
        pythonVenv.toString,
        "-m",
        "pip",
        "install"
      ) ++ finalDependencies() ++ Seq(
        "--break-system-packages",
        "--no-warn-script-location"
      ))
    }

    PathRef(pythonVenv)
  }

  /** Compile installs dependencies in virtual environment. */
  def compile: T[PathRef] = Task {
    val pythonVenv = installDependencies().path
    // val mainFileDir = sources().path

    PathRef(pythonVenv)
  }

  /** Runs the main Python file with specified command-line arguments. */
  def run(args: mill.define.Args) = Task.Command {

    val upstream = Task.traverse(moduleDeps)(_.sources)().zip(moduleDeps)
    for (((mainFileDir), mod) <- upstream) {
      val destinationPath = Task.dest / mod.millSourcePath.subRelativeTo(build.millSourcePath)
      os.copy.over(mainFileDir.path / os.up, destinationPath)
    }

    os.call(
      Seq(
        compile().path.toString,
        s"${sources().path / mainFileName()}"
      ) ++ args.value,
      env = Map("PYTHONPATH" -> Task.dest.toString),
      stdout = os.Inherit
    )
  }

  /** Checks the main Python file using Mypy with specified command-line arguments. */
  def runMyPy(args: mill.define.Args) = Task.Command {

    val upstream = Task.traverse(moduleDeps)(_.sources)().zip(moduleDeps)
    for(((mainFileDir), mod) <- upstream) {
      val destinationPath = Task.dest / mod.millSourcePath.subRelativeTo(build.millSourcePath)
      os.copy.over(mainFileDir.path / os.up, destinationPath)
    }

    os.call(
      Seq(
        compile().path.toString,
        "-m",
        "mypy",
        "--strict",
        s"${sources().path / mainFileName()}"
      ) ++ args.value,
      env = Map("PYTHONPATH" -> Task.dest.toString),
      stdout = os.Inherit
    )
  }

}

// ==== Example

// This example defines two objects, `success` and `error`, both of which inherit from `PythonModule`:

// - `success`: An object that demonstrates successful type-checking using `MyPy`, with the necessary dependencies.
// - `error`: An object that shows how `MyPy` flags type errors when mismatched types are detected. 
//    Users can simulate errors by uncommenting mentioned lines in the source code, prompting `run` to display errors.

object success extends PythonModule{
  override def dependencies: T[Seq[String]] = Task { Seq[String]("mypy") }
}

object error extends PythonModule{
  override def dependencies: T[Seq[String]] = Task { Seq[String]("mypy") }
}

// Here are the Main Script files for above example:
/** See Also: success/src/main.py */
/** See Also: error/src/main.py */
// User can Customise these Files as per their Needs.

// To run MyPy checks in Mill, the following commands execute type-checking on each object:

/** Usage

> ./mill success.runMyPy
Success: no issues found in 1 source file

> ./mill error.runMyPy
Success: no issues found in 1 source file
// Uncomment the Result variable line(Line Number:13) in the `Error/src/main.py` code to see error

*/

// So this is the basic example for `MyPy` support in Mill. Next, we will see the `Pex` Support Example