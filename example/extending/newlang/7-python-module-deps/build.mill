// == PythonModule moduleDeps
// This example demonstrates the support for Module dependencies
// in Python projects by extending the `PythonModule` trait further.
// This approach is particularly useful for projects that need
// dynamic dependency handling and isolated environments for each module.

// ==== Extending `PythonModule` Trait 

// The `PythonModule` trait now provides tasks for moduleDeps Support, managing the execution context of Python files. 

// - def `moduleDeps` Task is used to allow different `PythonModules` to depend on each other, 
//   and we use `Task.traverse` to combine the `upstream dependencies` for setup in `typeCheck`,
//   and checked the `upstream modules` for use in `run` Task and gathered source files from upstream
//   for running main file

package build
import mill._

/**
 * PythonModule trait Extended for ModuleDeps Support with full setup in a Mill build.
 */
trait PythonModule extends Module {

  /** List of module dependencies required by this module. */
  def moduleDeps: Seq[PythonModule] = Nil

  /** Returns the path to the source directory containing Python files. */
  def sources: T[PathRef] = Task.Source(millSourcePath / "src")

  /** Returns the name of the main Python file. */
  def mainFileName: T[String] = Task { "main.py" }

  /** This minimal setup provide basic Virtual Environment and Type Checking. */
  def setup: T[PathRef] = Task {
    // creating virtual environment
    os.call(("python3","-m","venv",Task.dest / "venv"))

    val pythonVenv = Task.dest / "venv" / "bin" / "python3"
    
    // installing mypy for Type Checking
    os.call((pythonVenv,"-m","pip","install","mypy"))

    PathRef(pythonVenv)
  }

  /** Creates Virtual env and check main file. */
  def typeCheck: T[PathRef] = Task {
    // Checks upstream modules for error free code
    val upstreamTypeCheck = Task.traverse(moduleDeps)(_.typeCheck)()

    val pythonVenv = setup().path

    os.call(
      (pythonVenv,"-m","mypy","--strict",sources().path / mainFileName()),
      stdout = os.Inherit
    )

    PathRef(pythonVenv)
  }

  /** Runs the main Python file with specified command-line arguments. */
  def run(args: mill.define.Args) = Task.Command {

    val upstream = Task.traverse(moduleDeps)(_.sources)().zip(moduleDeps)

    for (((sourcesFolder), mod) <- upstream) {
      val destinationPath = Task.dest / mod.millSourcePath.subRelativeTo(build.millSourcePath)
      os.copy.over(sourcesFolder.path / os.up, destinationPath)
    }

    val pythonVenv = typeCheck().path

    os.call(
      (pythonVenv,sources().path / mainFileName(),args.value),
      env = Map("PYTHONPATH" -> Task.dest.toString),
      stdout = os.Inherit
    )
  }

}
// Note the use of `Task.traverse(moduleDeps)` in order to aggregate the `typeCheck`
// output of the upstream modules, which is necessary before running any code, finally 
// it gathers upstream modules `sources` for further processing in `run` Task
//
// ==== Example
// 
// Again, we can instantiate `PythonModule` three times, but now `foo/src/foo.py`
// and `foo/bar/src/bar.py` export their APIs which are then imported in `qux/src/qux.py`:

object foo extends PythonModule{
  override def mainFileName: T[String] = Task { "foo.py" }
  object bar extends PythonModule{
      override def mainFileName: T[String] = Task { "bar.py" }
  }
}

object qux extends PythonModule{

  override def mainFileName: T[String] = Task { "qux.py" }

  def moduleDeps: Seq[PythonModule] = Seq[PythonModule](foo, foo.bar)

}
// Below are the Files from Source Folders

/** See Also: foo/src/foo.py */
/** See Also: foo/bar/src/bar.py */
/** See Also: qux/src/qux.py */

// See, How we have imported the other files(foo.py & bar.py) functions in `qux.py` file

// To run this build script, use the following command. 

/** Usage

> ./mill qux.run 10 20
Add: 10 + 20 = 30 | Multiply: 10 * 20 = 200 | Divide: 10 / 20 = 0.5

*/

// The dependency graph of tasks now looks like this, with the output of
// (`foo.typeCheck` & `foo.sources`) and (`bar.typeCheck` & `bar.sources`)
//  now being fed into `qux.typeCheck` and ultimately `qux.run`:
//
// ```graphviz
// digraph G {
//   rankdir=LR
//   node [shape=box width=0 height=0 style=filled fillcolor=white]
//   subgraph cluster_3 {
//     style=dashed
//     label=qux
//     "qux.setup" -> "qux.typeCheck" -> "qux.run"
//     "qux.sources" -> "qux.typeCheck"
//     "qux.mainFileName" -> "qux.typeCheck"
//     "qux.sources" -> "qux.run"
//     "qux.mainFileName" -> "qux.run"
//   }
//   subgraph cluster_1 {
//     subgraph cluster_2 {
//       style=dashed
//       label=bar
//       "bar.setup" -> "bar.typeCheck" -> "bar.run"
//       "bar.sources" -> "bar.typeCheck"
//       "bar.mainFileName" -> "bar.typeCheck"
//       "bar.sources" -> "bar.run"
//       "bar.mainFileName" -> "bar.run"
//     }
//     style=dashed
//     label=foo
//     "foo.setup" -> "foo.typeCheck" -> "foo.run"
//     "foo.sources" -> "foo.typeCheck"
//     "foo.mainFileName" -> "foo.typeCheck"
//     "foo.sources" -> "foo.run"
//     "foo.mainFileName" -> "foo.run"
//   }
//   "bar.typeCheck" -> "qux.typeCheck"  [color=green, penwidth=3]
//   "bar.sources" -> "qux.run"  [color=green, penwidth=3]
//   "foo.typeCheck" -> "qux.typeCheck"  [color=green, penwidth=3]
//   "foo.sources" -> "qux.run"  [color=green, penwidth=3]
// }
// ```