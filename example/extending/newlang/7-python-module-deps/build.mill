// == PythonModule moduleDeps, virtualEnv & libraryDeps
// This example demonstrates the support for Module dependencies, virtual environment & Library Dependencies
// in Python projects by extending the `PythonModule` trait further.
// This approach is particularly useful for projects that need dynamic dependency handling and isolated environments for each module.

// ==== Extending `PythonModule` Trait 

// The `PythonModule` trait now provides tasks for moduleDeps Support, creating virtual environments,
// installing dependencies, and managing the execution context of Python files. 

// 1. def `moduleDeps` Task is used to allow different `PythonModules` to depend on each other, 
//    and we use `Task.traverse` to combine the `upstream dependencies` for installation in `compile`,
//    and compiled the `upstream modules` for use in `run` Task

// 2. def `createVenv` Task creates the python `virtual environment` for creating isolated Environments
//    for installing multiple library dependencies required for running python files successfully.
//    Furthermore, it provides `activateVenv` Task to activate the virtual environment for further processing.

// 3. def `installDependencies` Task installs the dependencies in the activated virtual environment 
//    and these dependencies can be managed in two ways:
//
//    - Inline dependencies in the Mill build script (e.g., `requests` in this example).
//      This can be done using `dependencies` Task.
//    - External dependencies listed in a `requirements.txt` file, such as `numpy` and `pandas`.
//      This can be done using the `requirementsDependencies` Task.

package build
import mill._

/**
 * A trait for managing Python environments and dependencies in a Mill build.
 */
trait PythonModule extends Module {

  /** List of module dependencies required by this module. */
  def moduleDeps: Seq[PythonModule] = Nil

  /** Specifies dependencies to install in the virtual environment. */
  def dependencies: T[Seq[String]] = Task { Seq.empty[String] }

  /** Specifies the name of the virtual environment directory. */
  def venvName: T[String] = Task { "venv" }

  /** Specifies the name of the main Python file. */
  def mainFileName: T[String] = Task { "main.py" }

  /** Defines the path to the sources directory. */
  def sources: T[PathRef] = Task.Source(millSourcePath / "src")

  /** Collects all Python source files from the sources directory. */
  def allSources: T[Seq[PathRef]] = Task {
    os.walk(sources().path).filter(_.ext == "py").map(PathRef(_))
  }

  /** Path to the requirements file, configurable by the user. */
  def requirementsPath: T[PathRef] = Task {
    PathRef(millSourcePath / "src" / "requirements.txt")
  }

  /** Reads dependencies from the specified requirements file. */
  def requirementsDependencies: T[Seq[String]] = Task {
    val reqFile = requirementsPath().path
    if (os.exists(reqFile)) {
      os.read.lines(reqFile).map(_.trim).filter(_.nonEmpty)
    } else {
      Seq.empty[String]
    }
  }

  /** Installs pip using a downloaded script. */
  def installPip: T[Unit] = Task {
    val pipFile = T.dest / "get-pip.py"
    val pipPath = os.home / ".local" / "bin" / "pip3"

    if (!os.exists(pipPath)) {
      os.call(Seq("wget", "-q", "https://bootstrap.pypa.io/get-pip.py", "-O", s"$pipFile"))
      os.call(Seq(
        "python3",
        s"$pipFile",
        "--user",
        "--break-system-packages",
        "--no-warn-script-location"
      ))

      os.call(Seq(
        pipPath.toString,
        "install",
        "pip",
        "--break-system-packages",
        "--no-warn-script-location"
      ))
    } else {
      println("pip is already installed, skipping installation.")
    }
  }

  /** Creates a virtual environment using the installed Python version. */
  def createVenv: T[PathRef] = Task {
    installPip()
    val venvDir = T.dest / venvName()

    os.call(Seq(
      "python3",
      "-m",
      "pip",
      "install",
      "virtualenv",
      "--break-system-packages",
      "--no-warn-script-location"
    ))
    os.call(Seq("python3", "-m", "virtualenv", venvDir.toString))

    PathRef(venvDir)
  }

  /** Activates the created virtual environment. */
  def activateVenv: T[PathRef] = Task {
    val venvBin = createVenv().path / "bin"
    os.call(Seq("bash", "-c", s"source ${venvBin / "activate"}"))
    PathRef(venvBin)
  }

  /** Collects all dependencies for installation, including requirements and module dependencies. */
  def finalDependencies: T[Seq[String]] = Task {

    val upstreamDependencies = Task.traverse(moduleDeps)(_.finalDependencies)()

    (dependencies().map(_.toString) ++ requirementsDependencies().map(
      _.toString
    ) ++ upstreamDependencies.flatten.map(_.toString)).distinct

  }

  /** Installs specified dependencies in the virtual environment. */
  def installDependencies: T[PathRef] = Task {
    val pythonVenv = activateVenv().path / "python3"

    if (finalDependencies().nonEmpty) {
      os.call(Seq(
        pythonVenv.toString,
        "-m",
        "pip",
        "install"
      ) ++ finalDependencies() ++ Seq(
        "--break-system-packages",
        "--no-warn-script-location"
      ))
    }

    PathRef(pythonVenv)
  }

  /** Compile installs dependencies in virtual environment. */
  def compile: T[(PathRef, PathRef)] = Task {
    val pythonVenv = installDependencies().path
    val mainFileDir = sources().path

    (PathRef(pythonVenv), PathRef(mainFileDir))
  }

  /** Runs the main Python file with specified command-line arguments. */
  def run(args: mill.define.Args) = Task.Command {

    val upstream = Task.traverse(moduleDeps)(_.compile)().zip(moduleDeps)
    for (((_, mainFileDir), mod) <- upstream) {
      val destinationPath = Task.dest / mod.millSourcePath.subRelativeTo(build.millSourcePath)
      os.copy.over(mainFileDir.path / os.up, destinationPath)
    }

    os.call(
      Seq(
        compile()._1.path.toString,
        s"${compile()._2.path / mainFileName()}"
      ) ++ args.value,
      env = Map("PYTHONPATH" -> Task.dest.toString),
      stdout = os.Inherit
    )
  }

}
// Note the use of `Task.traverse(moduleDeps)` in order to aggregate the `compile`
// output of the upstream modules, which is necessary both to configure the `Virtual Environment`
// and installing the `dependencies` from the upstream and main module finally it compiles individual
// modules and give results for further processing in `run` Task
//
// ==== Example
// 
// Again, we can instantiate `PythonModule` three times, but now `foo/src/foo.py`
// and `foo/bar/src/bar.py` export their APIs which are then imported in `qux/src/qux.py`:

object foo extends PythonModule{
  override def mainFileName: T[String] = Task { "foo.py" }
  object bar extends PythonModule{
      override def mainFileName: T[String] = Task { "bar.py" }

    // foo and bar object dependencies are given 
    // in their respective requirements.txt
  }
}

object qux extends PythonModule{

  override def mainFileName: T[String] = Task { "qux.py" }

  // To show both requirements.txt and inline dependencies
  // we used inline dependency here and requirements.txt in above foo and bar object
  override def dependencies: T[Seq[String]] = Task{ Seq[String]("requests") }

  def moduleDeps: Seq[PythonModule] = Seq[PythonModule](foo, foo.bar)

}
// Below are the Files from Source Folders

/** See Also: foo/src/foo.py */
/** See Also: foo/src/requirements.txt */
/** See Also: foo/bar/src/bar.py */
/** See Also: foo/bar/src/requirements.txt */
/** See Also: qux/src/qux.py */

// User can also mention particular versions of the dependencies as per the rules of requirements.txt

// To run this build script, use the following command. 

/** Usage

> ./mill qux.run
NumPy Example: Array: [1 2 3 4 5] ; Mean: 3.0 ; Sum: 15 | Pandas Example: Average Age: 26.0 ; Cities: ['New York' 'Los Angeles' 'Chicago'] | Requests Example: Requests is working! ; Status Code=200

*/

// The dependency graph of tasks now looks like this, with the output of
// `foo.compile` and `bar.compile` now being fed into `qux.compile` (and
// ultimately `qux.run`):
//
// ```graphviz
// digraph G {
//   rankdir=LR
//   node [shape=box width=0 height=0 style=filled fillcolor=white]
//   subgraph cluster_3 {
//     style=dashed
//     label=qux
//     "qux.installPip" -> "qux.compile"
//     "qux.sources" -> "qux.compile" -> "qux.run"
//     "qux.mainFileName" -> "qux.run"
//   }
//   subgraph cluster_1 {
//     subgraph cluster_2 {
//       style=dashed
//       label=bar
//       "bar.installPip" -> "bar.compile"
//       "bar.sources" -> "bar.compile" -> "bar.run"
//       "bar.mainFileName" -> "bar.run"
//     }
//     style=dashed
//     label=foo
//     "foo.installPip" -> "foo.compile"
//     "foo.sources" -> "foo.compile" -> "foo.run"
//     "foo.mainFileName" -> "foo.run"
//   }
//   "bar.compile" -> "qux.compile"  [color=green, penwidth=3]
//   "foo.compile" -> "qux.compile"  [color=green, penwidth=3]
// }
// ```