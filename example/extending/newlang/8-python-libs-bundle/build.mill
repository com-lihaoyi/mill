// == Python Library Dependencies & Bundling

// This Example introduces support for `installing library dependencies`
// and `Pex packaging` in the `PythonModule` trait.
// 
// Pex (Python EXecutable) enables bundling Python applications into single-file executables,
// allowing easy distribution and execution without additional dependencies.

// ==== Extending PythonModule For Pex Support 

// This Example extends the `PythonModule` by addig the following functions:

// - def `requirementsPath`: Sets the path to `requirements.txt`, listing external dependencies.
//   Defaults to "requirements.txt" but can be customized.
// - def `requirementsDependencies`: Reads dependencies from `requirements.txt`, 
//   returning each valid entry or an empty list if the file is missing.
// - def `finalDependencies`: Merges dependencies from multiple sources into a unique list,
//   eliminating duplicates for efficient installation.
// - def `bundle`: Packages the entire project and dependencies into a 
//   single .pex executable (result.pex) for easy deployment.

package build
import mill._

/**
 * PythonModule trait Extended for bundling and installing
 * library dependencies with execution in a Mill build.
 */
trait PythonModule extends Module {

  /** List of module dependencies required by this module. */
  def moduleDeps: Seq[PythonModule] = Nil

  /** Specifies dependencies to install in the virtual environment. */
  def dependencies: T[Seq[String]] = Task { Seq.empty[String] }

  /** Specifies the name of the main Python file. */
  def mainFileName: T[String] = Task { "main.py" }

  /** Defines the path to the sources directory. */
  def sources: T[PathRef] = Task.Source(millSourcePath / "src")

  /** Path to the requirements file, configurable by the user. */
  def requirementsPath: T[PathRef] = Task.Source(millSourcePath / "requirements.txt")

  /** Reads dependencies from the specified requirements file. */
  def requirementsDependencies: T[Seq[String]] = Task {
    val reqFile = requirementsPath().path
    if (os.exists(reqFile)) {
      os.read.lines(reqFile).map(_.trim).filter(_.nonEmpty)
    } else {
      Seq.empty[String]
    }
  }

  /** Collects all dependencies for installation, including requirements and module dependencies. */
  def finalDependencies: T[Seq[String]] = Task {

    val upstreamDependencies = Task.traverse(moduleDeps)(_.finalDependencies)()

    (
      dependencies().map(_.toString) 
      ++ requirementsDependencies().map(_.toString) 
      ++ upstreamDependencies.flatten.map(_.toString)
    ).distinct

  }

  /** Creates a virtual environment using the installed Python version. */
  def createVenv: T[PathRef] = Task {
    val venvDir = T.dest / "venv"

    os.call(
      Seq(
        "python3",
        "-m",
        "venv",
        venvDir.toString
      )
    )

    PathRef(venvDir)
  }

  /** This minimal setup provide basic Virtual Environment and installing dependencies. */
  def setup: T[PathRef] = Task {
    // creating virtual environment
    val pythonVenv = createVenv().path / "bin" / "python3"
    
    // installing mypy for Type Checking
    // and pex for bundling
    os.call(
      Seq(
        pythonVenv.toString,
        "-m",
        "pip",
        "install",
        "mypy",
        "pex"
      )
    )

    // installs all library dependencies
    if (finalDependencies().nonEmpty) {
      os.call(
        Seq(
          pythonVenv.toString,
          "-m",
          "pip",
          "install"
        ) ++ finalDependencies()
      )
    }

    PathRef(pythonVenv)
  }

  /** Creates Virtual env and check main file. */
  def typeCheck: T[PathRef] = Task {
    // Checks upstream modules for error free code
    val upstreamTypeCheck = Task.traverse(moduleDeps)(_.typeCheck)()

    val pythonVenv = setup().path

    os.call(
      Seq(
        pythonVenv.toString,
        "-m",
        "mypy",
        "--strict",
        s"${sources().path / mainFileName()}"
      ),
      stdout = os.Inherit
    )

    PathRef(pythonVenv)
  }


  /** Runs the main Python file with specified command-line arguments. */
  def run(args: mill.define.Args) = Task.Command {

    val upstream = Task.traverse(moduleDeps)(_.sources)().zip(moduleDeps)

    for (((sourcesFolder), mod) <- upstream) {
      val destinationPath = Task.dest / mod.millSourcePath.subRelativeTo(build.millSourcePath)
      os.copy.over(sourcesFolder.path / os.up, destinationPath)
    }

    val pythonVenv = typeCheck().path

    os.call(
      Seq(
        pythonVenv.toString,
        s"${sources().path / mainFileName()}"
      ) ++ args.value,
      env = Map("PYTHONPATH" -> Task.dest.toString),
      stdout = os.Inherit
    )

  }

  /** Bundles the python project using pex(Python Executable) Library. */
  def bundle(args: mill.define.Args) = Task.Command {

    val pythonVenv = setup().path

    val pexFile = T.dest / "result.pex"

    val upstream = Task.traverse(moduleDeps)(_.sources)().zip(moduleDeps)

    for (((sourcesFolder), mod) <- upstream) {
      val destinationPath = Task.dest / mod.millSourcePath.subRelativeTo(build.millSourcePath)
      os.copy.over(sourcesFolder.path / os.up, destinationPath)
    }

    os.call(
      Seq(
        pythonVenv.toString,
        "-m",
        "pex",
      ) ++ finalDependencies() ++ Seq(
        "-c",
        s"${sources().path / mainFileName()}",
        "-o",
        pexFile.toString
      ) ++ args.value,
      env = Map("PYTHONPATH" -> Task.dest.toString),
      stdout = os.Inherit
    )

    PathRef(pexFile)
  }

}

// Note the use of `Task.traverse(moduleDeps)` in order to aggregate the upstream modules 
// library dependencies and the `typeCheck` outputs, which is necessary before running any 
// code, finally it gathers upstream modules `sources` for further processing in `run` Task

// ==== Example

// The object `pex` inherits from `PythonModule` and defines its dependencies:

// - `pex`: An object demonstrating `Pex` usage by defining project dependencies
//    within `requirements.txt` and inline(using dependencies task).

// Running `pex.runPex` creates a `.pex` file, suitable for easy distribution.

object pex extends PythonModule{
  // For Education Purpose both way of giving dependencies are discussed here
  // one dependency is mentioned in requirements.txt and one inline(below)
  override def dependencies: T[Seq[String]] = Task{ Seq("pandas") }

}

// Source Files For this Example: 
/** See Also: pex/src/main.py */
/** See Also: pex/requirements.txt */


// To run the project and create a `.pex` executable, use the following command:

/** Usage

> ./mill pex.run
Numpy : Sum: 150 | Pandas: Mean: 30.0, Max: 50

> ./mill show pex.bundle
".../out/pex/bundle.dest/result.pex"

*/

// This generates the `result.pex` file, which packages all dependencies 
// and can be executed as a standalone application.

// To Run the `result.pex` file, First Provide the executable permission(+x) 
// to result.pex and then run using `./result.pex` command.

// The final module tree and task graph is now as follows, with the additional dependencies
// tasks with upstream and the bundle tasks downstream:

// ```graphviz
// digraph G {
//   rankdir=LR;
//   node [shape=box, width=0, height=0, style=filled, fillcolor=white];
//   "pex.createVenv" -> "pex.setup" -> "pex.typeCheck" -> "pex.run";
//   "pex.typeCheck" -> "pex.bundle";
//   "pex.finalDependencies" -> "pex.setup";
//   "pex.finalDependencies" -> "pex.bundle";
//   "pex.sources" -> "pex.typeCheck";
//   "pex.mainFileName" -> "pex.typeCheck";
//   "pex.sources" -> "pex.run";
//   "pex.mainFileName" -> "pex.run";
//   "pex.sources" -> "pex.bundle";
//   "pex.mainFileName" -> "pex.bundle";
//   "pex.mainFileName" [color=green, penwidth=3];
//   "pex.run" [color=green, penwidth=3];
//   "pex.bundle" [color=green, penwidth=3];
// }
// ```
