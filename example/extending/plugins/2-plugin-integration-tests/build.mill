// == Integration Tests
//
// Integration tests are one step up from Unit tests: they are significantly slower to run due
// to running Mill in a subprocess, but are able to exercise the end-to-end lifecycle of a Mill
// command. Integration tests require further build configuration, which is shown below:

package build
import mill.*, scalalib.*, publish.*
import mill.util.BuildInfo.{millVersion, millBinPlatform}

object myplugin extends ScalaModule, PublishModule {
  def scalaVersion = "3.7.1"

  // Set the `platformSuffix` so the name indicates what Mill version it is compiled for
  def platformSuffix = s"_mill$millBinPlatform"

  // Depend on `mill-libs` so we can compile against Mill APIs
  def mvnDeps = Seq(mvn"com.lihaoyi::mill-libs:$millVersion")

  // Setup for integration/example tests
  object integration extends ScalaTests, TestModule.Utest {
    def mvnDeps = Seq(mvn"com.lihaoyi::mill-testkit:$millVersion")
    def forkEnv = Task {
      val artifact = s"${myplugin.pomSettings().organization}-${myplugin.artifactId()}"
        .replaceAll("[.-]", "_")
        .toUpperCase

      val localClasspathString = myplugin.localClasspath().map(_.path).mkString("\n")
      Map(
        "MILL_EXECUTABLE_PATH" -> millExecutable.assembly().path.toString,
        s"MILL_LOCAL_TEST_OVERRIDE_$artifact" -> localClasspathString
      )
    }

    // Create a Mill executable configured for testing our plugin
    object millExecutable extends JavaModule {
      def mvnDeps = Seq(mvn"com.lihaoyi:mill-runner-launcher_3:$millVersion")
      def mainClass = Some("mill.launcher.MillLauncherMain")
    }
  }

  // Publishing Config
  def publishVersion = "0.0.1"

  def pomSettings = PomSettings(
    description = "Line Count Mill Plugin",
    organization = "com.lihaoyi",
    url = "https://github.com/lihaoyi/myplugin",
    licenses = Seq(License.MIT),
    versionControl = VersionControl.github("lihaoyi", "myplugin"),
    developers = Seq(Developer("lihaoyi", "Li Haoyi", "https://github.com/lihaoyi"))
  )
}

/** Usage

 > ./mill myplugin.integration
+ myplugin.IntegrationTests.integration...
+ myplugin.ExampleTests.example...
...
*/

//
// Unlike unit tests which define a `TestRootModule` in-memory as part of the test code,
// Mill's integration tests rely on a `build.mill` that is processed and compiled as part of the
// test initialization, and can only perform assertions on the four things that are returned from
// any subprocess:
//
// 1. `.isSuccess: Boolean`, whether or the Mill subprocess returned with exit code 0
// 2. `.out: String`, the standard output captured by the Mill process
// 3. `.err: String`, the standard error captured by the Mill process
// 4. Any files that are generated on disk. In particular, files generated by tasks
//    can be fetched via the `tester.out("...").*` APIs to be read as JSON strings (via `.text`),
//    parsed `ujson.Value` ASTs (`.json`), or parsed into a typed Scala value (`.value[T]`)

/** See Also: myplugin/integration/src/mill/testkit/IntegrationTests.scala */
/** See Also: myplugin/integration/resources/integration-test-project/src/foo/Foo.java */
/** See Also: myplugin/integration/resources/integration-test-project/build.mill */

// Integration tests are generally used sparingly, but they are handy for scenarios where
// your Mill plugin logic prints to standard output or standard error, and you want to assert
// that the printed output is as expected.
//
// == Example Tests
//
// Example tests are a variant of the integration tests mentioned above, but instead of
// having the testing logic defined as part of the test suite in a `.scala` file, the testing
// logic is instead defined as a `/** Usage */` comment in the `build.mill`. These tests are
// a great way of documenting expected usage of your plugin: a user can glance at a single
// file to see how the plugin is imported (via `//| mvnDeps`) how it is used (e.g. by being
// extended by a module) and what commands they can run exercising the plugin and the resultant
// output they should expect:

/** See Also: myplugin/integration/src/mill/testkit/ExampleTests.scala */
/** See Also: myplugin/integration/resources/example-test-project/src/foo/Foo.java */
/** See Also: myplugin/integration/resources/example-test-project/build.mill */

// The `/** Usage */` comment is of the following format:
//
// * Each line prefixed with `>` is a command that is to be run
// * Following lines after commands are expected output, until the next blank line
// * If the command is expected to fail, the following lines should be prefixed by `error: `
// * Expected output lines can contain `...` wildcards to match against parts of the output
//   which are unstable or unnecessary for someone reading through the `build.mill`.
// * A `...` wildcard on its own line can be used to match against any number of additional
//   lines of output
//
// The line-matching for example tests is intentionally fuzzy: it does not assert that the
// ordering of the lines printed by the command matches the ordering given, as long as every
// line printed is given and every line given is printed. `...` wildcards intentionally add
// additional fuzziness to the matching. The point of example tests is not to match
// character-for-character exactly what the output must be, but to match on the "important"
// parts of the output while simultaneously emphasizing these important parts to someone who
// may be reading the `build.mill`
//
// Example tests are similar to integration tests in that they exercise the full Mill bootstrapping
// process, and are thus much slower and more expensive to run than unit tests. However, it is
// usually a good idea to have at least one example test for your Mill plugin, so a user who
// wishes to use it can take the `build.mill` and associated files and immediately have a Mill
// build that is runnable using your plugin, along with a list of commands they can run and
// what output they should expect.
//
