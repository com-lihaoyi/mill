// Althought running JVM bytecode via a one-off isolated classloader has less overhead
// than running it in a subprocess, the fact that the classloader needs to be created
// each time adds overhead: newly-created classloaders contain code that is not yet
// optimized by the JVM. When performance matters, you can put the classloader in a
// `Task.Worker` to keep it around, allowing the code internally to be optimized and
// stay optimized without being thrown away each time

// This example is similar to the earlier example running the Groovy interpreter in
// a subprocess, but instead of using `Jvm.runSubprocess` we use `ClassLoader.create` to
// load the Groovy interpreter classpath files:

package build
import mill._, javalib._
import mill.util.Jvm

object coursierModule extends CoursierModule

def groovyClasspath: Task[Agg[PathRef]] = Task{
  coursierModule.defaultResolver().resolveDeps(Agg(ivy"org.codehaus.groovy:groovy:3.0.9"))
}

def groovyWorker: Worker[java.net.URLClassLoader] = Task.Worker{
  mill.api.ClassLoader.create(groovyClasspath().map(_.path.toIO.toURL).toSeq, parent = null)
}

trait GroovyGenerateJavaModule extends JavaModule {
  def groovyScript = Task.Source(millSourcePath / "generate.groovy")

  def groovyGeneratedResources = Task{
    val oldCl = Thread.currentThread().getContextClassLoader
    Thread.currentThread().setContextClassLoader(groovyWorker())
    try {
      groovyWorker()
        .loadClass("groovy.ui.GroovyMain")
        .getMethod("main", classOf[Array[String]])
        .invoke(
          null,
          Array[String](
            groovyScript().path.toString,
            groovyGenerateArg(),
            (Task.dest / "groovy-generated.html").toString
          )
        )
    } finally Thread.currentThread().setContextClassLoader(oldCl)
    PathRef(Task.dest)
  }

  def groovyGenerateArg: T[String]
  def resources = super.resources() ++ Seq(groovyGeneratedResources())
}

object foo extends GroovyGenerateJavaModule{
  def groovyGenerateArg = "Foo Groovy!"
}
object bar extends GroovyGenerateJavaModule{
  def groovyGenerateArg = "Bar Groovy!"
}

// Here we have two modules `foo` and `bar`, each of which makes use of `groovyWorker`
// to evaluate a groovy script to generate some resources. In this case, we invoke the `main`
// method of `groovy.ui.GroovyMain`, which also happens to require us to set the
// `ContextClassLoader` to work.


/** Usage

> ./mill foo.run
Contents of groovy-generated.html is <html><body><h1>Hello!</h1><p>Foo Groovy!</p></body></html>

> ./mill bar.run
Contents of groovy-generated.html is <html><body><h1>Hello!</h1><p>Bar Groovy!</p></body></html>
*/


// Because the `URLClassLoader` within `groovyWorker` is long-lived, the code within the
// classloader can be optimized by the JVM runtime, and would have less overhead than if
// run in separate classloaders via `Jvm.runClassloader`. And because `URLClassLoader`
// already extends `AutoCloseable`, `groovyWorker` gets treated as an
// xref:fundamentals/tasks.adoc#_autoclosable_workers[Autocloseable Worker] automatically.

// NOTE: As mentioned in documentation for xref:fundamentals/tasks.adoc#_workers[Worker Tasks],
// the classloader contained within `groovyWorker` above is *initialized* in a single-thread,
// but it may be *used* concurrently in a multi-threaded environment. Practically, that means
// that the classes and methods you are invoking within the classloader do not make use of
// un-synchronized global mutable variables.
