//// SNIPPET:BUILD
package build
import mill.*, javalib.*

object `package` extends JavaModule {
  // You can have arbitrary numbers of third-party dependencies
  def mvnDeps = Seq(
    mvn"org.thymeleaf:thymeleaf:3.1.1.RELEASE",
    mvn"org.slf4j:slf4j-nop:2.0.7"
  )

  // Choose a main class to use for `.run` if there are multiple present
  def mainClass: T[Option[String]] = Some("foo.Foo2")

  // Add (or replace) source folders for the module to use
  def customSources = Task.Sources("custom-src")
  def sources = Task { super.sources() ++ customSources() }

  // Add (or replace) resource folders for the module to use
  def customResources = Task.Sources("custom-resources")
  def resources = Task { super.resources() ++ customResources() }

  // Generate sources at build time
  def generatedSources: T[Seq[PathRef]] = Task {
    for (name <- Seq("A", "B", "C")) os.write(
      Task.dest / s"Foo$name.java",
      s"""
         |package foo;
         |public class Foo$name {
         |  public static String value = "hello $name";
         |}
      """.stripMargin
    )

    Seq(PathRef(Task.dest))
  }

  // Pass additional JVM flags when `.run` is called or in the executable
  // generated by `.assembly`
  def forkArgs: T[Seq[String]] = Seq("-Dmy.custom.property=my-prop-value")

  // Pass additional environmental variables when `.run` is called. Note that
  // this does not apply to running externally via `.assembly
  def forkEnv: T[Map[String, String]] = Map("MY_CUSTOM_ENV" -> "my-env-value")
}
// If you want to better understand how the various upstream tasks feed into
// a task of interest, such as `run`, you can visualize their relationships via
/** Usage
> ./mill visualizePlan run
*/
//
// image::basic/VisualizePlanJava.svg[VisualizePlanJava.svg]
//
// (right-click open in new tab to see full sized)
//
//// SNIPPET:FATAL_WARNINGS
//
