//// SNIPPET:BUILD
package build
import mill._, javalib._

object `package` extends RootModule with JavaModule {
  // You can have arbitrary numbers of third-party dependencies
  def ivyDeps = Agg(
    ivy"org.thymeleaf:thymeleaf:3.1.1.RELEASE"
  )

  // Choose a main class to use for `.run` if there are multiple present
  def mainClass: T[Option[String]] = Some("foo.Foo2")

  // Add (or replace) source folders for the module to use
  def sources = Task.Sources{
    super.sources() ++ Seq(PathRef(millSourcePath / "custom-src"))
  }

  // Add (or replace) resource folders for the module to use
  def resources = Task.Sources{
    super.resources() ++ Seq(PathRef(millSourcePath / "custom-resources"))
  }

  // Generate sources at build time
  def generatedSources: T[Seq[PathRef]] = Task {
    for(name <- Seq("A", "B", "C")) os.write(
      Task.dest / s"Foo$name.java",
      s"""
         |package foo;
         |public class Foo$name {
         |  public static String value = "hello $name";
         |}
      """.stripMargin
    )

    Seq(PathRef(Task.dest))
  }

  // Pass additional JVM flags when `.run` is called or in the executable
  // generated by `.assembly`
  def forkArgs: T[Seq[String]] = Seq("-Dmy.custom.property=my-prop-value")

  // Pass additional environmental variables when `.run` is called. Note that
  // this does not apply to running externally via `.assembly
  def forkEnv: T[Map[String, String]] = Map("MY_CUSTOM_ENV" -> "my-env-value")
}
// If you want to better understand how the various upstream tasks feed into
// a task of interest, such as `run`, you can visualize their relationships via
/** Usage
> mill visualizePlan run
*/
//
// image::basic/VisualizePlanJava.svg[VisualizePlanJava.svg]
//
// (right-click open in new tab to see full sized)
//
//// SNIPPET:FATAL_WARNINGS
//