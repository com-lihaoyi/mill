// Mill makes it very easy to customize your build graph, overriding portions of it with custom logic.
// In this example, we override the `resources` of our `PythonModule` - normally the `resources/` folder
// - to instead contain a single generated text file containing the line count of all the source files in that module

package build
import mill._, pythonlib._

object foo extends PythonModule {

  def script: T[PathRef] = Task.Source { millSourcePath / "src" / "foo.py" }

  /** Total number of lines in module source files */
  def lineCount = Task {
    allSourceFiles().map(f => os.read.lines(f.path).size).sum
  }

  /** Generate resources using lineCount of sources */
  override def resources = Task {
    os.write(Task.dest / "line-count.txt", "" + lineCount())
    super.resources() ++ Seq(PathRef(Task.dest))
  }

  object test extends PythonTests with TestModule.Unittest
}

// The addition of `lineCount` and `resources` overrides the previous `resource` folder
// provided by `PythonModule` (labelled `resources.super` below), replacing it with the
// `destination` folder of the new `resources` task, which is wired up to `lineCount`:
//
//
// ```graphviz
// digraph G {
//  rankdir=LR;
//  node [shape=none width=0 height=0 style=filled fillcolor=white];
//  lineCount [shape=box];
//  resources [shape=box];
//  allSourceFiles -> lineCount;
//  lineCount -> resources;
//  "resources.super" -> resources;
//  resources -> "...";
//  "..." -> run;
//  }
// ```
//

/** Usage

> ./mill foo.run
Line Count: 21

> ./mill show foo.lineCount
21

> ./mill inspect foo.lineCount
...
foo.lineCount(build.mill...)
    Total number of lines in module source files
Inputs:
    foo.allSourceFiles
...

> ./mill foo.test
...
test_line_count (test.TestScript...) ... ok
...
----------------------------------------------------------------------
Ran 1 test...
OK
...

*/

// Above, def `lineCount` is a new build task we define, which makes use of `allSourceFiles`
// (an existing task) and is in-turn used in our override of `resources` (also an existing task).
// The `override` keyword is optional in Mill. This generated file can then be loaded
// and used at runtime, as see in the output of `mill run`.

// If you’re not familiar with what tasks you can `override` or how they are related,
// you can explore the existing tasks via autocomplete in your IDE, or use the
// https://mill-build.org/mill/main-branch/cli/builtin-commands.html#_visualize[mill visualize].

// `os.read.lines` and `os.write` come from the https://github.com/com-lihaoyi/os-lib[OS-Lib] library,
// which is one of Mill’s https://mill-build.org/mill/main-branch/fundamentals/bundled-libraries.html[Bundled Libraries].
// You can also import any other library you want from Maven Central using
// https://mill-build.org/mill/main-branch/extending/import-ivy-plugins.html[import $ivy],
// so you are not limited to what is bundled with Mill.

// Custom user-defined tasks in Mill benefit from all the same things that built-in tasks do: automatic caching
// (in the https://mill-build.org/mill/main-branch/fundamentals/out-dir.html[out/ folder]),
// parallelism (with the https://mill-build.org/mill/main-branch/cli/flags.html#_jobs_j[-j/--jobs flag]),
// inspectability (via https://mill-build.org/mill/main-branch/cli/builtin-commands.html#_show[show] /
// https://mill-build.org/mill/main-branch/cli/builtin-commands.html#_inspect[inspect]), and so on.
// While these things may not matter for such a simple example that runs quickly, they ensure that custom
// build logic remains performant and maintainable even as the complexity of your project grows.
