// Config-based modules can depend on programmable modules, and vice versa. This
// allows you to use simple config-based `build.mill.yaml` files for modules without any special
// requirements, use programmable `build.mill` files for modules with custom tasks or other
// more advanced customizations, and have them inter-operate with each other seamlessly.

// The example below shows a config-based module in `foo/package.mill.yaml` depending upon
// a programmable module `bar` and a programmable cross-module `qux[1]`.

//// SNIPPET:BUILD
package build
import mill.*, scalalib.*

object bar extends ScalaModule {
  def scalaVersion = "3.7.1"
  def mvnDeps = Seq(mvn"com.lihaoyi::scalatags:0.13.1")
}

object qux extends Cross[QuxModule](1, 2, 3)
trait QuxModule extends ScalaModule, Cross.Module[Int] {
  def scalaVersion = "3.7.1"
}

/** See Also: foo/package.mill.yaml */

/** Usage

> ./mill foo.run --text hello
<h1>hello</h1>

*/

//// SNIPPET:END

// The dependenies on programmable modules like `bar` and cross-modules like `qux[1]` use
// Mill's xref:cli/query-syntax.adoc[Task Query Syntax]. Note that `"qux[1]"` needs to be
// quoted to avoid being mistaken for the YAML `[]` array syntax.
