// `testParallelism` respects `testForkGrouping`, allowing you to use both features in a test module.

//// SNIPPET:BUILD1
package build
import mill._, scalalib._

object foo extends ScalaModule {
  def scalaVersion = "2.13.8"
  object test extends ScalaTests {
    def ivyDeps = Agg(mvn"com.lihaoyi::utest:0.8.5")
    def testFramework = "utest.runner.Framework"

    // Group tests by GroupX and GroupY
    def testForkGrouping =
      discoveredTestClasses().groupMapReduce(_.contains("GroupX"))(Seq(_))(_ ++ _).toSeq.sortBy(
        data => !data._1
      ).map(_._2)
    def testParallelism = true
  }
}

//// SNIPPET:END

/** Usage

> mill -j 4 foo.test

> find out/foo/test/test.dest
...
out/foo/test/test.dest/group-0-foo.GroupX1/worker-...
out/foo/test/test.dest/group-0-foo.GroupX1/test-classes
out/foo/test/test.dest/group-1-foo.GroupY1/worker-...
out/foo/test/test.dest/group-1-foo.GroupY1/test-classes
out/foo/test/test.dest/test-report.xml
...

*/

// This example sets `testForkGrouping` to group test classes into two categories: `GroupX` and `GroupY`.
// Additionally, `testParallelism` is enabled.
// Mill ensures each subprocess exclusively claims and runs tests from either `GroupX` or `GroupY`, preventing them from mixing.
// Test classes from `GroupX` and `GroupY` will never share the same test runner.
//
// This is useful when you have incompatible tests that cannot run within the same JVM.
// Test Grouping combined with Test Parallel Scheduler maintains their isolation while maximizing performance through parallel test execution.
