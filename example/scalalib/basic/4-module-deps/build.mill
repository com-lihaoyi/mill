// This example contains a simple Mill build with two modules, `foo` and `bar`,
// defined by their respective `foo/package.mill.yaml` and `bar/package.mill.yaml` config
// files, and on which you can run tasks on such as `foo.run` or
// `bar.run`. There is also a `bar.test` module defined by `bar/test/package.mill.yaml`.

/** See Also: foo/package.mill.yaml */
/** See Also: bar/package.mill.yaml */
/** See Also: bar/test/package.mill.yaml */

// Inter-module dependencies are defined by the `moduleDeps` key, and modules
// can also be nested within each other, as `bar.test` is nested
// within `bar`.
//
// ==== Multi-Module Folder Layout
//
// The above builds expect the following project layout:
//
//// SNIPPET:TREE
//
// ----
// build.mill
// foo/
//     src/
//         Foo.scala
// bar/
//     src/
//         Bar.scala
//     test/
//         src/
//             BarTests.scala
// out/
//     foo/
//         compile.json
//         compile.dest/
//         ...
//     bar/
//         compile.json
//         compile.dest/
//         ...
//         test/
//             compile.json
//             compile.dest/
//             ...
// ----
//
//// SNIPPET:END

// Typically, source, output files, and task names in Mill follow the module
// hierarchy, so e.g. input to the `foo` module lives in `foo/src/` and
// compiled output files live in `out/foo/compile.dest`, and that module is
// run via `foo.run`.
//
// You can use `mill resolve` to list out what tasks you can run, e.g.
// `mill resolve __.run` below which lists out all the `run` tasks:

/** Usage

> ./mill resolve __.run
foo.run
bar.run

> ./mill foo.run --text "hello-world"
<h1>hello-world</h1>

> ./mill bar.test
...
...bar.BarTests...simple...
...bar.BarTests...escaping...

*/

// In general, for multi-module builds, every task is prefixed by its module
// name: `foo.run`, `bar.assembly`, `bar.test.compile`, etc.
// Mill will ensure that the specified tasks and their upstream dependencies are
// executed in the right order, and re-executed as necessary when source code
// in each module changes.
//
// ==== Task Query Syntax
//
// You can use wildcards and brace-expansion to select
// multiple tasks at once or to shorten the path to deeply nested tasks. If
// you provide optional task arguments and your wildcard or brace-expansion is
// resolved to multiple tasks, the arguments will be applied to each of the
// tasks.
//
// .Wildcards and brace-expansion
// |==========================================================
// | Wildcard | Function
// | `_`      | matches a single segment of the task path
// | `__`     | matches arbitrary segments of the task path
// | `{a,b}`  | is equal to specifying two tasks `a` and `b`
// |==========================================================
//
//
// You can use the + symbol to add another task with optional arguments.
// If you need to feed a + as argument to your task, you can mask it by
// preceding it with a backslash (`\`).
//

/** Usage
> ./mill bar._.compile # Runs `compile` for all direct sub-modules of `foo`

> ./mill bar.__.test # Runs `test` for all transitive sub-modules of `foo`

> ./mill {foo,bar}.compile # Runs `compile` for `foo` and `bar`

> ./mill __.compile + bar.__.test # Runs all `compile` tasks and all tests under `foo`.
*/

// For more details on the query syntax, check out the
// xref:cli/query-syntax.adoc[query syntax documentation]
