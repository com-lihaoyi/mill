//// SNIPPET:BUILD
package build
import mill.*, scalalib.*

trait MyModule extends ScalaModule {
  def scalaVersion = "3.7.1"
  object test extends ScalaTests {
    def mvnDeps = Seq(mvn"com.lihaoyi::utest:0.8.9")
    def testFramework = "utest.runner.Framework"
  }
}

object foo extends MyModule {
  def moduleDeps = Seq(bar)
  def mvnDeps = Seq(mvn"com.lihaoyi::mainargs:0.7.6")
}

object bar extends MyModule {
  def mvnDeps = Seq(mvn"com.lihaoyi::scalatags:0.13.1")
}
//// SNIPPET:END

// This is similar to the xref:#_multiple_scala_modules example above, but using Mill's
// programmatic configuration syntax. You can define multiple modules the same way you
// define a single module, using `def moduleDeps` to define the relationship between them.
// Modules can also be nested within each other, as `foo.test` and `bar.test` are nested
// within `foo` and `bar` respectively
//
// Note that we split out the `test` submodule configuration common to both
// modules into a separate `trait MyModule`. This xref:fundamentals/modules.adoc[Trait Module]
// works like a `class` in Java, and lets us avoid the need to copy-paste common
// settings, while still letting us define any per-module configuration such as
// `mvnDeps` specific to a particular module. This is a common pattern within Mill builds.
//

//// SNIPPET:TEST
/** Usage

> ./mill bar.test
+ bar.BarTests.simple...
+ bar.BarTests.escaping...
*/
//// SNIPPET:END
/** Usage
> ./mill foo.run --foo-text hello --bar-text world
Foo.value: hello
Bar.value: <h1>world</h1>

*/


//
// You can also put the configuration for each submodule in it's respective
// folder's `package.mill` file, as described in xref:large/multi-file-builds.adoc[].
// This can be helpful in larger projects to avoid having your `build.mill` grow
// large, and aid in discoverability by keeping the build configuration for each
// module close to the code it is configuring
//
