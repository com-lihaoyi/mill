// Mill uses MainArgs to handle argument parsing for ``Task.Command``s that
// are run from the command line.
import mill._

def commandSimple(str: String, i: Int, bool: Boolean = true) = Task.Command{
  println(s"$str $i $bool")
}

// Mill uses MainArgs to let you parse most common Scala primitive types as command
// parameters: `String`s, `Int`s, `Boolean`s, etc. Single-character parameter names
// are treated as short arguments called with one dash `-` rather than two dashes `--`.
// Default values work as you would expect, and are substituted in if a value is not
// given at the command line

/** Usage

> ./mill commandSimple --str hello -i 123
hello 123 true

*/


// === `os.Path`
//
// In addition to the builtin set of types that MainArgs supports, Mill also
// supports parsing OS-Lib ``os.Path``s from the command line:


def commandTakingPath(path: os.Path) = Task.Command{
  println(path)
}

/** Usage

> ./mill commandTakingPath --path foo/bar/baz.txt
...foo/bar/baz.txt

*/

// === `Task`
//
// Mill allows commands to take ``Task[T]``s as parameters anywhere they can
// take an unboxed `T`. This can be handy later on if you want to call the
// command as part of another task, while passing it the value of an upstream
// task:

def commandTakingTask(str: Task[String]) = Task.Command{
  val result = "arg: " + str()
  println(result)
  result
}

/** Usage

> ./mill commandTakingTask --str helloworld
arg: helloworld

*/

def upstreamTask = Task {
  "HELLO"
}

def taskCallingCommand = Task {
  commandTakingTask(upstreamTask)()
}


/** Usage

> ./mill show taskCallingCommand
"arg: HELLO"

*/


// === Evaluator (experimental)
//
// _Evaluator Command are experimental and suspected to change.
// See {mill-github-url}/issues/502[issue #502] for details._
//
// You can define a command that takes in the current `Evaluator` as an argument,
// which you can use to inspect the entire build, or run arbitrary tasks.
// For example, here is a `customPlanCommand` command which uses this
// to traverse the module tree to find the tasks specified by the `tasks` strings,
// and plan out what would be necessary to run them
import mill.eval.{Evaluator, Terminal}
import mill.resolve.{Resolve, SelectMode}

def customPlanCommand(evaluator: Evaluator, tasks: String*) = Task.Command {
  Resolve.Tasks.resolve(
    evaluator.rootModule,
    tasks,
    SelectMode.Multi
  ) match{
    case Left(err) => Left(err)
    case Right(resolved) =>
      val (sortedGroups, _) = evaluator.plan(resolved)
      val plan = sortedGroups
        .keys()
        .collect { case r: Terminal.Labelled[_] => r.render }
        .toArray

      plan.foreach(println)
      Right(())
  }
}

// We can call our `customPlanCommand` from the command line and pass it the
// `taskCallingCommand` we saw earlier, and it prints out the list of tasks
// it needs to run in the order necessary to reach `taskCallingCommand

/** Usage

> ./mill customPlanCommand taskCallingCommand
upstreamTask
commandTakingTask
taskCallingCommand

*/

// Many built-in tools are implemented as custom evaluator commands:
// xref:scalalib/builtin-commands.adoc#_inspect[inspect],
// xref:scalalib/builtin-commands.adoc#_resolve[resolve],
// xref:scalalib/builtin-commands.adoc#_show[show].
// If you want a way to run Mill commands and programmatically manipulate the
// tasks and outputs, you do so with your own evaluator command.
