// You can define anonymous tasks using the `Task.Anon {...}` syntax. These are
// not runnable from the command-line, but can be used to share common code you
// find yourself repeating in ``Task``s and ``Command``s.

package build
import mill.*

def data = Task.Source("data")

def anonTask(fileName: String): Task[String] = Task.Anon {
  os.read(data().path / fileName)
}

def helloFileData = Task { anonTask("hello.txt")() }
def printFileData(fileName: String) = Task.Command {
  println(anonTask(fileName)())
}

//
// Anonymous task's output does not need to be JSON-serializable, their output is
// not cached, and they can be defined with or without arguments.
// Unlike <<_tasks>> or <<_commands>>, anonymous tasks can be defined
// anywhere and passed around any way you want, until you finally make use of them
// within a downstream task or command.
//
// Anonymous tasks work well when parameters are known at task definition time. Dynamically
// generated inputs can not be used with Anonymous Tasks, since mill wouldn't be able to build
// the dependency tree. We need to know the parameters before creating the task, but the tasks
// need to be created before we can start evaluation, we have a classic hen-or-egg problem.
// Common strategies around this are:
// 1. Define the values outside of a task, so Mill knows how to create the anonymous
// tasks before evaluation starts.
// 2. Put the value itself into a task, so it can be properly ordered to be evaluated
// before it's dependencies.
// 3. Make it not a task but a normal def
//
// While an anonymous task ``foo``'s own output is not cached, if it is used in a
// downstream task `baz` and the upstream task `bar` hasn't changed,
// ``baz``'s cached output will be used and ``foo``'s evaluation will be skipped
// altogether.

/** Usage

> ./mill show helloFileData
"Hello"

> ./mill printFileData --file-name hello.txt
Hello

> ./mill printFileData --file-name world.txt
World!

*/
