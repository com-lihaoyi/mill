// Mill comes with a number of useful commands out of the box. These are listed
// in the API Docs:
//
// * {mill-doc-url}/api/latest/mill/main/MainModule.html[mill.main.MainModule]
//
// Mill's built-in commands are typically not directly related to building your
// application code, but instead are utilities that help you understand and work
// with your Mill build.
//
// The following examples will be assuming the `build.mill` file given below:

package build
import mill._, javalib._

trait MyModule extends JavaModule {
  object test extends JavaTests with TestModule.Junit4
}

object foo extends MyModule {
  def moduleDeps = Seq(bar)
  def ivyDeps = Seq(
    ivy"net.sourceforge.argparse4j:argparse4j:0.9.0"
  )
}

object bar extends MyModule {
  def ivyDeps = Seq(
    ivy"net.sourceforge.argparse4j:argparse4j:0.9.0",
    ivy"org.thymeleaf:thymeleaf:3.1.1.RELEASE"
  )
}
// == resolve

// `resolve` lists the tasks that match a particular query, without running them.
// This is useful for "dry running" an `mill` command to see what would be run
// before you run them, or to explore what modules or tasks are available
// from the command line using `+resolve _+`, `+resolve foo._+`, etc.

// == visualize
//
/** Usage
> mill visualize foo._
[
  ".../out/visualize.dest/out.dot",
  ".../out/visualize.dest/out.json",
  ".../out/visualize.dest/out.png",
  ".../out/visualize.dest/out.svg",
  ".../out/visualize.dest/out.txt"
]
*/
//
// `mill visualize` takes a subset of the Mill build graph (e.g. `+core._+`
// is every task directly under the `core` module) and draws out their
// relationships in `.svg` and `.png` form for you to inspect. It also generates
// `.txt`, `.dot` and `.json` for easy processing by downstream tools.
//
// `visualize` can be very handy for trying to understand the dependency graph of
// tasks within your Mill build: who depends on what? Who do I need to override to affect
// a particular task? Which tasks depend on another and need to run sequentially, and which
// do not and can be run in parallel?
//
// The above command visualizes all the tasks within the `foo` module, and
// generates the following diagram to show you how they are related to one another
// (right-click open in new tab to see full sized):
//
// image::basic/VisualizeJava.svg[VisualizeJava.svg]
//
// The above example shows the outcome of using `visualize` on multiple tasks within a single
// module, but you can also use `visualize` on a single task in multiple modules to see how they are related:
//
/** Usage
> mill visualize __.compile

> cat out/visualize.dest/out.dot
digraph "example1" {
graph ["rankdir"="LR"]
"bar.compile" ["style"="solid","shape"="box"]
"bar.test.compile" ["style"="solid","shape"="box"]
"foo.compile" ["style"="solid","shape"="box"]
"foo.test.compile" ["style"="solid","shape"="box"]
"bar.compile" -> "foo.compile"
"bar.compile" -> "bar.test.compile"
"foo.compile" -> "foo.test.compile"
}
*/

// image::basic/VisualizeCompiles.svg[VisualizeCompiles.svg]
//
// NOTE: `visualize` does a https://en.wikipedia.org/wiki/Transitive_reduction[Transitive Reduction]
// of the graph when rendering it. This removes redundant edges and simplifies the graph
// so it's easier to visualize while preserving the overall structure of the graph, but
// it does mean that there will be some duplicate edges that are not shown.
//
// == visualizePlan
//
/** Usage
> mill visualizePlan foo.run
[
  ".../out/visualizePlan.dest/out.dot",
  ".../out/visualizePlan.dest/out.json",
  ".../out/visualizePlan.dest/out.png",
  ".../out/visualizePlan.dest/out.svg",
  ".../out/visualizePlan.dest/out.txt"
]
*/
//
// `mill visualizePlan` is similar to `mill visualize` except that it
// shows a graph of the entire build plan, including tasks not directly resolved
// by the query. Tasks directly resolved are shown with a solid border, and
// dependencies are shown with a dotted border.
//
// The above command generates the following diagram (right-click open in new tab to see full sized):
//
// image::basic/VisualizePlanJava.svg[VisualizePlanJava.svg]
//
//
// == init

/** Usage
> mill init
Run `mill init <example-id>` with one of these examples as an argument to download and extract example.
Run `mill init --show-all` to see full list of examples.
Run `mill init <Giter8 template>` to generate project from Giter8 template.
...
scalalib/basic/1-simple
...
scalalib/web/1-todo-webapp
scalalib/web/2-webapp-cache-busting
scalalib/web/3-todo-http4s
scalalib/web/4-scalajs-module
scalalib/web/5-webapp-scalajs
scalalib/web/6-webapp-scalajs-shared
...
javalib/basic/1-simple
...
javalib/basic/6-realistic
...
javalib/web/1-hello-jetty
javalib/web/2-hello-spring-boot
javalib/web/3-todo-spring-boot
javalib/web/4-hello-micronaut
javalib/web/5-todo-micronaut
kotlinlib/basic/1-simple
...
kotlinlib/basic/6-realistic
...
kotlinlib/web/1-hello-ktor
*/

// The `init` command generates a project based on a Mill example project or
// a Giter8 template. You can use it to quickly generate a starter project.
// There are lots of templates out there for many frameworks and tools!
//
// The typical usage of `init` is to download a
// xref:cli/installation-ide.adoc#_bootstrap_scripts[bootstrap script]
// into an empty folder and run `./mill init` to download and unpack one of the example
// projects closest to what you want into the empty folder. Even though the example
// project isn't going to be everything that you need, at least it'll get most of the
// tedious boilerplate set up, so you can hit the group running working on the things
// that are unique to your particular project..
//
// `init` can also be used to initialize a Mill build configuration based on
// an existing Maven or Gradle build. See the linked page for more details:
//
// * xref:migrating/maven.adoc[]
// * xref:migrating/gradle.adoc[]
//
// == selective.*
//
// Mill comes with builtin `selective.*` commands to work with Selective Test Execution.
// See the linked page for more details:
//
// * xref:large/selective-execution.adoc[]
//
// == shutdown
//
// `./mill shutdown` is used to shut down the background daemon that Mill uses to keep
// the build code performant. Without calling `shutdown`, the background daemon will
// automatically shut itself down after 30 minutes of inactivity.

// == version
//
// `./mill version` prints the current Mill version
