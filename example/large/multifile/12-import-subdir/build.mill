// Mill supports nested `build.mill` files in subdirectories. Unlike `package.mill` files
// which must use package declarations matching their directory path (e.g., `package build.deps.foo`),
// nested `build.mill` files can use a simple `package build` declaration regardless of where
// they are located.
//
// This makes it easy to:
//
// * Keep module definitions self-contained in subdirectories that can be built independently
// * Refactor or move modules around without updating package declarations
//
// === Example Project
// The `FooModule` trait is defined in the nested `deps/foo/build.mill` file, and we can reference it
// using the hierarchical path `build_.deps.foo.FooModule`
package build

import mill.*, scalalib.*

/** Reference FooModule from the nested build.mill file */
trait BarModule extends build_.deps.foo.FooModule

/** See Also: deps/package.mill */

/** See Also: deps/foo/build.mill */

/** See Also: deps/foo/versions.mill */

//
// In this example:
//
// * The root `build.mill` uses `package build` and defines a `BarModule` trait
// * `deps/package.mill` uses `package build.deps` to create the intermediate namespace
// * `deps/foo/build.mill` also uses `package build` instead of needing `package build.deps.foo`
// * `deps/foo/versions.mill` is a helper file that provides shared configuration
//
// The nested `deps/foo/build.mill` file defines a `FooModule` trait that can be referenced
// from the root build file as `build_.deps.foo.FooModule`. Note the use of `build_` to
// reference the generated build package object.
//
// Helper files like `versions.mill` work alongside nested `build.mill` files and can be
// referenced using the hierarchical path (e.g., `build.foo.scalaVersion`).

/** Usage

> ./mill show deps.foo.scalaVersion
"2.13.16"

*/

// Each nested `build.mill` can use the simple `package build` declaration while still being
// accessible through its full hierarchical path from parent build files.
