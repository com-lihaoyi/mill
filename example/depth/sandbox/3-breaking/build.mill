// Mill's sandboxing approach is best effort: while it tries to guide you into using
// isolated sandbox folders, Mill cannot guarantee it, and in fact provides the
// `MILL_WORKSPACE_ROOT` environment variable to reference the project root folder
// for scenarios where you may need it. This can be useful for a variety of reasons:
//
// * Migrating legacy applications that assume access to the workspace root
// * Scenarios where writing the the original source repository is necessary:
//   code auto-formatters, auto-fixers, auto-updaters. etc.
//
// `MILL_WORKSPACE_ROOT` can be used both in tasks:
package build
import mill._, javalib._

def tWorkspaceTask = T { println(os.Path(sys.env("MILL_WORKSPACE_ROOT"))) }

/** Usage
> ./mill tWorkspaceTask
*/

// `MILL_WORKSPACE_ROOT` as well as in tests:

object foo extends JavaModule{
  object test extends JavaTests with TestModule.Junit4
}

/** See Also: foo/src/foo/Foo.java */
/** See Also: foo/test/src/foo/FooTests.java */

// Test suites can access the workspace root via the `MILL_WORKSPACE_ROOT`
// environment variable:

/** Usage
> ./mill __.test
*/

/** Usage

> find . | grep .html
...
.../out/foo/test/test.dest/sandbox/modules.html
.../out/foo/test/test.dest/sandbox/foo.html

> cat out/foo/test/test.dest/sandbox/foo.html
<h1>foo</h1>

*/
