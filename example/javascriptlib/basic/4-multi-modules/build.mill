package build
import mill._

trait TypeScriptModule extends Module {
  def moduleDeps: Seq[TypeScriptModule] = Nil
  def npmDevDeps: T[Seq[String]] = Task { Seq.empty[String] }

  def npmInstall: T[PathRef] = Task.Anon {
    os.call((
      "npm",
      "install",
      "--save-dev",
      "@types/node@^20.0.0",
      "ts-node@^10.9.2",
      "typescript@^5.0.0",
      npmDevDeps()
    ))
    PathRef(Task.dest)
  }

  def sources = Task.Source(millSourcePath / "src")
  def tests = Task.Source(millSourcePath / "test")
  val testConfigPath = millSourcePath / os.up / "jest.config.ts"

  def sourceForTask = Task.Anon {
    val destination = T.dest.toString()
    val destSource = destination match {
      case x if !x.contains("test") => os.walk(sources().path).filter(_.ext == "ts").map(PathRef(_))
      case _ => (os.walk(sources().path) ++ os.walk(tests().path) ++ IndexedSeq(
          testConfigPath
        )).filter(_.ext == "ts").map(PathRef(_))
    }

    destSource
  }

  def tsConfig = Task.Anon {
    val nodeTypes = npmInstall().path / "node_modules/@types"
    val javascriptOut = Task.dest / "javascript"
    val declarationsOut = Task.dest / "declarations"

    val upstreamPaths =
      for (((jsDir, dTsDir), mod) <- Task.traverse(moduleDeps)(_.compile)().zip(moduleDeps))
        yield (mod.millSourcePath.subRelativeTo(build.millSourcePath) + "/*", dTsDir.path)

    val allPaths = upstreamPaths ++ Seq("*" -> sources().path, "*" -> npmInstall().path)
    os.write(
      Task.dest / "tsconfig.json",
      ujson.Obj(
        "compilerOptions" -> ujson.Obj(
          "outDir" -> javascriptOut.toString,
          "declaration" -> true,
          "declarationDir" -> declarationsOut.toString,
          "typeRoots" -> ujson.Arr(nodeTypes.toString),
          "paths" -> ujson.Obj.from(allPaths.map { case (k, v) => (k, ujson.Arr(s"$v/*")) })
        ),
        "files" -> sourceForTask().map(_.path.toString)
      )
    )
  }

  def compile: T[(PathRef, PathRef)] = Task {
    tsConfig()
    os.call(npmInstall().path / "node_modules/typescript/bin/tsc")
    val javascriptOut = T.dest / "javascript"
    val declarationsOut = T.dest / "declarations"
    (PathRef(javascriptOut), PathRef(declarationsOut))
  }

  def test = Task { os.call(("echo", "nothing to see here"), stdout = os.Inherit) }
}

object authors extends TypeScriptModule

object books extends TypeScriptModule {
  def moduleDeps = Seq(authors)
}

object library extends TypeScriptModule {
  def moduleDeps = Seq(authors, books)

  def npmDevDeps = Seq(
    "@types/jest@^29.0.0",
    "jest@^29.0.0",
    "ts-jest@^29.0.0"
  )

  override def test = Task {
    tsConfig()
    os.call(npmInstall().path / "node_modules/typescript/bin/tsc")
    val javascriptOut = Task.dest / "javascript"

    // env
    // note: ' npmInstall().path / "node_modules" ' required in NODE_PATH for jest to find preset: ts-jest
    val env = Map("NODE_PATH" -> Seq(
      ".",
      javascriptOut,
      npmInstall().path,
      npmInstall().path / "node_modules"
    ).mkString(":"))

    os.call(
      ("node", npmInstall().path / "node_modules/jest/bin/jest.js", javascriptOut.toString()),
      stdout = os.Inherit,
      env = env
    )
  }

  // intialize a data source
  def resources = Task {
    val mockAuthors = ujson.Arr(
      ujson.Obj("id" -> 1, "name" -> "Author One"),
      ujson.Obj("id" -> 2, "name" -> "Author Two")
    )

    val mockBooks = ujson.Arr(
      ujson.Obj(
        "id" -> 1,
        "title" -> "Book One",
        "publication" -> 2001,
        "sn" -> "SN001",
        "author" -> ujson.Obj("id" -> 1)
      ),
      ujson.Obj(
        "id" -> 2,
        "title" -> "Book Two",
        "publication" -> 2002,
        "sn" -> "SN002",
        "author" -> ujson.Obj("id" -> 1)
      ),
      ujson.Obj(
        "id" -> 3,
        "title" -> "Book Three",
        "publication" -> 2003,
        "sn" -> "SN003",
        "author" -> ujson.Obj("id" -> 2)
      )
    )

    os.write(Task.dest / "authors.json", ujson.write(mockAuthors, indent = 2))
    os.write(Task.dest / "books.json", ujson.write(mockBooks, indent = 2))
    PathRef(Task.dest)
  }

  def prepareRun = Task.Anon {
    val upstream = Task.traverse(moduleDeps)(_.compile)().zip(moduleDeps)
    for (((jsDir, tTsDir), mod) <- upstream) {
      os.copy(jsDir.path, Task.dest / mod.millSourcePath.subRelativeTo(build.millSourcePath))
    }
    val mainFile = compile()._1.path / "index.js"
    val pathToResources = resources().path
    val env = Map("NODE_PATH" -> Seq(".", compile()._1.path, npmInstall().path).mkString(":"))
    (mainFile, pathToResources, env)
  }

  def run(args: mill.define.Args) = Task.Command {
    val (mainFile, pathToResources, env) = prepareRun()
    os.call(
      ("node", mainFile, pathToResources.toString(), args.value),
      stdout = os.Inherit,
      env = env
    )
  }
}
