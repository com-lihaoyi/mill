diff --git a/.github/workflows/run-tests.yml b/.github/workflows/run-tests.yml
index 7afdd53994b..5ec15bb6b0a 100644
--- a/.github/workflows/run-tests.yml
+++ b/.github/workflows/run-tests.yml
@@ -263,7 +263,7 @@ jobs:
             millargs: "'integration.invalidation.__.native.server'"
             install-sbt: false
 
-          - java-version: 17.0.14
+          - java-version: 17
             millargs: "'integration.bootstrap[no-java-bootstrap].native.server'"
 
     uses: ./.github/workflows/post-build-selective.yml
diff --git a/dist/package.mill b/dist/package.mill
index e93db5bd1d0..52954600e2b 100644
--- a/dist/package.mill
+++ b/dist/package.mill
@@ -343,87 +343,10 @@ object `package` extends RootModule with InstallModule {
 
     def nativeImageOptions = Seq("--no-fallback", "--enable-url-protocols=https", "-Os")
 
-    // copying the original method from NativeImageModule until re-bootstrapping
-    // for the withRevalidateOnce and the GraalVM copy stuff
-    def nativeImageTool: T[PathRef] = Task {
-      jvmWorker().javaHome().map(_.path)
-        .orElse(sys.env.get("GRAALVM_HOME").map(os.Path(_))) match {
-        case Some(home) =>
-          val tool = if (Properties.isWin) "native-image.cmd" else "native-image"
-          val actualHome = maybeCopiedGraalVmHome(home, checkExists = true) match {
-            case Some(home0) =>
-              System.err.println(s"Using $home0 as GraalVM")
-              home0
-            case None =>
-              home
-          }
-          val path = actualHome / "bin" / tool
-          if (os.exists(path))
-            // native-image is externally managed, better revalidate it at least once
-            PathRef(path).withRevalidateOnce
-          else throw new RuntimeException(s"$path not found")
-        case None =>
-          throw new RuntimeException("JvmWorkerModule.javaHome/GRAALVM_HOME not defined")
-      }
-    }
-
     def jvmWorker = ModuleRef(JvmWorkerGraalvm)
 
-    def nativeImageGraalVmCopyBase: Option[os.Path] =
-      if (Properties.isWin && System.getenv("CI") != null)
-        Some(os.Path("C:/jvms"))
-      else
-        None
-
-    private def maybeCopiedGraalVmHome(
-        home: os.Path,
-        checkExists: Boolean = false
-    ): Option[os.Path] =
-      nativeImageGraalVmCopyBase
-        .map { base =>
-          import java.math.BigInteger
-          import java.security.MessageDigest
-          val sha1 = {
-            val bytes = MessageDigest.getInstance("SHA-1").digest(home.toString.getBytes)
-            val baseSha1 = new BigInteger(1, bytes).toString(16)
-            "0" * (40 - baseSha1.length) + baseSha1
-          }
-          base / sha1.take(8)
-        }
-        .filter(dir => !checkExists || os.exists(dir))
-
-    def nativeImageMaybeCopyGraal(): Command[Unit] =
-      if (nativeImageGraalVmCopyBase.isEmpty)
-        Task.Command {}
-      else
-        Task.Command {
-          val originalHome = jvmWorker().javaHome().map(_.path).getOrElse {
-            sys.error("No JVM defined via jvmWorker")
-          }
-          for (dest <- maybeCopiedGraalVmHome(originalHome))
-            if (os.exists(dest))
-              System.err.println(s"$dest already exists")
-            else {
-              System.err.println(s"Copying $originalHome to $dest")
-              os.copy(originalHome, dest, createFolders = true)
-            }
-        }
-
     object JvmWorkerGraalvm extends JvmWorkerModule {
       def jvmId = build.Settings.graalvmJvmId
-      // copying the original method from NativeImageModule until re-bootstrapping
-      // for the withRevalidateOnce
-      def javaHome: T[Option[PathRef]] = Task {
-        Option(jvmId()).filter(_ != "").map { id =>
-          val path = mill.util.Jvm.resolveJavaHome(
-            id = id,
-            coursierCacheCustomizer = coursierCacheCustomizer(),
-            ctx = Some(implicitly[mill.api.Ctx.Log]),
-            jvmIndexVersion = jvmIndexVersion()
-          ).get
-          PathRef(path, quick = true).withRevalidateOnce
-        }
-      }
     }
   }
 }
diff --git a/mill-build/build.mill b/mill-build/build.mill
index 521b6533dd6..1c8b6ff79ea 100644
--- a/mill-build/build.mill
+++ b/mill-build/build.mill
@@ -1,5 +1,5 @@
 import mill._
-import mill.runner.MillBuildRootModule
+import mill.runner.meta.MillBuildRootModule
 import mill.scalalib._
 
 object `package` extends MillBuildRootModule {
diff --git a/website/package.mill b/website/package.mill
index c30c14440e4..f3e6aa41ed3 100644
--- a/website/package.mill
+++ b/website/package.mill
@@ -57,7 +57,7 @@ object `package` extends RootModule {
   }
 
   def runAntora(npmDir: os.Path, workDir: os.Path, args: Seq[String])(implicit
-      ctx: mill.api.Ctx.Log
+      ctx: mill.define.TaskCtx.Log
   ) = {
 
     prepareAntora(npmDir)
@@ -116,7 +116,7 @@ object `package` extends RootModule {
   }
 
   def expandDiagramsInDirectoryAdocFile(dest: os.Path, visualizeClassPath: Agg[os.Path])(implicit
-      ctx: mill.api.Ctx
+      ctx: mill.define.TaskCtx
   ) = {
 
     // Walk all files to render graphviz templates ourselves because the only Antora graphviz
