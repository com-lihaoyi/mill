diff --git a/build.sc b/build.sc
index 0ea67137d2..d6b79da5b4 100644
--- a/build.sc
+++ b/build.sc
@@ -25,8 +25,10 @@ import mill.main.MainModule
 import mill.scalalib._
 import mill.scalalib.publish._
 import mill.modules.Jvm
-import mill.define.SelectMode
-
+import mill.main.SelectMode
+import $ivy.`com.lihaoyi::mill-contrib-buildinfo:`
+import mill.contrib.buildinfo.BuildInfo
+import mill.scalalib.api.Versions
 import scala.util.control.NonFatal
 import mill.T
 import mill.define.{Discover, ExternalModule, Input, Module, Task}
@@ -163,12 +165,8 @@ object Deps {
   val requests = ivy"com.lihaoyi::requests:0.8.0"
 }
 
-def millVersion: T[String] = T { VcsVersion.vcsState().format() }
-def millLastTag: T[String] = T {
-  VcsVersion.vcsState().lastTag.getOrElse(
-    sys.error("No (last) git tag found. Your git history seems incomplete!")
-  )
-}
+def millVersion: T[String] = T { "0.0.0.test" }
+def millLastTag: T[String] = T { "0.0.0.test" }
 def millBinPlatform: T[String] = T {
   val tag = millLastTag()
   if (tag.contains("-M")) tag
@@ -217,8 +215,8 @@ val buildBridgeScalaVersions =
   if (!buildAllCompilerBridges) Seq()
   else bridgeScalaVersions
 
-object bridge extends Cross[BridgeModule](buildBridgeScalaVersions: _*)
-class BridgeModule(val crossScalaVersion: String) extends PublishModule with CrossScalaModule {
+object bridge extends Cross[BridgeModule](buildBridgeScalaVersions)
+trait BridgeModule extends PublishModule with CrossScalaModule {
   def scalaVersion = crossScalaVersion
   def publishVersion = bridgeVersion
   def artifactName = T { "mill-scala-compiler-bridge" }
@@ -237,239 +235,25 @@ class BridgeModule(val crossScalaVersion: String) extends PublishModule with Cro
   def generatedSources = T {
     import mill.scalalib.api.ZincWorkerUtil.{grepJar, scalaBinaryVersion}
     val resolvedJars = resolveDeps(
-      T.task { Agg(ivy"org.scala-sbt::compiler-bridge:${Deps.zinc.dep.version}") },
+      T.task {
+        Agg(ivy"org.scala-sbt::compiler-bridge:${Deps.zinc.dep.version}").map(bindDependency())
+      },
       sources = true
     )()
 
     val bridgeJar = grepJar(
-      resolvedJars.map(_.path),
+      resolvedJars,
       s"compiler-bridge_${scalaBinaryVersion(scalaVersion())}",
       Deps.zinc.dep.version,
       true
     )
 
-    mill.api.IO.unpackZip(bridgeJar, os.rel)
+    mill.api.IO.unpackZip(bridgeJar.path, os.rel)
 
     Seq(PathRef(T.dest))
   }
 }
 
-trait BuildInfo extends JavaModule {
-
-  /**
-   * The package name under which the BuildInfo data object will be stored.
-   */
-  def buildInfoPackageName: String
-
-  /**
-   * The name of the BuildInfo data object, defaults to "BuildInfo"
-   */
-  def buildInfoObjectName: String = "BuildInfo"
-
-  /**
-   * Enable to compile the BuildInfo values directly into the classfiles,
-   * rather than the default behavior of storing them as a JVM resource. Needed
-   * to use BuildInfo on Scala.js which does not support JVM resources
-   */
-  def buildInfoStaticCompiled: Boolean = false
-
-  /**
-   * A mapping of key-value pairs to pass from the Build script to the
-   * application code at runtime.
-   */
-  def buildInfoMembers: T[Seq[BuildInfo.Value]] = Seq.empty[BuildInfo.Value]
-
-  def resources =
-    if (buildInfoStaticCompiled) super.resources
-    else T.sources { super.resources() ++ Seq(buildInfoResources()) }
-
-  def buildInfoResources = T {
-    val p = new java.util.Properties
-    for (v <- buildInfoMembers()) p.setProperty(v.key, v.value)
-
-    val stream = os.write.outputStream(
-      T.dest / os.SubPath(
-        buildInfoPackageName.replace('.', '/')
-      ) / s"$buildInfoObjectName.buildinfo.properties",
-      createFolders = true
-    )
-
-    p.store(
-      stream,
-      s"mill.contrib.buildinfo.BuildInfo for ${buildInfoPackageName}.${buildInfoObjectName}"
-    )
-    stream.close()
-    PathRef(T.dest)
-  }
-
-  private def isScala = this.isInstanceOf[ScalaModule]
-
-  override def generatedSources = T {
-    super.generatedSources() ++ buildInfoSources()
-  }
-
-  def buildInfoSources = T {
-    if (buildInfoMembers().isEmpty) Nil
-    else {
-      val code = if (buildInfoStaticCompiled) BuildInfo.staticCompiledCodegen(
-        buildInfoMembers(),
-        isScala,
-        buildInfoPackageName,
-        buildInfoObjectName
-      )
-      else BuildInfo.codegen(
-        buildInfoMembers(),
-        isScala,
-        buildInfoPackageName,
-        buildInfoObjectName
-      )
-
-      val ext = if (isScala) "scala" else "java"
-
-      os.write(
-        T.dest / buildInfoPackageName.split('.') / s"${buildInfoObjectName}.$ext",
-        code,
-        createFolders = true
-      )
-      Seq(PathRef(T.dest))
-    }
-  }
-}
-
-object BuildInfo {
-  case class Value(key: String, value: String, comment: String = "")
-  object Value {
-    implicit val rw: upickle.default.ReadWriter[Value] = upickle.default.macroRW
-  }
-  def staticCompiledCodegen(
-      buildInfoMembers: Seq[Value],
-      isScala: Boolean,
-      buildInfoPackageName: String,
-      buildInfoObjectName: String
-  ): String = {
-    val bindingsCode = buildInfoMembers
-      .sortBy(_.key)
-      .map {
-        case v =>
-          if (isScala) s"""${commentStr(v)}val ${v.key} = ${pprint.Util.literalize(v.value)}"""
-          else s"""${commentStr(
-              v
-            )}public static java.lang.String ${v.key} = ${pprint.Util.literalize(v.value)};"""
-      }
-      .mkString("\n\n  ")
-
-    if (isScala) {
-      val mapEntries = buildInfoMembers
-        .map { case v => s""""${v.key}" -> ${v.key}""" }
-        .mkString(",\n")
-
-      s"""
-         |package $buildInfoPackageName
-         |
-         |object $buildInfoObjectName {
-         |  $bindingsCode
-         |  val toMap = Map[String, String](
-         |    $mapEntries
-         |  )
-         |}
-      """.stripMargin.trim
-    } else {
-      val mapEntries = buildInfoMembers
-        .map { case v => s"""map.put("${v.key}", ${v.key});""" }
-        .mkString(",\n")
-
-      s"""
-         |package $buildInfoPackageName;
-         |
-         |public class $buildInfoObjectName {
-         |  $bindingsCode
-         |
-         |  public static java.util.Map<String, String> toMap(){
-         |    Map<String, String> map = new HashMap<String, String>();
-         |    $mapEntries
-         |    return map;
-         |  }
-         |}
-      """.stripMargin.trim
-    }
-  }
-
-  def codegen(
-      buildInfoMembers: Seq[Value],
-      isScala: Boolean,
-      buildInfoPackageName: String,
-      buildInfoObjectName: String
-  ): String = {
-    val bindingsCode = buildInfoMembers
-      .sortBy(_.key)
-      .map {
-        case v =>
-          if (isScala)
-            s"""${commentStr(v)}val ${v.key} = buildInfoProperties.getProperty("${v.key}")"""
-          else s"""${commentStr(
-              v
-            )}public static final java.lang.String ${v.key} = buildInfoProperties.getProperty("${v.key}");"""
-      }
-      .mkString("\n\n  ")
-
-    if (isScala)
-      s"""
-         |package ${buildInfoPackageName}
-         |
-         |object $buildInfoObjectName {
-         |  private val buildInfoProperties = new java.util.Properties
-         |
-         |  private val buildInfoInputStream = getClass
-         |    .getResourceAsStream("$buildInfoObjectName.buildinfo.properties")
-         |
-         |  buildInfoProperties.load(buildInfoInputStream)
-         |
-         |  $bindingsCode
-         |}
-      """.stripMargin.trim
-    else
-      s"""
-         |package ${buildInfoPackageName};
-         |
-         |public class $buildInfoObjectName {
-         |  private static java.util.Properties buildInfoProperties = new java.util.Properties();
-         |
-         |  static {
-         |    java.io.InputStream buildInfoInputStream = $buildInfoObjectName
-         |      .class
-         |      .getResourceAsStream("$buildInfoObjectName.buildinfo.properties");
-         |
-         |    try{
-         |      buildInfoProperties.load(buildInfoInputStream);
-         |    }catch(java.io.IOException e){
-         |      throw new RuntimeException(e);
-         |    }finally{
-         |      try{
-         |        buildInfoInputStream.close();
-         |      }catch(java.io.IOException e){
-         |        throw new RuntimeException(e);
-         |      }
-         |    }
-         |  }
-         |
-         |  $bindingsCode
-         |}
-      """.stripMargin.trim
-  }
-
-  def commentStr(v: Value) = {
-    if (v.comment.isEmpty) ""
-    else {
-      val lines = v.comment.linesIterator.toVector
-      lines.length match {
-        case 1 => s"""/** ${v.comment} */\n  """
-        case _ => s"""/**\n    ${lines.map("* " + _).mkString("\n    ")}\n    */\n  """
-      }
-
-    }
-  }
-}
-
 def commonPomSettings(artifactName: String) = {
   PomSettings(
     description = artifactName,
@@ -523,27 +307,8 @@ trait MillCoursierModule extends CoursierModule {
   )
 }
 
-trait MillMimaConfig extends mima.Mima {
+trait MillMimaConfig extends Module {
   def skipPreviousVersions: T[Seq[String]] = T(Seq.empty[String])
-  override def mimaPreviousVersions: T[Seq[String]] = Settings.mimaBaseVersions
-  override def mimaPreviousArtifacts: T[Agg[Dep]] = T {
-    Agg.from(
-      Settings.mimaBaseVersions
-        .filter(v => !skipPreviousVersions().contains(v))
-        .map(version =>
-          ivy"${pomSettings().organization}:${artifactId()}:${version}"
-        )
-    )
-  }
-  override def mimaExcludeAnnotations: T[Seq[String]] = Seq(
-    "mill.api.internal",
-    "mill.api.experimental"
-  )
-  override def mimaCheckDirection: Target[CheckDirection] = T { CheckDirection.Backward }
-  override def mimaBinaryIssueFilters: Target[Seq[ProblemFilter]] = T {
-    issueFilterByModule.getOrElse(this, Seq())
-  }
-  lazy val issueFilterByModule: Map[MillMimaConfig, Seq[ProblemFilter]] = Map()
 }
 
 /** A Module compiled with applied Mill-specific compiler plugins: mill-moduledefs. */
@@ -846,7 +611,10 @@ object scalajslib extends MillModule with BuildInfo {
     override def ivyDeps = Agg(Deps.sbtTestInterface)
   }
   object worker extends Cross[WorkerModule]("1")
-  class WorkerModule(scalajsWorkerVersion: String) extends MillInternalModule {
+
+  trait WorkerModule extends MillInternalModule with Cross.Module[String] {
+    def scalajsWorkerVersion = crossValue
+    override def millSourcePath: os.Path = super.millSourcePath / scalajsWorkerVersion
     def testDepPaths = T{ Seq(compile().classes) }
     override def moduleDeps = Seq(scalajslib.`worker-api`, main.client, main.api)
     override def ivyDeps = Agg(
@@ -911,8 +679,10 @@ object contrib extends MillModule {
 
     object api extends MillPublishModule
 
-    object worker extends Cross[WorkerModule](Deps.play.keys.toSeq: _*)
-    class WorkerModule(playBinary: String) extends MillInternalModule {
+    object worker extends Cross[WorkerModule](Deps.play.keys.toSeq)
+    trait WorkerModule extends MillInternalModule with Cross.Module[String] {
+      def playBinary = crossValue
+      override def millSourcePath: os.Path = super.millSourcePath / playBinary
       override def sources = T.sources {
         // We want to avoid duplicating code as long as the Play APIs allow.
         // But if newer Play versions introduce incompatibilities,
@@ -1074,8 +844,9 @@ object scalanativelib extends MillModule {
     override def ivyDeps = Agg(Deps.sbtTestInterface)
   }
   object worker extends Cross[WorkerModule]("0.4")
-  class WorkerModule(scalaNativeWorkerVersion: String)
-      extends MillInternalModule {
+  trait WorkerModule extends MillInternalModule with Cross.Module[String] {
+    def scalaNativeWorkerVersion = crossValue
+    override def millSourcePath: os.Path = super.millSourcePath / scalaNativeWorkerVersion
     def testDepPaths = T{ Seq(compile().classes) }
     override def moduleDeps = Seq(scalanativelib.`worker-api`)
     override def ivyDeps = scalaNativeWorkerVersion match {
@@ -1225,7 +996,9 @@ trait IntegrationTestModule extends MillScalaModule {
   }
 }
 
-trait IntegrationTestCrossModule extends IntegrationTestModule {
+trait IntegrationTestCrossModule extends IntegrationTestModule with Cross.Module[String] {
+  def repoSlug = crossValue
+  override def millSourcePath = super.millSourcePath / repoSlug
   object local extends ModeModule{
     def testTransitiveDeps = super.testTransitiveDeps() ++ Seq(
       runner.linenumbers.testDep(),
@@ -1251,15 +1024,15 @@ object example extends MillScalaModule {
 
   def moduleDeps = Seq(integration)
 
-  object basic extends Cross[ExampleCrossModule](listIn(millSourcePath / "basic"): _*)
-  object scalabuilds extends Cross[ExampleCrossModule](listIn(millSourcePath / "scalabuilds"): _*)
-  object scalamodule extends Cross[ExampleCrossModule](listIn(millSourcePath / "scalamodule"): _*)
-  object tasks extends Cross[ExampleCrossModule](listIn(millSourcePath / "tasks"): _*)
-  object cross extends Cross[ExampleCrossModule](listIn(millSourcePath / "cross"): _*)
-  object misc extends Cross[ExampleCrossModule](listIn(millSourcePath / "misc"): _*)
-  object web extends Cross[ExampleCrossModule](listIn(millSourcePath / "web"): _*)
+  object basic extends Cross[ExampleCrossModule](listIn(millSourcePath / "basic"))
+  object scalabuilds extends Cross[ExampleCrossModule](listIn(millSourcePath / "scalabuilds"))
+  object scalamodule extends Cross[ExampleCrossModule](listIn(millSourcePath / "scalamodule"))
+  object tasks extends Cross[ExampleCrossModule](listIn(millSourcePath / "tasks"))
+  object cross extends Cross[ExampleCrossModule](listIn(millSourcePath / "cross"))
+  object misc extends Cross[ExampleCrossModule](listIn(millSourcePath / "misc"))
+  object web extends Cross[ExampleCrossModule](listIn(millSourcePath / "web"))
 
-  class ExampleCrossModule(val repoSlug: String) extends IntegrationTestCrossModule {
+  trait ExampleCrossModule extends IntegrationTestCrossModule {
     def sources = T.sources()
     def testRepoRoot: T[PathRef] = T.source(millSourcePath)
     def compile = example.compile()
@@ -1309,7 +1082,7 @@ object example extends MillScalaModule {
               val title =
                 if (seenCode) ""
                 else {
-                  val label = VcsVersion.vcsState().format()
+                  val label = "xxx"
                   val exampleDashed = examplePath.segments.mkString("-")
                   val download = s"{mill-download-url}/$label-$exampleDashed.zip[download]"
                   val browse = s"{mill-example-url}/$examplePath[browse]"
@@ -1340,9 +1113,9 @@ object example extends MillScalaModule {
 }
 
 object integration extends MillScalaModule {
-  object failure extends Cross[IntegrationCrossModule](listIn(millSourcePath / "failure"): _*)
-  object feature extends Cross[IntegrationCrossModule](listIn(millSourcePath / "feature"): _*)
-  class IntegrationCrossModule(val repoSlug: String) extends IntegrationTestCrossModule
+  object failure extends Cross[IntegrationCrossModule](listIn(millSourcePath / "failure"))
+  object feature extends Cross[IntegrationCrossModule](listIn(millSourcePath / "feature"))
+  trait IntegrationCrossModule extends IntegrationTestCrossModule
 
   def moduleDeps = Seq(scalalib, scalajslib, scalanativelib, runner.test)
 
@@ -1549,9 +1322,6 @@ object dev extends MillModule {
   }
 
   def forkArgs: T[Seq[String]] = T{
-
-
-
     main.graphviz.testArgs() ++
     contrib.buildinfo.testArgs() ++
     scalalib.testArgs() ++
@@ -1665,67 +1435,11 @@ object docs extends Module {
     def moduleDeps = build.millInternal.modules.collect { case m: MillApiModule => m }
 
     def unidocSourceUrl = T {
-      val sha = VcsVersion.vcsState().currentRevision
+      val sha = "xxx"
       Some(s"${Settings.projectUrl}/blob/$sha")
     }
   }
 
-  /**
-   * Mix this in to any [[ScalaModule]] to provide a [[unidocSite]] target that
-   * can be used to build a unified scaladoc site for this module and all of
-   * its transitive dependencies
-   */
-  trait UnidocModule extends ScalaModule {
-    def unidocSourceUrl: T[Option[String]] = None
-    def unidocVersion: T[Option[String]] = None
-
-    def unidocLocal = T {
-      def unidocCompileClasspath =
-        Seq(compile().classes) ++ T.traverse(moduleDeps)(_.compileClasspath)().flatten
-
-      val unidocSourceFiles =
-        allSourceFiles() ++ T.traverse(moduleDeps)(_.allSourceFiles)().flatten
-
-      T.log.info(s"Staging scaladoc for ${unidocSourceFiles.length} files")
-
-      // the details of the options and zincWorker call are significantly
-      // different between scala-2 scaladoc and scala-3 scaladoc
-      // below is for scala-2 variant
-      val options: Seq[String] = Seq(
-        "-doc-title",
-        "Mill",
-        "-d",
-        T.dest.toString,
-        "-classpath",
-        unidocCompileClasspath.map(_.path).mkString(sys.props("path.separator"))
-      ) ++
-        unidocVersion().toSeq.flatMap(Seq("-doc-version", _)) ++
-        unidocSourceUrl().toSeq.flatMap(_ => Seq("-doc-source-url", "file://€{FILE_PATH}.scala"))
-
-      zincWorker.worker().docJar(
-        scalaVersion(),
-        scalaOrganization(),
-        scalaDocClasspath().map(_.path),
-        scalacPluginClasspath().map(_.path),
-        options ++ unidocSourceFiles.map(_.path.toString)
-      ) match {
-        case true => mill.api.Result.Success(PathRef(T.dest))
-        case false => mill.api.Result.Failure("unidoc generation failed")
-      }
-    }
-
-    def unidocSite = T {
-      os.copy(unidocLocal().path, T.dest, mergeFolders = true)
-      for {
-        sourceUrl <- unidocSourceUrl()
-        p <- os.walk(T.dest) if p.ext == "scala"
-      } {
-        os.write(p, os.read(p).replace(s"file://${T.workspace}", sourceUrl))
-      }
-      PathRef(T.dest)
-    }
-  }
-
   private val npmExe = if (scala.util.Properties.isWin) "npm.cmd" else "npm"
   private val antoraExe = if (scala.util.Properties.isWin) "antora.cmd" else "antora"
   def npmBase: T[os.Path] = T.persistent { T.dest }
@@ -1778,7 +1492,7 @@ object docs extends Module {
 
     val contribReadmes = T.traverse(contrib.contribModules)(m =>
       T.task {
-        m.millModuleSegments.last.render -> m.readme()
+        m.millModuleSegments.parts.last -> m.readme()
       }
     )()
 
@@ -2007,7 +1721,7 @@ def exampleZips: Target[Seq[PathRef]] = T {
     examplePath = exampleMod.millSourcePath
   } yield {
     val example = examplePath.subRelativeTo(T.workspace)
-    val exampleStr = VcsVersion.vcsState().format() + "-" + example.segments.mkString("-")
+    val exampleStr = "xxx" + "-" + example.segments.mkString("-")
     os.copy(examplePath, T.dest / exampleStr, createFolders = true)
     os.copy(launcher().path, T.dest / exampleStr / "mill")
     val zip = T.dest / s"$exampleStr.zip"
@@ -2016,49 +1730,7 @@ def exampleZips: Target[Seq[PathRef]] = T {
   }
 }
 
-def uploadToGithub(authKey: String) = T.command {
-  val vcsState = VcsVersion.vcsState()
-  val label = vcsState.format()
-  if (label != millVersion()) sys.error("Modified mill version detected, aborting upload")
-  val releaseTag = vcsState.lastTag.getOrElse(sys.error(
-    "Incomplete git history. No tag found.\nIf on CI, make sure your git checkout job includes enough history."
-  ))
-
-  if (releaseTag == label) {
-    // TODO: check if the tag already exists (e.g. because we created it manually) and do not fail
-    scalaj.http.Http(
-      s"https://api.github.com/repos/${Settings.githubOrg}/${Settings.githubRepo}/releases"
-    )
-      .postData(
-        ujson.write(
-          ujson.Obj(
-            "tag_name" -> releaseTag,
-            "name" -> releaseTag
-          )
-        )
-      )
-      .header("Authorization", "token " + authKey)
-      .asString
-  }
-
-  val examples = exampleZips().map(z => (z.path, z.path.last))
-
-  val zips = examples ++ Seq(
-    (assembly().path, label + "-assembly"),
-    (launcher().path, label)
-  )
-
-  for ((zip, name) <- zips) {
-    upload.apply(
-      zip,
-      releaseTag,
-      name,
-      authKey,
-      Settings.githubOrg,
-      Settings.githubRepo
-    )
-  }
-}
+def uploadToGithub(authKey: String) = T.command {}
 
 def validate(ev: Evaluator): Command[Unit] = T.command {
   T.task(MainModule.evaluateTasks(
diff --git a/ci/mill-bootstrap.patch b/ci/mill-bootstrap.patch
index 9707a8b5a1..e10e01e5cd 100644
--- a/ci/mill-bootstrap.patch
+++ b/ci/mill-bootstrap.patch
@@ -1,39 +1,8 @@
 diff --git a/build.sc b/build.sc
-index e84e6dd644..031388de0c 100644
+index 53e945d488..f2517371da 100644
 --- a/build.sc
 +++ b/build.sc
-@@ -2,27 +2,18 @@
- import $file.ci.shared
- import $file.ci.upload
- import $ivy.`org.scalaj::scalaj-http:2.4.2`
--import $ivy.`de.tototec::de.tobiasroeser.mill.vcs.version_mill0.10:0.3.0`
--import $ivy.`com.github.lolgab::mill-mima_mill0.10:0.0.13`
- import $ivy.`net.sourceforge.htmlcleaner:htmlcleaner:2.25`
-+import $ivy.`com.lihaoyi::mill-contrib-buildinfo:$MILL_VERSION`
-+import mill.contrib.buildinfo.BuildInfo
- 
- // imports
--import com.github.lolgab.mill.mima
--import com.github.lolgab.mill.mima.{
--  CheckDirection,
--  DirectMissingMethodProblem,
--  IncompatibleMethTypeProblem,
--  IncompatibleSignatureProblem,
--  ProblemFilter,
--  ReversedMissingMethodProblem
--}
- import coursier.maven.MavenRepository
--import de.tobiasroeser.mill.vcs.version.VcsVersion
- import mill._
- import mill.define.{Command, Source, Sources, Target, Task}
- import mill.eval.Evaluator
- import mill.main.MainModule
- import mill.scalalib._
-+import mill.scalalib.api.Versions
- import mill.scalalib.publish._
- import mill.modules.Jvm
- import mill.define.SelectMode
-@@ -163,12 +154,8 @@ object Deps {
+@@ -163,12 +163,8 @@ object Deps {
    val requests = ivy"com.lihaoyi::requests:0.8.0"
  }
  
@@ -48,7 +17,7 @@ index e84e6dd644..031388de0c 100644
  def millBinPlatform: T[String] = T {
    val tag = millLastTag()
    if (tag.contains("-M")) tag
-@@ -217,8 +204,8 @@ val buildBridgeScalaVersions =
+@@ -217,8 +213,8 @@ val buildBridgeScalaVersions =
    if (!buildAllCompilerBridges) Seq()
    else bridgeScalaVersions
  
@@ -59,7 +28,7 @@ index e84e6dd644..031388de0c 100644
    def scalaVersion = crossScalaVersion
    def publishVersion = bridgeVersion
    def artifactName = T { "mill-scala-compiler-bridge" }
-@@ -237,239 +224,25 @@ class BridgeModule(val crossScalaVersion: String) extends PublishModule with Cro
+@@ -237,239 +233,25 @@ class BridgeModule(val crossScalaVersion: String) extends PublishModule with Cro
    def generatedSources = T {
      import mill.scalalib.api.ZincWorkerUtil.{grepJar, scalaBinaryVersion}
      val resolvedJars = resolveDeps(
@@ -304,7 +273,7 @@ index e84e6dd644..031388de0c 100644
  def commonPomSettings(artifactName: String) = {
    PomSettings(
      description = artifactName,
-@@ -523,27 +296,8 @@ trait MillCoursierModule extends CoursierModule {
+@@ -523,27 +305,8 @@ trait MillCoursierModule extends CoursierModule {
    )
  }
  
@@ -333,7 +302,7 @@ index e84e6dd644..031388de0c 100644
  }
  
  /** A Module compiled with applied Mill-specific compiler plugins: mill-moduledefs. */
-@@ -842,7 +596,10 @@ object scalajslib extends MillModule with BuildInfo {
+@@ -846,7 +609,10 @@ object scalajslib extends MillModule with BuildInfo {
      override def ivyDeps = Agg(Deps.sbtTestInterface)
    }
    object worker extends Cross[WorkerModule]("1")
@@ -345,7 +314,7 @@ index e84e6dd644..031388de0c 100644
      def testDepPaths = T{ Seq(compile().classes) }
      override def moduleDeps = Seq(scalajslib.`worker-api`, main.client, main.api)
      override def ivyDeps = Agg(
-@@ -907,8 +664,10 @@ object contrib extends MillModule {
+@@ -911,8 +677,10 @@ object contrib extends MillModule {
  
      object api extends MillPublishModule
  
@@ -358,7 +327,7 @@ index e84e6dd644..031388de0c 100644
        override def sources = T.sources {
          // We want to avoid duplicating code as long as the Play APIs allow.
          // But if newer Play versions introduce incompatibilities,
-@@ -1070,8 +829,9 @@ object scalanativelib extends MillModule {
+@@ -1074,8 +842,9 @@ object scalanativelib extends MillModule {
      override def ivyDeps = Agg(Deps.sbtTestInterface)
    }
    object worker extends Cross[WorkerModule]("0.4")
@@ -370,7 +339,7 @@ index e84e6dd644..031388de0c 100644
      def testDepPaths = T{ Seq(compile().classes) }
      override def moduleDeps = Seq(scalanativelib.`worker-api`)
      override def ivyDeps = scalaNativeWorkerVersion match {
-@@ -1222,7 +982,9 @@ trait IntegrationTestModule extends MillScalaModule {
+@@ -1225,7 +994,9 @@ trait IntegrationTestModule extends MillScalaModule {
    }
  }
  
@@ -381,7 +350,7 @@ index e84e6dd644..031388de0c 100644
    object local extends ModeModule{
      def testTransitiveDeps = super.testTransitiveDeps() ++ Seq(
        runner.linenumbers.testDep(),
-@@ -1248,15 +1010,15 @@ object example extends MillScalaModule {
+@@ -1251,15 +1022,15 @@ object example extends MillScalaModule {
  
    def moduleDeps = Seq(integration)
  
@@ -405,7 +374,7 @@ index e84e6dd644..031388de0c 100644
      def sources = T.sources()
      def testRepoRoot: T[PathRef] = T.source(millSourcePath)
      def compile = example.compile()
-@@ -1306,7 +1068,7 @@ object example extends MillScalaModule {
+@@ -1309,7 +1080,7 @@ object example extends MillScalaModule {
                val title =
                  if (seenCode) ""
                  else {
@@ -414,7 +383,7 @@ index e84e6dd644..031388de0c 100644
                    val exampleDashed = examplePath.segments.mkString("-")
                    val download = s"{mill-download-url}/$label-$exampleDashed.zip[download]"
                    val browse = s"{mill-example-url}/$examplePath[browse]"
-@@ -1337,9 +1099,9 @@ object example extends MillScalaModule {
+@@ -1340,9 +1111,9 @@ object example extends MillScalaModule {
  }
  
  object integration extends MillScalaModule {
@@ -427,7 +396,7 @@ index e84e6dd644..031388de0c 100644
  
    def moduleDeps = Seq(scalalib, scalajslib, scalanativelib, runner.test)
  
-@@ -1670,67 +1432,11 @@ object docs extends Module {
+@@ -1673,67 +1444,11 @@ object docs extends Module {
      def moduleDeps = build.millInternal.modules.collect { case m: MillApiModule => m }
  
      def unidocSourceUrl = T {
@@ -496,7 +465,7 @@ index e84e6dd644..031388de0c 100644
    private val npmExe = if (scala.util.Properties.isWin) "npm.cmd" else "npm"
    private val antoraExe = if (scala.util.Properties.isWin) "antora.cmd" else "antora"
    def npmBase: T[os.Path] = T.persistent { T.dest }
-@@ -1783,7 +1489,7 @@ object docs extends Module {
+@@ -1786,7 +1501,7 @@ object docs extends Module {
  
      val contribReadmes = T.traverse(contrib.contribModules)(m =>
        T.task {
@@ -505,7 +474,7 @@ index e84e6dd644..031388de0c 100644
        }
      )()
  
-@@ -2012,7 +1718,7 @@ def exampleZips: Target[Seq[PathRef]] = T {
+@@ -2015,7 +1730,7 @@ def exampleZips: Target[Seq[PathRef]] = T {
      examplePath = exampleMod.millSourcePath
    } yield {
      val example = examplePath.subRelativeTo(T.workspace)
@@ -514,7 +483,7 @@ index e84e6dd644..031388de0c 100644
      os.copy(examplePath, T.dest / exampleStr, createFolders = true)
      os.copy(launcher().path, T.dest / exampleStr / "mill")
      val zip = T.dest / s"$exampleStr.zip"
-@@ -2021,49 +1727,7 @@ def exampleZips: Target[Seq[PathRef]] = T {
+@@ -2024,49 +1739,7 @@ def exampleZips: Target[Seq[PathRef]] = T {
    }
  }
  
