diff --git a/dist/package.mill b/dist/package.mill
index fc69cdb68f0..d8464864021 100644
--- a/dist/package.mill
+++ b/dist/package.mill
@@ -342,23 +342,6 @@ object `package` extends RootModule with InstallModule {
 
     def nativeImageOptions = Seq("--no-fallback", "--enable-url-protocols=https", "-Os")
 
-    // copying the original method from NativeImageModule until re-bootstrapping
-    // for the withRevalidateOnce
-    def nativeImageTool: T[PathRef] = Task {
-      jvmWorker().javaHome().map(_.path)
-        .orElse(sys.env.get("GRAALVM_HOME").map(os.Path(_))) match {
-        case Some(home) =>
-          val tool = if (scala.util.Properties.isWin) "native-image.cmd" else "native-image"
-          val path = home / "bin" / tool
-          if (os.exists(path))
-            // native-image is externally managed, better revalidate it at least once
-            PathRef(path).withRevalidateOnce
-          else throw new RuntimeException(s"$path not found")
-        case None =>
-          throw new RuntimeException("JvmWorkerModule.javaHome/GRAALVM_HOME not defined")
-      }
-    }
-
     def jvmWorker = ModuleRef(JvmWorkerGraalvm)
 
     def maybeCopyGraal(): Command[Unit] = Task.Command {
@@ -373,19 +356,13 @@ object `package` extends RootModule with InstallModule {
       // copying the original method from NativeImageModule until re-bootstrapping
       // for the withRevalidateOnce
       def javaHome: T[Option[PathRef]] = Task {
-        Option(jvmId()).filter(_ != "").map { id =>
-          val path = mill.util.Jvm.resolveJavaHome(
-            id = id,
-            coursierCacheCustomizer = coursierCacheCustomizer(),
-            ctx = Some(implicitly[mill.api.Ctx.Log]),
-            jvmIndexVersion = jvmIndexVersion()
-          ).get
+        super.javaHome().map { ref =>
           if (Properties.isWin && System.getenv("CI") != null) {
             val copied = T.workspace / "jvm"
             System.err.println(s"Using $copied as GraalVM")
             PathRef(copied, quick = true).withRevalidateOnce
           } else
-            PathRef(path, quick = true).withRevalidateOnce
+            ref
         }
       }
     }
diff --git a/mill-build/build.mill b/mill-build/build.mill
index 521b6533dd6..1c8b6ff79ea 100644
--- a/mill-build/build.mill
+++ b/mill-build/build.mill
@@ -1,5 +1,5 @@
 import mill._
-import mill.runner.MillBuildRootModule
+import mill.runner.meta.MillBuildRootModule
 import mill.scalalib._
 
 object `package` extends MillBuildRootModule {
diff --git a/website/package.mill b/website/package.mill
index c30c14440e4..f3e6aa41ed3 100644
--- a/website/package.mill
+++ b/website/package.mill
@@ -57,7 +57,7 @@ object `package` extends RootModule {
   }
 
   def runAntora(npmDir: os.Path, workDir: os.Path, args: Seq[String])(implicit
-      ctx: mill.api.Ctx.Log
+      ctx: mill.define.TaskCtx.Log
   ) = {
 
     prepareAntora(npmDir)
@@ -116,7 +116,7 @@ object `package` extends RootModule {
   }
 
   def expandDiagramsInDirectoryAdocFile(dest: os.Path, visualizeClassPath: Agg[os.Path])(implicit
-      ctx: mill.api.Ctx
+      ctx: mill.define.TaskCtx
   ) = {
 
     // Walk all files to render graphviz templates ourselves because the only Antora graphviz
