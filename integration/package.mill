package build.integration
// imports
import scala.util.chaining._
import coursier.maven.MavenRepository
import mill._
import mill.util.Tasks
import mill.scalalib._
import mill.javalib.api.JvmWorkerUtil
import mill.scalalib.publish._
import mill.util.Jvm
import mill.api.SelectMode
import mill.contrib.buildinfo.BuildInfo
import mill.T
import mill.api.Cross
import mill.javalib.testrunner.TestResult
import millbuild.*
import upickle.implicits.namedTuples.default.given
import mill.api.BuildCtx

object `package` extends mill.Module {
  // We compile the test code once and then offer multiple modes to
  // test it in the `test` CrossModule. We pass `test`'s sources to `lib` to
  // and pass `lib`'s compile output back to `test`.

  def sharedOutFolder = Task.Worker {
    val counter = new java.util.concurrent.atomic.AtomicInteger(0)
    new mill.util.CachedFactory[Unit, os.Path] {
      def setup(key: Unit): os.Path = {
        val res = Task.dest / s"shared-${counter.getAndIncrement()}" / "out"
        os.remove.all(res)
        os.makeDir.all(res)
        res
      }

      def teardown(key: Unit, value: os.Path): Unit = {
        os.remove.all(value)
      }

      def maxCacheSize: Int = Task.ctx().jobs
    }
  }

  trait IntegrationTestModule extends Cross.Module[String] with DefaultTaskModule {
    def moduleDir = super.moduleDir / crossValue

    def moduleDeps = Seq(build.libs.util.test, build.testkit, build.runner.daemon)

    def resources: T[Seq[PathRef]]
    def runClasspath: T[Seq[PathRef]]
    def localRunClasspath: T[Seq[PathRef]]
    def forkEnv: T[Map[String, String]]
    def forkArgs: T[Seq[String]]
    def testExclusive = false
    def testClasspath: T[Seq[PathRef]]

    trait ModeModule extends MillBaseTestsModule {
      override def testClasspath: T[Seq[PathRef]] = IntegrationTestModule.this.testClasspath()
      def useSharedOut: Boolean
      override def enableBsp = false
      override def testForked(args: String*) = Task.Command(exclusive = testExclusive) {

        sharedOutFolder().withValue(()) { sharedOutFolder =>
          val testModuleUtil = new mill.javalib.TestModuleUtil(
            testUseArgsFile(),
            forkArgs(),
            Seq.empty[String],
            jvmWorker().scalalibClasspath(),
            resources(),
            testFramework(),
            runClasspath(),
            testClasspath(),
            args,
            testForkGrouping(),
            jvmWorker().testrunnerEntrypointClasspath(),
            allForkEnv() ++ Option.when(useSharedOut) { "MILL_TEST_SHARED_OUTPUT_DIR" -> "1" },
            testSandboxWorkingDir = !useSharedOut,
            if (useSharedOut) sharedOutFolder else forkWorkingDir(),
            testReportXml(),
            javaHome().map(_.path),
            testParallelism(),
            testLogLevel(),
            jvmWorker = jvmWorker().internalWorker()
          )
          testModuleUtil.runTests()
        }
      }

      def mode: String = moduleSegments.parts.last
      def scalaVersion = Deps.scalaVersion

      def forkEnv = Task {
        super.forkEnv() ++
          IntegrationTestModule.this.forkEnv() ++
          Map(
            "MILL_INTEGRATION_DAEMON_MODE" -> (mode == "daemon").toString,
            "MILL_INTEGRATION_IS_PACKAGED_LAUNCHER" -> millIntegrationIsPackagedLauncher().toString,
            "MILL_LAUNCHER" -> build.dist.bootstrapLauncher().path.toString,
            "MILL_LAUNCHER_BAT" -> build.dist.bootstrapLauncherBat().path.toString,
            "MILL_INTEGRATION_LAUNCHER" -> millIntegrationLauncher().path.toString
          ) ++
          (if (millIntegrationIsPackagedLauncher()) Map() else build.dist.localTestOverridesEnv())
      }

      def millIntegrationLauncher: T[PathRef]

      /** Whether the Mill JARs are published locally alongside this Mill launcher */
      def millIntegrationIsPackagedLauncher: Task[Boolean]

      def forkArgs = Task {
        super.forkArgs() ++ IntegrationTestModule.this.forkArgs() ++ build.dist.forkArgs()
      }

      def resources = IntegrationTestModule.this.resources()
      def runClasspath = IntegrationTestModule.this.runClasspath()
      def localRunClasspath = IntegrationTestModule.this.localRunClasspath()

    }

    // Set `packaged.daemon` as the default way to run integration and example tests
    override def defaultTask(): String = "testForked"
    def testForked(args: String*): Task.Command[(msg: String, results: Seq[TestResult])] =
      Task.Command {
        packaged.daemon.testForked(args*)()
      }

    object shared extends IntegrationLauncherModule {
      override def useSharedOut = true
      def millIntegrationLauncher = build.dist.launcher()
      def millIntegrationIsPackagedLauncher = Task(false)
    }
    object packaged extends IntegrationLauncherModule {
      def millIntegrationLauncher = build.dist.executable()
      def millIntegrationIsPackagedLauncher = Task(true)
    }
    object native extends IntegrationLauncherModule {
      def millIntegrationLauncher = build.dist.native.executable()
      def millIntegrationIsPackagedLauncher = Task(true)
    }
    trait IntegrationLauncherModule extends DefaultTaskModule {
      // Set `daemon` as the default way to run integration and example tests
      override def defaultTask(): String = "testForked"
      def testForked(args: String*): Task.Command[(msg: String, results: Seq[TestResult])] =
        Task.Command {
          daemon.testForked(args*)()
        }
      def useSharedOut = false
      def millIntegrationLauncher: T[PathRef]
      def millIntegrationIsPackagedLauncher: Task[Boolean]
      object nodaemon extends ModeModule {
        override def useSharedOut = IntegrationLauncherModule.this.useSharedOut
        def millIntegrationLauncher = IntegrationLauncherModule.this.millIntegrationLauncher
        def millIntegrationIsPackagedLauncher =
          IntegrationLauncherModule.this.millIntegrationIsPackagedLauncher
      }
      object daemon extends ModeModule {
        override def useSharedOut = IntegrationLauncherModule.this.useSharedOut
        def millIntegrationLauncher = IntegrationLauncherModule.this.millIntegrationLauncher
        def millIntegrationIsPackagedLauncher =
          IntegrationLauncherModule.this.millIntegrationIsPackagedLauncher
      }
    }
  }

  object failure extends Cross[IntegrationCrossModule](build.listCross)
  object feature extends Cross[IntegrationCrossModule](build.listCross)
  object invalidation extends Cross[IntegrationCrossModule](build.listCross)
  object manual extends Cross[IntegrationCrossModule](build.listCross)
  object ide extends Cross[IdeIntegrationCrossModule](build.listCross)
  object bootstrap extends Cross[IdeIntegrationCrossModule](build.listCross)
  object migrating extends Cross[IdeIntegrationCrossModule](build.listCross)
  trait IntegrationCrossModule extends MillScalaModule with IntegrationTestModule {
    override def testClasspath = Seq(compile().classes)
    override lazy val test: MillScalaTests = new MillScalaTests {
      // This `test` module isn't used, since `this` contains the test code we want to
      // compile and the `ModeModule`s contain the entrypoints to run that code
      def enableBsp = false
    }
    override def moduleDeps = super[IntegrationTestModule].moduleDeps
    def forkArgs: T[Seq[String]] = Task(List.empty[String])
    def forkEnv = super.forkEnv() ++ Seq(
      // "UTEST_UPDATE_GOLDEN_TESTS" -> "1",
      "MILL_PROJECT_ROOT" -> BuildCtx.workspaceRoot.toString,
      "TEST_SCALA_2_13_VERSION" -> Deps.testScala213Version,
      "TEST_KOTLIN_VERSION" -> Deps.kotlinCompiler.version
    )
  }
  trait IdeIntegrationCrossModule extends IntegrationCrossModule {
    def moduleDeps = super.moduleDeps ++ Seq(`bsp-util`)
    def mvnDeps = super.mvnDeps() ++ Seq(
      Deps.bsp4j
    )
    def forkArgs = super.forkArgs() ++ Seq(
      s"-Dmill.integration.coursier-version=${Deps.coursier.dep.versionConstraint.asString}"
    )
  }

  /** Deploy freshly build mill for use in tests */
  def testMill: T[PathRef] = {
    val name = if (scala.util.Properties.isWin) "mill.bat" else "mill"
    Task {
      val executable = build.dist.executable().path
      val dest = Task.dest / name
      os.copy.over(executable, dest)
      PathRef(dest)
    }
  }

  object `bsp-util` extends MillScalaModule {
    def moduleDeps = Seq(build.libs.util.test, build.runner.bsp, build.libs.javalib.testrunner)
    def mvnDeps = super.mvnDeps() ++ Seq(
      Deps.bsp4j
    )
  }
}
