package build.integration
// imports
import scala.util.chaining.*
import coursier.maven.MavenRepository
import mill.*
import mill.util.Tasks
import mill.scalalib.*
import mill.javalib.api.JvmWorkerUtil
import mill.scalalib.publish.*
import mill.util.Jvm
import mill.api.SelectMode
import mill.contrib.buildinfo.BuildInfo
import mill.T
import mill.api.Cross
import mill.javalib.testrunner.TestResult
import millbuild.*
import upickle.implicits.namedTuples.default.given
import mill.api.BuildCtx

object `package` extends mill.Module {
  // We compile the test code once and then offer multiple modes to
  // test it in the `test` CrossModule. We pass `test`'s sources to `lib` to
  // and pass `lib`'s compile output back to `test`.

  // Pre-clone git repos for init tests at build time (parallelizable)
  // rather than during test execution
  object initRepos extends Module {
    case class RepoInfo(name: String, url: String, branch: String)

    val repos = Seq(
      // Maven tests
      RepoInfo("jansi", "https://github.com/fusesource/jansi.git", "jansi-2.4.2"),
      RepoInfo("netty", "https://github.com/netty/netty.git", "netty-4.2.6.Final"),
      // Gradle tests
      RepoInfo("FastCSV", "https://github.com/osiegmar/FastCSV.git", "v4.1.0"),
      RepoInfo("ehcache3", "https://github.com/ehcache/ehcache3.git", "v3.10.8"),
      // Sbt tests
      RepoInfo("Airstream", "https://github.com/raquo/Airstream.git", "v17.2.1"),
      RepoInfo("fs2", "https://github.com/typelevel/fs2.git", "v3.12.0")
    )

    val reposMap = repos.map(v => v.name -> v).toMap

    private def cloneRepoImpl(repo: RepoInfo, destDir: os.Path): PathRef = {
      val repoDir = destDir / repo.name
      os.proc("git", "clone", repo.url, "--depth", "1", "--branch", repo.branch, repo.name)
        .call(cwd = destDir)
      PathRef(repoDir)
    }

    def jansi = Task { cloneRepoImpl(reposMap("jansi"), Task.dest) }
    def netty = Task { cloneRepoImpl(reposMap("netty"), Task.dest) }
    def FastCSV = Task { cloneRepoImpl(reposMap("FastCSV"), Task.dest) }
    def ehcache3 = Task { cloneRepoImpl(reposMap("ehcache3"), Task.dest) }
    def Airstream = Task { cloneRepoImpl(reposMap("Airstream"), Task.dest) }
    def fs2 = Task { cloneRepoImpl(reposMap("fs2"), Task.dest) }

    def all = Task {
      Map(
        "jansi" -> jansi().path.toString,
        "netty" -> netty().path.toString,
        "FastCSV" -> FastCSV().path.toString,
        "ehcache3" -> ehcache3().path.toString,
        "Airstream" -> Airstream().path.toString,
        "fs2" -> fs2().path.toString
      )
    }
  }

  case class SharedWorkerInfo(outPath: os.Path, port: Int)

  def millVersionNoSelective = Task(selectiveInputs = Nil) {
    build.millVersion()
  }

  def sharedOutFolder = Task.Worker {

    // Include millVersion in the worker path to invalidate when Mill version changes
    os.list(Task.dest).foreach(os.remove.all(_))
    val versionDir = Task.dest / millVersionNoSelective()
    val counter = new java.util.concurrent.atomic.AtomicInteger(0)
    new mill.util.CachedFactory[Unit, SharedWorkerInfo] {
      def setup(key: Unit): SharedWorkerInfo = {
        val index = counter.getAndIncrement()
        val res = versionDir / s"shared-$index" / "out"
        os.remove.all(res)
        os.makeDir.all(res)
        SharedWorkerInfo(res, 10000 + index)
      }

      def teardown(key: Unit, value: SharedWorkerInfo): Unit = {
        os.remove.all(value.outPath)
      }

      def maxCacheSize: Int = Task.ctx().jobs
    }
  }

  trait IntegrationTestModule extends Cross.Module[String] with DefaultTaskModule {
    def moduleDir = super.moduleDir / crossValue

    def moduleDeps =
      Seq(build.libs.util.test, build.testkit, build.testkit.internal, build.runner.daemon)

    def resources: T[Seq[PathRef]]
    def runClasspath: T[Seq[PathRef]]
    def localRunClasspath: T[Seq[PathRef]]
    def forkEnv: T[Map[String, String]]
    def forkArgs: T[Seq[String]]
    def testExclusive = false
    def testClasspath: T[Seq[PathRef]]

    // No selective execution inputs overrides by default, but individual submodules can
    // override this to specify explicit selective execution inputs to use
    def selectiveInputs: Seq[Task[?]] = null

    trait ModeModule extends MillBaseTestsModule {
      override def testClasspath: T[Seq[PathRef]] = IntegrationTestModule.this.testClasspath()
      def useSharedOut: Boolean
      override def enableBsp = false
      def testForked0(args: String*) = Task.Anon {
        sharedOutFolder().withValue(()) { workerInfo =>
          val testModuleUtil = new mill.javalib.TestModuleUtil(
            testUseArgsFile(),
            forkArgs(),
            Seq.empty[String],
            jvmWorker().scalalibClasspath(),
            resources(),
            testFramework(),
            runClasspath(),
            testClasspath(),
            args,
            testForkGrouping(),
            jvmWorker().testrunnerEntrypointClasspath(),
            allForkEnv() ++ (
              if (useSharedOut)
                Map("MILL_TEST_SHARED_OUTPUT_DIR" -> "1", "PORT" -> workerInfo.port.toString)
              else Map.empty
            ),
            testSandboxWorkingDir = !useSharedOut,
            if (useSharedOut) workerInfo.outPath else forkWorkingDir(),
            testReportXml(),
            javaHome().map(_.path),
            testParallelism(),
            testLogLevel(),
            jvmWorker = jvmWorker().internalWorker()
          )
          testModuleUtil.runTests()
        }
      }

      override def testForked(args: String*) = Task.Command(
        selectiveInputs = IntegrationTestModule.this.selectiveInputs
      ) {
        testForked0(args*)()
      }

      def mode: String = moduleSegments.parts.last
      def scalaVersion = Deps.scalaVersion

      def forkEnv = Task {
        super.forkEnv() ++
          IntegrationTestModule.this.forkEnv() ++
          Map(
            "MILL_INTEGRATION_DAEMON_MODE" -> (mode == "daemon").toString,
            "MILL_INTEGRATION_IS_PACKAGED_LAUNCHER" -> millIntegrationIsPackagedLauncher().toString,
            "MILL_INTEGRATION_LAUNCHER" -> millIntegrationLauncher().path.toString
          ) ++
          (if (millIntegrationIsPackagedLauncher()) Map()
           else build.dist.raw.localTestOverridesEnv())
      }

      def millIntegrationLauncher: T[PathRef]

      /** Whether the Mill JARs are published locally alongside this Mill launcher */
      def millIntegrationIsPackagedLauncher: Task[Boolean]

      def forkArgs = Task {
        super.forkArgs() ++ IntegrationTestModule.this.forkArgs() ++ build.dist.raw.forkArgs()
      }

      def resources = IntegrationTestModule.this.resources()
      def runClasspath = IntegrationTestModule.this.runClasspath()
      def localRunClasspath = IntegrationTestModule.this.localRunClasspath()

    }

    // Set `fast.daemon` as the default way to run integration and example tests
    override def defaultTask(): String = "testForked"
    def testForked(args: String*): Task.Command[(msg: String, results: Seq[TestResult])] =
      Task.Command(selectiveInputs = selectiveInputs) {
        fast.daemon.testForked0(args*)()
      }

    object fast extends IntegrationLauncherModule {
      override def useSharedOut = true
      def millIntegrationLauncher = build.dist.raw.launcher()
      def millIntegrationIsPackagedLauncher = Task(false)
    }
    object packaged extends IntegrationLauncherModule {
      def millIntegrationLauncher = build.dist.raw.executable()
      def millIntegrationIsPackagedLauncher = Task(true)
    }
    object native extends IntegrationLauncherModule {
      def millIntegrationLauncher = build.dist.native.executable()
      def millIntegrationIsPackagedLauncher = Task(true)
    }
    object proguard extends IntegrationLauncherModule {
      def millIntegrationLauncher = build.dist.executable()
      def millIntegrationIsPackagedLauncher = Task(true)
    }
    trait IntegrationLauncherModule extends Module {
      def useSharedOut = false
      def millIntegrationLauncher: T[PathRef]
      def millIntegrationIsPackagedLauncher: Task[Boolean]
      object nodaemon extends ModeModule {
        // Test parallelism doesn't work when sharing the out folder
        // since the parallel test executions will collide over files
        override def testParallelism = !useSharedOut
        override def useSharedOut = IntegrationLauncherModule.this.useSharedOut
        def millIntegrationLauncher = IntegrationLauncherModule.this.millIntegrationLauncher
        def millIntegrationIsPackagedLauncher =
          IntegrationLauncherModule.this.millIntegrationIsPackagedLauncher
      }
      object daemon extends ModeModule {
        override def testParallelism = !useSharedOut
        override def useSharedOut = IntegrationLauncherModule.this.useSharedOut
        def millIntegrationLauncher = IntegrationLauncherModule.this.millIntegrationLauncher
        def millIntegrationIsPackagedLauncher =
          IntegrationLauncherModule.this.millIntegrationIsPackagedLauncher
      }
    }
  }

  object failure extends Cross[IntegrationCrossModule](build.listCross)
  object feature extends Cross[IntegrationCrossModule](build.listCross)
  object dedicated extends Cross[DedicatedIntegrationCrossModule](build.listCross)
  object multimode extends Cross[MultimodeIntegrationCrossModule](build.listCross)
  object bootstrap extends Cross[BootstrapIntegrationCrossModule](build.listCross)
  object migrating extends Cross[MigrationIntegrationCrossModule](build.listCross)
  object manual extends Cross[IntegrationCrossModule](build.listCross)

  trait DedicatedIntegrationCrossModule extends IntegrationCrossModule {
    override def testForked(args: String*): Task.Command[(msg: String, results: Seq[TestResult])] =
      Task.Command(selectiveInputs = selectiveInputs) { proguard.daemon.testForked0(args*)() }
  }
  trait MultimodeIntegrationCrossModule extends IntegrationCrossModule {
    override def testForked(args: String*): Task.Command[(msg: String, results: Seq[TestResult])] =
      Task.Command(selectiveInputs = selectiveInputs) { packaged.daemon.testForked0(args*)() }
  }
  trait BootstrapIntegrationCrossModule extends IntegrationCrossModule {
    override def testForked(args: String*): Task.Command[(msg: String, results: Seq[TestResult])] =
      Task.Command(selectiveInputs = selectiveInputs) { native.daemon.testForked0(args*)() }
  }
  trait MigrationIntegrationCrossModule extends IntegrationCrossModule {
    override def testForked(args: String*): Task.Command[(msg: String, results: Seq[TestResult])] =
      Task.Command(selectiveInputs = selectiveInputs) { packaged.daemon.testForked0(args*)() }
    def forkEnv = super.forkEnv() ++ initRepos.all().map { case (name, path) =>
      s"MILL_INIT_REPO_$name" -> path
    }
    override def selectiveInputs = Seq(
      sources,
      resources,
      build.libs.init.sources,
      build.libs.init.maven.sources,
      build.libs.init.gradle.sources,
      build.libs.init.gradle.api.sources,
      build.libs.init.gradle.exportplugin.sources,
      build.libs.init.sbt.sources,
      build.libs.init.sbt.api(Deps.scalaVersion).sources,
      build.libs.init.sbt.exportplugin.sources,
      build.libs.init.buildgen.sources,
      build.libs.init.buildgen.api(Deps.scalaVersion).sources
    )
  }
  trait IntegrationCrossModule extends MillScalaModule with IntegrationTestModule {
    override def testClasspath = Seq(compile().classes)
    override lazy val test: MillScalaTests = new MillScalaTests {
      // This `test` module isn't used, since `this` contains the test code we want to
      // compile and the `ModeModule`s contain the entrypoints to run that code
      def enableBsp = false
    }
    override def moduleDeps = super[IntegrationTestModule].moduleDeps ++ Seq(`bsp-util`)
    def mvnDeps = super.mvnDeps() ++ Seq(
      Deps.bsp4j
    )

    def forkArgs: T[Seq[String]] = Seq(
      s"-Dmill.integration.coursier-version=${Deps.coursier.dep.versionConstraint.asString}"
    )
    def forkEnv = Task {
      super.forkEnv() ++ Seq(
        // "UTEST_UPDATE_GOLDEN_TESTS" -> "1",
        "MILL_PROJECT_ROOT" -> BuildCtx.workspaceRoot.toString,
        "TEST_SCALA_2_13_VERSION" -> Deps.testScala213Version,
        "TEST_KOTLIN_VERSION" -> Deps.kotlinCompiler.version
      )
    }
  }

  /** Deploy freshly build mill for use in tests */
  def testMill: T[PathRef] = {
    val name = if (scala.util.Properties.isWin) "mill.bat" else "mill"
    Task {
      val executable = build.dist.raw.executable().path
      val dest = Task.dest / name
      os.copy.over(executable, dest)
      PathRef(dest)
    }
  }

  object `bsp-util` extends MillScalaModule {
    def moduleDeps = Seq(build.libs.util.test, build.runner.bsp, build.libs.javalib.testrunner)
    def mvnDeps = super.mvnDeps() ++ Seq(
      Deps.bsp4j
    )
  }
}
