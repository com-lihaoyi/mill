package build.integration
// imports
import scala.util.chaining._
import coursier.maven.MavenRepository
import mill._
import mill.main.Tasks
import mill.scalalib._
import mill.scalalib.api.JvmWorkerUtil
import mill.scalalib.publish._
import mill.util.Jvm
import mill.define.SelectMode
import mill.contrib.buildinfo.BuildInfo
import mill.T
import mill.define.Cross
import mill.testrunner.TestResult

// plugins and dependencies
import $meta._

object `package` extends RootModule {
  // We compile the test code once and then offer multiple modes to
  // test it in the `test` CrossModule. We pass `test`'s sources to `lib` to
  // and pass `lib`'s compile output back to `test`.

  trait IntegrationTestModule extends Cross.Module[String] {
    def moduleDir = super.moduleDir / crossValue

    def moduleDeps = Seq(build.main.test, build.testkit, build.runner)

    def resources: T[Seq[PathRef]]
    def runClasspath: T[Seq[PathRef]]
    def localRunClasspath: T[Seq[PathRef]]
    def forkEnv: T[Map[String, String]]
    def testExclusive = false
    trait ModeModule extends build.MillBaseTestsModule {
      override def testForked(args: String*) = Task.Command(exclusive = testExclusive) {
        testTask(Task.Anon { args }, Task.Anon { Seq.empty[String] })()
      }

      def mode: String = moduleSegments.parts.last
      def scalaVersion = build.Deps.scalaVersion

      def forkEnv =
        super.forkEnv() ++
          IntegrationTestModule.this.forkEnv() ++
          Map(
            "MILL_INTEGRATION_SERVER_MODE" -> (mode == "local" || mode == "server").toString,
            "MILL_INTEGRATION_IS_PACKAGED_LAUNCHER" -> millIntegrationIsPackagedLauncher().toString,
            "MILL_LAUNCHER" -> build.dist.bootstrapLauncher().path.toString,
            "MILL_LAUNCHER_BAT" -> build.dist.bootstrapLauncherBat().path.toString,
            "MILL_INTEGRATION_LAUNCHER" -> millIntegrationLauncher().path.toString,
            "MILL_LOCAL_TEST_OVERRIDE_CLASSPATH" -> build.dist.localTestOverridesClasspath().path.toString
          )

      def millIntegrationLauncher: T[PathRef]

      /** Whether the Mill JARs are published locally alongside this Mill launcher */
      def millIntegrationIsPackagedLauncher: Task[Boolean]

      def forkArgs = Task { super.forkArgs() ++ build.dist.forkArgs() }

      def resources = IntegrationTestModule.this.resources()
      def runClasspath = IntegrationTestModule.this.runClasspath()
      def localRunClasspath = IntegrationTestModule.this.localRunClasspath()

      def compile: T[mill.scalalib.api.CompilationResult] =
        Task {
          mill.scalalib.api.CompilationResult(null, null)
        } // binary compatibility stub, not used

    }

    object local extends IntegrationLauncherModule {
      def millIntegrationLauncher = build.dist.launcher()
      def millIntegrationIsPackagedLauncher = Task(false)
    }
    object packaged extends IntegrationLauncherModule {
      def millIntegrationLauncher = build.dist.executable()
      def millIntegrationIsPackagedLauncher = Task(true)
    }
    object native extends IntegrationLauncherModule {
      def millIntegrationLauncher = build.dist.native.executable()
      def millIntegrationIsPackagedLauncher = Task(true)
    }
    trait IntegrationLauncherModule extends Module {
      def millIntegrationLauncher: T[PathRef]
      def millIntegrationIsPackagedLauncher: Task[Boolean]
      object fork extends ModeModule {
        def millIntegrationLauncher = IntegrationLauncherModule.this.millIntegrationLauncher
        def millIntegrationIsPackagedLauncher =
          IntegrationLauncherModule.this.millIntegrationIsPackagedLauncher
      }
      object server extends ModeModule {
        def millIntegrationLauncher = IntegrationLauncherModule.this.millIntegrationLauncher
        def millIntegrationIsPackagedLauncher =
          IntegrationLauncherModule.this.millIntegrationIsPackagedLauncher
      }
    }
  }

  object failure extends Cross[IntegrationCrossModule](build.listIn(moduleDir / "failure"))
  object feature extends Cross[IntegrationCrossModule](build.listIn(moduleDir / "feature"))
  object invalidation
      extends Cross[IntegrationCrossModule](build.listIn(moduleDir / "invalidation"))
  object ide extends Cross[IdeIntegrationCrossModule](build.listIn(moduleDir / "ide"))
  object bootstrap
      extends Cross[IdeIntegrationCrossModule](build.listIn(moduleDir / "bootstrap"))
  object migrating
      extends Cross[IdeIntegrationCrossModule](build.listIn(moduleDir / "migrating"))
  trait IntegrationCrossModule extends build.MillScalaModule with IntegrationTestModule {
    override def moduleDeps = super[IntegrationTestModule].moduleDeps
    def forkEnv = super.forkEnv() ++ Seq(
      "MILL_PROJECT_ROOT" -> Task.workspace.toString,
      "TEST_SCALA_2_13_VERSION" -> build.Deps.testScala213Version,
      "TEST_KOTLIN_VERSION" -> build.Deps.kotlinCompiler.version
    )
  }
  trait IdeIntegrationCrossModule extends IntegrationCrossModule {
    def ivyDeps = super.ivyDeps() ++ Agg(
      build.Deps.bsp4j
    )
  }

  /** Deploy freshly build mill for use in tests */
  def testMill: T[PathRef] = {
    val name = if (scala.util.Properties.isWin) "mill.bat" else "mill"
    Task {
      PathRef(build.dist.installLocalTask(binFile = Task.Anon((Task.dest / name).toString()))())
    }
  }
}
