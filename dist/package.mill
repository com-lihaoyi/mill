package build.dist

import mill.*
import scalalib.*
import publish.*
import mill.api.ModuleRef
import mill.util.Jvm
import mill.testkit.Chunk
//import de.tobiasroeser.mill.vcs.version.VcsVersion
import millbuild.*
import mill.api.BuildCtx
import mill.contrib.proguard.Proguard
import scala.util.Using
import scala.util.Properties
import java.nio.file.Files
import java.nio.file.attribute.PosixFilePermission

trait DistModule extends RunModule {
  // All modules that we want to aggregate as part of this `dev` assembly.
  // Excluding itself, and the `dist` module that uses it
  lazy val allPublishModules = build.moduleInternal.modules.collect {
    case m: MillPublishJavaModule => m
  }

  def executableRaw: T[PathRef]

  def localRepo: T[PathRef] = Task {
    val dest = Task.dest
    val repos = Task.traverse(allPublishModules)(m => m.publishLocalTestRepo)().map(_.path)
    for (repo <- repos; elem <- os.list(repo))
      os.copy.into(elem, dest, mergeFolders = true)
    PathRef(dest)
  }

  def executable = Task {
    val rawExecutable = executableRaw()
    if (Properties.isWin) {
      val launcher = Task.dest / "mill.bat"
      val launcherContent =
        s"""@echo off
           |set "NEW_COURSIER_REPOSITORIES=${localRepo().path.toNIO.toUri.toASCIIString}|ivy2Local|central"
           |if defined COURSIER_REPOSITORIES (
           |  set "NEW_COURSIER_REPOSITORIES=%NEW_COURSIER_REPOSITORIES%|%COURSIER_REPOSITORIES%"
           |) else (
           |  set "NEW_COURSIER_REPOSITORIES=%NEW_COURSIER_REPOSITORIES%|ivy2Local|central"
           |)
           |set "COURSIER_REPOSITORIES=%NEW_COURSIER_REPOSITORIES%"
           |set NEW_COURSIER_REPOSITORIES=
           |"${rawExecutable.path.toString.replace("\"", "\\\"")}" %*
           |if errorlevel 1 exit /b %errorlevel%
           |""".stripMargin
      os.write(launcher, launcherContent)
      PathRef(launcher)
    } else {
      val launcher = Task.dest / "mill"
      val launcherContent =
        s"""#!/usr/bin/env bash
           |set -e
           |export COURSIER_REPOSITORIES="${localRepo().path.toNIO.toUri.toASCIIString}|$${COURSIER_REPOSITORIES:-ivy2Local|central}"
           |exec '${rawExecutable.path.toString.replace("'", "\\'")}' "$$@"
           |""".stripMargin
      os.write(launcher, launcherContent)
      val perms = Files.getPosixFilePermissions(launcher.toNIO)
      perms.add(PosixFilePermission.OWNER_EXECUTE)
      perms.add(PosixFilePermission.GROUP_EXECUTE)
      perms.add(PosixFilePermission.OTHERS_EXECUTE)
      Files.setPosixFilePermissions(launcher.toNIO, perms)
      PathRef(launcher)
    }
  }

  def localBinName: String

  def cacheBinarySuffix: Task[String] = Task.Anon("")

  /**
   * Build and install Mill locally.
   *
   * @param binFile The location where the Mill binary should be installed
   */
  def installLocal(binFile: String = localBinName) = {
    val binFile0 = os.Path(binFile, BuildCtx.workspaceRoot)
    Task.Command[Unit] {
      installIvyLocalTask(Task.Anon(binFile0))()
    }
  }

  val batExt = if (scala.util.Properties.isWin) ".bat" else ""

  def installLocalCache() = {

    def launcherPathTask(suffix: Task[String]) =
      Task.Anon {
        os.home / ".cache/mill/download" / (build.millVersion() + suffix() + batExt)
      }

    val jarLauncherPathTask = launcherPathTask(build.dist.cacheBinarySuffix)
    val nativeLauncherPathTask = launcherPathTask(build.dist.native.cacheBinarySuffix)

    Task.Command {
      val Seq(jarLauncherPath, _*) =
        installIvyLocalTask(jarLauncherPathTask, nativeLauncherPathTask)()
      Task.log.streams.out.println(jarLauncherPath.path.toString())
      jarLauncherPath
    }
  }

  def installLocalTask(binFile: Task[String]): Task[os.Path] =
    Task.Anon {
      val targetFile = os.Path(binFile(), BuildCtx.workspaceRoot)
      if (os.exists(targetFile))
        Task.log.info(s"Overwriting existing local Mill binary at ${targetFile}")
      os.copy.over(executable().path, targetFile, createFolders = true)
      Task.log.info(
        s"Published ${build.dist.allPublishModules.size} modules under Mill sources local repo ${localRepo().path} and installed ${targetFile}"
      )
      targetFile
    }

  def installIvyLocalTask(targetFiles: Task[os.Path]*) =
    Task.Anon[Seq[PathRef]] {
      Task.traverse(allPublishModules)(m => m.publishLocal(doc = false))()
      val targetFiles0 = Task.sequence(targetFiles)()
      for (targetFile <- targetFiles0) {
        if (os.exists(targetFile))
          Task.log.info(s"Overwriting existing local Mill binary at $targetFile")
        os.copy.over(executableRaw().path, targetFile, createFolders = true)
      }
      Task.log.info(
        s"Published ${build.dist.allPublishModules.size} modules under ~/.ivy2/local and installed ${targetFiles0.mkString(", ")}"
      )
      targetFiles0.map(PathRef(_))
    }

  def artifactName: T[String]
  def artifact = Task { Artifact(Settings.pomOrg, artifactName(), build.millVersion()) }
  def pomSettings = Task { MillPublishJavaModule.commonPomSettings(artifactName()) }

  def artifactFileNamePrefix = Task { s"${artifactName()}-${build.millVersion()}" }
  def pom: T[PathRef] = Task {
    val pom = Pom(
      artifact = artifact(),
      dependencies = Nil,
      name = artifactName(),
      pomSettings = pomSettings(),
      properties = Map(),
      packagingType = "jar",
      parentProject = None,
      bomDependencies = Nil,
      dependencyManagement = Nil
    )
    val pomPath = Task.dest / s"${artifactFileNamePrefix()}.pom"
    os.write.over(pomPath, pom)
    PathRef(pomPath)
  }

  def publishArtifacts = Task {
    PublishModule.PublishData(
      meta = artifact(),
      payload = Seq(
        executableRaw() -> s"${artifactFileNamePrefix()}.exe",
        pom() -> s"${artifactFileNamePrefix()}.pom"
      )
    )
  }

  def millClientJvmArgs = Seq(
    // Avoid reserving a lot of memory for the client, as the client only forward information
    "-Xmx128m",
    // Set UTF-8 encoding to fix Unicode character display issues on Windows
    "-Dfile.encoding=UTF-8",
    "-Dsun.stdout.encoding=UTF-8",
    "-Dsun.stderr.encoding=UTF-8"
  )

  def forkArgs = Task{
    millClientJvmArgs ++ Seq(
      // Workaround for Zinc/JNA bug
      // https://github.com/sbt/sbt/blame/6718803ee6023ab041b045a6988fafcfae9d15b5/main/src/main/scala/sbt/Main.scala#L130
      "-Djna.nosys=true"
    )
  }
}

/**
 * The main dist module produces a ProGuard-minified assembly jar.
 * For integration/example tests, use `dist.raw` which provides the unminified assembly.
 */
object `package` extends MillJavaModule with Proguard with DistModule {
  def proguardVersion = "7.8.2"

  def moduleDeps = Seq(build.runner.launcher)

  def localTestExtraModules = allPublishModules

  def localBinName = "mill-proguard.jar"

  // Use the raw assembly as input to ProGuard
  override def inJar: T[PathRef] = assembly()

  override def mainClass = Some("mill.launcher.MillLauncherMain")

  // Disable obfuscation as it breaks reflection
  override def obfuscate = Task { false }

  // Disable optimization as it corrupts bytecode stack map frames in complex Scala code
  override def optimize = Task { false }

  override def additionalOptions: T[Seq[String]] = Seq(
    // From Proguard trait defaults
    "-dontwarn java.lang.invoke.MethodHandle",
    "-dontwarn scala.AnyKind",

    // Suppress all other warnings about missing classes - the Mill jar bundles many
    // dependencies that have optional runtime dependencies we don't need
    "-dontwarn **",

    // Keep all directory entries and resources in the output jar
    "-keepdirectories",

    // Keep Scala lazy val fields (used by Scala 3 lazy val implementation)
    "-keepclassmembers class * { ** *$lzy1; }",
    "-keepclassmembers class * { !transient <fields>; }",

    // Keep Coursier and scala-xml classes otherwise things break for some reason
    "-keep class coursier.** { *; }",
    "-keep class scala.xml.** { *; }"
  )

  private def writeExecutableScript(
      dest: os.Path,
      mainClass: String,
      shellClassPath: Seq[String],
      cmdClassPath: Seq[String],
      jvmArgs: Seq[String] = Nil,
      jarToAppend: Option[os.Path] = None
  ): Unit = {
    val script = Jvm.launcherUniversalScript(mainClass, shellClassPath, cmdClassPath, jvmArgs)
    val lineSep = if (!script.endsWith("\n")) "\n\r\n" else ""
    os.write(dest, script + lineSep)
    jarToAppend.foreach { jar =>
      scala.util.Using.resource(os.read.inputStream(jar)) { is =>
        os.write.append(dest, is)
      }
    }
    if (!scala.util.Properties.isWin) os.perms.set(dest, "rwxrwxrwx")
  }

  def executableRaw: T[PathRef] = Task {
    val filename = if (scala.util.Properties.isWin) "mill.bat" else "mill"
    val dest = Task.dest / filename
    writeExecutableScript(dest, mainClass().get, Seq("$0"), Seq("%~dpnx0"), jarToAppend = Some(proguard().path))
    PathRef(dest)
  }

  def launcher = Task {
    val filename = if (scala.util.Properties.isWin) "run.bat" else "run"
    val dest = Task.dest / filename

    val launcherForkArgs = testArgs()
    val (millArgs, otherArgs) =
      launcherForkArgs.partition(arg =>
        arg.startsWith("-DMILL") && !arg.startsWith("-DMILL_VERSION")
      )

    // Pass Mill options via file, due to small max args limit in Windows
    val vmOptionsFile = Task.dest / "mill.properties"
    val millOptionsContent = millArgs
      .map(_.drop(2).replace("\\", "/")) // drop -D prefix, replace \ with /
      .mkString("\r\n")

    os.write(vmOptionsFile, millOptionsContent)
    val jvmArgs = otherArgs ++ millClientJvmArgs ++ List(
      s"-DMILL_OPTIONS_PATH=$vmOptionsFile"
    )
    val classpath = runClasspath().map(_.path.toString)
    val classpathJar = Task.dest / "classpath.jar"
    Jvm.createClasspathPassingJar(classpathJar, runClasspath().map(_.path))

    writeExecutableScript(dest, mainClass().get, classpath, Seq(classpathJar.toString()), jvmArgs)
    PathRef(dest)
  }

  /**
   * The raw (unminified) assembly module. Used for integration and example tests
   * where startup time matters less than build time.
   */
  object raw extends MillJavaModule with DistModule {

    def moduleDeps = Seq(build.runner.launcher)

    def localTestExtraModules = allPublishModules

    def localBinName = "mill-assembly.jar"

    def assemblyRules = super.assemblyRules ++ Seq(
      mill.scalalib.Assembly.Rule.ExcludePattern("mill/local-test-overrides/.*")
    )

    def mainClass = Some("mill.launcher.MillLauncherMain")

    def executableRaw = Task {
      val filename = if (scala.util.Properties.isWin) "mill.bat" else "mill"
      os.copy(assembly().path, Task.dest / filename)
      PathRef(Task.dest / filename)
    }

    def artifactName = "mill-" + super.artifactName() + "-raw"
  }

  def run(args: Task[Args] = Task.Anon(Args())) = Task.Command(exclusive = true) {
    args().value match {
      case Nil => mill.api.Result.Failure("Need to pass in cwd as first argument to dist.raw.run")
      case wd0 +: rest =>
        val wd = os.Path(wd0, BuildCtx.workspaceRoot)
        assert(os.exists(wd), s"Folder $wd does not exist")
        try {
          os.call(
            cmd = (launcher().path.toString, rest),
            env = forkEnv() ++ build.dist.raw.localTestOverridesEnv(),
            cwd = wd,
            stdin = os.Inherit,
            stdout = os.Inherit,
            stderr = os.Inherit
          )
          mill.api.Result.Success(())
        } catch {
          case e: Throwable =>
            mill.api.Result.Failure(s"dist.raw.run failed with an exception. ${e.getMessage()}")
        }
    }
  }

  def bootstrapLauncher = Task {
    build.dist.scripts.millSh.compile0()
  }

  def bootstrapLauncherBat = Task {
    build.dist.scripts.millBat.compile0()
  }

  def examplePaths: Task[Seq[os.Path]] = Task.Input {
    build.example.exampleModules.map(_.moduleDir)
  }

  def examplePathRefs: Task[Seq[PathRef]] =
    Task.traverse(build.example.exampleModules)(_.testRepoRoot)

  def exampleRendered: Task[Seq[PathRef]] =
    Task.traverse(build.example.exampleModules)(_.rendered)

  def exampleParsed: Task[Seq[Seq[Chunk]]] =
    Task.traverse(build.example.exampleModules)(_.parsed)

  def exampleArtifactNames = Task {
    for (path <- examplePaths()) yield {
      val example = path.subRelativeTo(BuildCtx.workspaceRoot)
      val artifactName = example.segments.mkString("-")
      s"${build.dist.artifactFileNamePrefix()}-$artifactName"
    }
  }

  def exampleZips: T[Seq[PathRef]] = Task {
    examplePathRefs().zip(exampleArtifactNames()).zip(exampleRendered()).zip(exampleParsed()).map {
      case (((pr, exampleStr), rendered), parsed) =>
        os.copy(pr.path, Task.dest / exampleStr, createFolders = true)

        // When the `build.mill` contains no Scala or Yaml chunks, it purely serves
        // as the doc-site content and isn't used in the build. So we don't need to include it
        // and cna instead just render the readme.adoc file for people to read
        if (!parsed.exists(c => c.isInstanceOf[Chunk.Scala] || c.isInstanceOf[Chunk.Yaml])) {
          os.remove.all(Task.dest / exampleStr / "build.mill")
          os.copy(rendered.path, Task.dest / exampleStr / "readme.adoc")
        }
        val ignoreErrorsOnCI = Task.dest / exampleStr / "ignoreErrorsOnCI"
        if (os.exists(ignoreErrorsOnCI)) os.remove(ignoreErrorsOnCI)
        val buildMill = Task.dest / exampleStr / "build.mill"
        os.copy.over(bootstrapLauncher().path, Task.dest / exampleStr / "mill")
        os.copy.over(bootstrapLauncherBat().path, Task.dest / exampleStr / "mill.bat")
        val zip = Task.dest / s"$exampleStr.zip"
        os.proc("zip", "-r", zip, exampleStr).call(cwd = Task.dest)
        PathRef(zip)
    }
  }

  def publishArtifacts = Task {
    super.publishArtifacts().copy(payload =
      super.publishArtifacts().payload ++
        exampleZips().map(z => (z, z.path.last)) ++
        Seq(
          (bootstrapLauncher(), s"${artifactFileNamePrefix()}-mill.sh"),
          (bootstrapLauncherBat(), s"${artifactFileNamePrefix()}-mill.bat")
        )
    )
  }

  def artifactName = "mill-" + super.artifactName()

  object native extends mill.scalalib.NativeImageModule with DistModule {
    def finalMainClass = build.dist.raw.finalMainClass()
    def runClasspath = build.dist.raw.runClasspath()
    def artifactOsSuffix = Task {
      val osName = System.getProperty("os.name").toLowerCase
      if (osName.contains("mac")) "mac"
      else if (osName.contains("windows")) "windows"
      else "linux"
    }

    def artifactCpuSuffix = Task {
      System.getProperty("os.arch") match {
        case "x86_64" => "amd64"
        case s => s
      }
    }

    def nativeSuffix = Task { s"${artifactOsSuffix()}-${artifactCpuSuffix()}" }
    def artifactName = Task {
      s"${build.dist.artifactName()}-native-${nativeSuffix()}"
    }

    // Use assembly jar as the upstream ivy classpath rather than using runClasspath
    // directly to try and avoid native image command length problems on windows
    def nativeImageClasspath =
      Seq(build.runner.launcher.resolvedIvyAssembly().pathRef) ++
        build.runner.launcher.upstreamLocalAssemblyClasspath() ++
        build.runner.launcher.localClasspath()

    def localBinName = "mill-native"

    def cacheBinarySuffix = Task.Anon { s"-native-${artifactOsSuffix()}-${artifactCpuSuffix()}" }

    def executableRaw = nativeImage()

    def nativeImageOptions = Seq(
      "--no-fallback",
      "--enable-url-protocols=https",
      "-Os",
      // Build for compatibility with older CPUs that lack AVX2 and other modern features
      // https://github.com/com-lihaoyi/mill/issues/4630
      "-march=compatibility",
      // Allow users to use authenticated proxies
      "-Djdk.http.auth.tunneling.disabledSchemes=",
      // Set UTF-8 encoding to fix Unicode character display issues on Windows
      "-Dfile.encoding=UTF-8",
      "-Dsun.stdout.encoding=UTF-8",
      "-Dsun.stderr.encoding=UTF-8"
      // Enable JVisualVM support
      // https://www.graalvm.org/latest/tools/visualvm/#using-visualvm-with-graalvm-native-executables
      // "--enable-monitoring=jvmstat,heapdump"
    )

    def jvmId = Settings.graalvmJvmId
  }
}
