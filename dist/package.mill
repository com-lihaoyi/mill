package build.dist

import mill.*
import scalalib.*
import publish.*
import mill.api.ModuleRef
import mill.util.Jvm
import mill.testkit.Chunk
//import de.tobiasroeser.mill.vcs.version.VcsVersion
import millbuild.*
import mill.api.BuildCtx
import scala.util.Using
import scala.util.Properties
import java.nio.file.Files
import java.nio.file.attribute.PosixFilePermission

trait DistModule extends Module {
  // All modules that we want to aggregate as part of this `dev` assembly.
  // Excluding itself, and the `dist` module that uses it
  lazy val allPublishModules = build.moduleInternal.modules.collect {
    case m: MillPublishJavaModule => m
  }

  def executableRaw: T[PathRef]

  def localRepo: T[PathRef] = Task {
    val dest = Task.dest
    val repos = Task.traverse(allPublishModules)(m => m.publishLocalTestRepo)().map(_.path)
    for (repo <- repos; elem <- os.list(repo))
      os.copy.into(elem, dest, mergeFolders = true)
    PathRef(dest)
  }

  def executable = Task {
    val rawExecutable = executableRaw()
    if (Properties.isWin) {
      val launcher = Task.dest / "mill.bat"
      val launcherContent =
        s"""@echo off
           |set "NEW_COURSIER_REPOSITORIES=${localRepo().path.toNIO.toUri.toASCIIString}|ivy2Local|central"
           |if defined COURSIER_REPOSITORIES (
           |  set "NEW_COURSIER_REPOSITORIES=%NEW_COURSIER_REPOSITORIES%|%COURSIER_REPOSITORIES%"
           |) else (
           |  set "NEW_COURSIER_REPOSITORIES=%NEW_COURSIER_REPOSITORIES%|ivy2Local|central"
           |)
           |set "COURSIER_REPOSITORIES=%NEW_COURSIER_REPOSITORIES%"
           |set NEW_COURSIER_REPOSITORIES=
           |"${rawExecutable.path.toString.replace("\"", "\\\"")}" %*
           |if errorlevel 1 exit /b %errorlevel%
           |""".stripMargin
      os.write(launcher, launcherContent)
      PathRef(launcher)
    } else {
      val launcher = Task.dest / "mill"
      val launcherContent =
        s"""#!/usr/bin/env bash
           |set -e
           |export COURSIER_REPOSITORIES="${localRepo().path.toNIO.toUri.toASCIIString}|$${COURSIER_REPOSITORIES:-ivy2Local|central}"
           |exec '${rawExecutable.path.toString.replace("'", "\\'")}' "$$@"
           |""".stripMargin
      os.write(launcher, launcherContent)
      val perms = Files.getPosixFilePermissions(launcher.toNIO)
      perms.add(PosixFilePermission.OWNER_EXECUTE)
      perms.add(PosixFilePermission.GROUP_EXECUTE)
      perms.add(PosixFilePermission.OTHERS_EXECUTE)
      Files.setPosixFilePermissions(launcher.toNIO, perms)
      PathRef(launcher)
    }
  }

  def localBinName: String

  def cacheBinarySuffix: Task[String] = Task.Anon("")

  /**
   * Build and install Mill locally.
   *
   * @param binFile The location where the Mill binary should be installed
   */
  def installLocal(binFile: String = localBinName) = {
    val binFile0 = os.Path(binFile, BuildCtx.workspaceRoot)
    Task.Command[Unit] {
      installIvyLocalTask(Task.Anon(binFile0))()
    }
  }

  val batExt = if (scala.util.Properties.isWin) ".bat" else ""

  def installLocalCache() = {

    def launcherPathTask(suffix: Task[String]) =
      Task.Anon {
        os.home / ".cache/mill/download" / (build.millVersion() + suffix() + batExt)
      }

    val jarLauncherPathTask = launcherPathTask(build.dist.cacheBinarySuffix)
    val nativeLauncherPathTask = launcherPathTask(build.dist.native.cacheBinarySuffix)

    Task.Command {
      val Seq(jarLauncherPath, _*) =
        installIvyLocalTask(jarLauncherPathTask, nativeLauncherPathTask)()
      Task.log.streams.out.println(jarLauncherPath.path.toString())
      jarLauncherPath
    }
  }

  def installLocalTask(binFile: Task[String]): Task[os.Path] =
    Task.Anon {
      val targetFile = os.Path(binFile(), BuildCtx.workspaceRoot)
      if (os.exists(targetFile))
        Task.log.info(s"Overwriting existing local Mill binary at ${targetFile}")
      os.copy.over(executable().path, targetFile, createFolders = true)
      Task.log.info(
        s"Published ${build.dist.allPublishModules.size} modules under Mill sources local repo ${localRepo().path} and installed ${targetFile}"
      )
      targetFile
    }

  def installIvyLocalTask(targetFiles: Task[os.Path]*) =
    Task.Anon[Seq[PathRef]] {
      Task.traverse(allPublishModules)(m => m.publishLocal(doc = false))()
      val targetFiles0 = Task.sequence(targetFiles)()
      for (targetFile <- targetFiles0) {
        if (os.exists(targetFile))
          Task.log.info(s"Overwriting existing local Mill binary at $targetFile")
        os.copy.over(executableRaw().path, targetFile, createFolders = true)
      }
      Task.log.info(
        s"Published ${build.dist.allPublishModules.size} modules under ~/.ivy2/local and installed ${targetFiles0.mkString(", ")}"
      )
      targetFiles0.map(PathRef(_))
    }

  def artifactName: T[String]
  def artifact = Task { Artifact(Settings.pomOrg, artifactName(), build.millVersion()) }
  def pomSettings = Task { MillPublishJavaModule.commonPomSettings(artifactName()) }

  def artifactFileNamePrefix = Task { s"${artifactName()}-${build.millVersion()}" }
  def pom: T[PathRef] = Task {
    val pom = Pom(
      artifact = artifact(),
      dependencies = Nil,
      name = artifactName(),
      pomSettings = pomSettings(),
      properties = Map(),
      packagingType = "jar",
      parentProject = None,
      bomDependencies = Nil,
      dependencyManagement = Nil
    )
    val pomPath = Task.dest / s"${artifactFileNamePrefix()}.pom"
    os.write.over(pomPath, pom)
    PathRef(pomPath)
  }

  def publishArtifacts = Task {
    PublishModule.PublishData(
      meta = artifact(),
      payload = Seq(
        executableRaw() -> s"${artifactFileNamePrefix()}.exe",
        pom() -> s"${artifactFileNamePrefix()}.pom"
      )
    )
  }
}

object `package` extends MillJavaModule with DistModule {

  def moduleDeps = Seq(build.runner.launcher)

  def localTestExtraModules =
    allPublishModules

  def localBinName = "mill-assembly.jar"

  private def millClientJvmArgs = Seq(
    // Avoid reserving a lot of memory for the client, as the client only forward information
    "-Xmx128m"
  )

  def launcher = Task {
    val isWin = scala.util.Properties.isWin
    val outputPath = Task.dest / (if (isWin) "run.bat" else "run")

    val launcherForkArgs = testArgs()
    val (millArgs, otherArgs) =
      launcherForkArgs.partition(arg =>
        arg.startsWith("-DMILL") && !arg.startsWith("-DMILL_VERSION")
      )

    // Pass Mill options via file, due to small max args limit in Windows
    val vmOptionsFile = Task.dest / "mill.properties"
    val millOptionsContent = millArgs
      .map(_.drop(2).replace("\\", "/")) // drop -D prefix, replace \ with /
      .mkString("\r\n")

    os.write(vmOptionsFile, millOptionsContent)
    val jvmArgs = otherArgs ++ millClientJvmArgs ++ List(
      s"-DMILL_OPTIONS_PATH=$vmOptionsFile"
    )
    val classpath = runClasspath().map(_.path.toString)
    val classpathJar = Task.dest / "classpath.jar"
    Jvm.createClasspathPassingJar(classpathJar, runClasspath().map(_.path))

    val script = Jvm.launcherUniversalScript(
      mainClass = mainClass().get,
      shellClassPath = classpath,
      cmdClassPath = Seq(classpathJar.toString()),
      jvmArgs = jvmArgs
    )

    os.write(outputPath, script)

    if (!isWin) os.perms.set(outputPath, "rwxrwxrwx")

    PathRef(outputPath)
  }

  def assemblyRules = super.assemblyRules ++ Seq(
    mill.scalalib.Assembly.Rule.ExcludePattern("mill/local-test-overrides/.*")
  )

  def forkArgs = millClientJvmArgs ++ Seq(
    // Workaround for Zinc/JNA bug
    // https://github.com/sbt/sbt/blame/6718803ee6023ab041b045a6988fafcfae9d15b5/main/src/main/scala/sbt/Main.scala#L130
    "-Djna.nosys=true"
  )

  def mainClass = Some("mill.launcher.MillLauncherMain")

  def executableRaw = Task {
    val filename = if (scala.util.Properties.isWin) "mill.bat" else "mill"
    os.copy(assembly().path, Task.dest / filename)
    PathRef(Task.dest / filename)
  }

  def run(args: Task[Args] = Task.Anon(Args())) = Task.Command(exclusive = true) {
    args().value match {
      case Nil => mill.api.Result.Failure("Need to pass in cwd as first argument to dist.run")
      case wd0 +: rest =>
        val wd = os.Path(wd0, BuildCtx.workspaceRoot)
        assert(os.exists(wd), s"Folder $wd does not exist")
        try {
          os.call(
            cmd = (launcher().path.toString, rest),
            env = forkEnv() ++ build.dist.localTestOverridesEnv(),
            cwd = wd,
            stdin = os.Inherit,
            stdout = os.Inherit,
            stderr = os.Inherit
          )
          mill.api.Result.Success(())
        } catch {
          case e: Throwable =>
            mill.api.Result.Failure(s"dist.run failed with an exception. ${e.getMessage()}")
        }
    }
  }

  def bootstrapLauncher = Task {
    build.dist.scripts.millSh.compile0()
  }

  def bootstrapLauncherBat = Task {
    build.dist.scripts.millBat.compile0()
  }

  def examplePaths: Task[Seq[os.Path]] = Task.Input {
    build.example.exampleModules.map(_.moduleDir)
  }

  def examplePathRefs: Task[Seq[PathRef]] =
    Task.traverse(build.example.exampleModules)(_.testRepoRoot)

  def exampleRendered: Task[Seq[PathRef]] =
    Task.traverse(build.example.exampleModules)(_.rendered)

  def exampleParsed: Task[Seq[Seq[Chunk]]] =
    Task.traverse(build.example.exampleModules)(_.parsed)

  def exampleArtifactNames = Task {
    for (path <- examplePaths()) yield {
      val example = path.subRelativeTo(BuildCtx.workspaceRoot)
      val artifactName = example.segments.mkString("-")
      s"${build.dist.artifactFileNamePrefix()}-$artifactName"
    }
  }

  def exampleZips: T[Seq[PathRef]] = Task {
    examplePathRefs().zip(exampleArtifactNames()).zip(exampleRendered()).zip(exampleParsed()).map {
      case (((pr, exampleStr), rendered), parsed) =>
        os.copy(pr.path, Task.dest / exampleStr, createFolders = true)

        // When the `build.mill` contains no Scala or Yaml chunks, it purely serves
        // as the doc-site content and isn't used in the build. So we don't need to include it
        // and cna instead just render the readme.adoc file for people to read
        if (!parsed.exists(c => c.isInstanceOf[Chunk.Scala] || c.isInstanceOf[Chunk.Yaml])) {
          os.remove.all(Task.dest / exampleStr / "build.mill")
          os.copy(rendered.path, Task.dest / exampleStr / "readme.adoc")
        }
        val ignoreErrorsOnCI = Task.dest / exampleStr / "ignoreErrorsOnCI"
        if (os.exists(ignoreErrorsOnCI)) os.remove(ignoreErrorsOnCI)
        val buildMill = Task.dest / exampleStr / "build.mill"
        os.copy.over(bootstrapLauncher().path, Task.dest / exampleStr / "mill")
        os.copy.over(bootstrapLauncherBat().path, Task.dest / exampleStr / "mill.bat")
        val zip = Task.dest / s"$exampleStr.zip"
        os.proc("zip", "-r", zip, exampleStr).call(cwd = Task.dest)
        PathRef(zip)
    }
  }

  def publishArtifacts = Task {
    super.publishArtifacts().copy(payload =
      super.publishArtifacts().payload ++
        exampleZips().map(z => (z, z.path.last)) ++
        Seq(
          (bootstrapLauncher(), s"${artifactFileNamePrefix()}-mill.sh"),
          (bootstrapLauncherBat(), s"${artifactFileNamePrefix()}-mill.bat")
        )
    )
  }

  def artifactName = "mill-" + super.artifactName()

  object native extends mill.scalalib.NativeImageModule with DistModule {
    def finalMainClass = build.dist.finalMainClass()
    def runClasspath = build.dist.runClasspath()
    def artifactOsSuffix = Task {
      val osName = System.getProperty("os.name").toLowerCase
      if (osName.contains("mac")) "mac"
      else if (osName.contains("windows")) "windows"
      else "linux"
    }

    def artifactCpuSuffix = Task {
      System.getProperty("os.arch") match {
        case "x86_64" => "amd64"
        case s => s
      }
    }

    def nativeSuffix = Task { s"${artifactOsSuffix()}-${artifactCpuSuffix()}" }
    def artifactName = Task {
      s"${build.dist.artifactName()}-native-${nativeSuffix()}"
    }

    // Use assembly jar as the upstream ivy classpath rather than using runClasspath
    // directly to try and avoid native image command length problems on windows
    def nativeImageClasspath =
      Seq(build.runner.launcher.resolvedIvyAssembly().pathRef) ++
        build.runner.launcher.upstreamLocalAssemblyClasspath() ++
        build.runner.launcher.localClasspath()

    def localBinName = "mill-native"

    def cacheBinarySuffix = Task.Anon { s"-native-${artifactOsSuffix()}-${artifactCpuSuffix()}" }

    def executableRaw = nativeImage()

    def nativeImageOptions = Seq(
      "--no-fallback",
      "--enable-url-protocols=https",
      "-Os",
      // Allow users to use authenticated proxies
      "-Djdk.http.auth.tunneling.disabledSchemes="
      // Enable JVisualVM support
      // https://www.graalvm.org/latest/tools/visualvm/#using-visualvm-with-graalvm-native-executables
      // "--enable-monitoring=jvmstat,heapdump"
    )

    def jvmId = Settings.graalvmJvmId
  }
}
