<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Tasks :: The Mill Build Tool</title>
    <link rel="canonical" href="https://mill-build.org/mill/0.11.12/Tasks.html" />
    <link rel="prev" href="query-syntax.html" />
    <link rel="next" href="modules.html" />
    <meta name="generator" content="Antora 3.1.9" />
    <link rel="stylesheet" href="../../_/css/site.css" />
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-1C582ZJR85"></script>
    <script>function gtag(){dataLayer.push(arguments)};window.dataLayer=window.dataLayer||[];gtag('js',new Date());gtag('config','G-1C582ZJR85')</script>
<link rel="icon" href="../../_/favicon.png" type="image/x-icon" />
  
  </head><body class="article">
  
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <!-- TODO: add mill icon -->
      <a class="navbar-item" href="https://mill-build.org"><img src="../../_/logo-white.svg" height="20" /> The Mill Build Tool</a>
      <div class="navbar-item search">
        <input id="search-input" type="text" placeholder="Search the docs" />
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/com-lihaoyi/mill">Source Code (GitHub)</a>
        <a class="navbar-item" href="https://mill-build.org/api/latest/index.html">API</a>
        <a class="navbar-item" href="https://github.com/com-lihaoyi/mill/issues">Issues</a>
        <a class="navbar-item" href="https://github.com/com-lihaoyi/mill/discussions">Discuss</a>
        <a class="navbar-item" href="https://discord.gg/MNAXQMAr">Chat</a>

            <!--
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Documentation</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#"></a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Plugins</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Resource A</a>
            <a class="navbar-item" href="#">Resource B</a>
            <a class="navbar-item" href="#">Resource C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
        -->
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="mill" data-version="master">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
<ul class="nav-list">

  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../javalib/intro.html">Building Java Projects with Mill</a>
<ul class="nav-list">

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../javalib/installation-ide.html">Installation and IDE Support</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../javalib/builtin-commands.html">Built-in Commands</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../javalib/module-config.html">Java Module Configuration</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../javalib/dependencies.html">Java Library Dependencies</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../javalib/testing.html">Testing Java Projects</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../javalib/linting.html">Linting Java Projects</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../javalib/publishing.html">Publishing Java Projects</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../javalib/build-examples.html">Java Build Examples</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../javalib/web-examples.html">Java Web Examples</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../javalib/android-examples.html">(Experimental) Android Builds</a>
  </li>
</ul>
  </li>

  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../scalalib/intro.html">Building Scala Projects with Mill</a>
<ul class="nav-list">

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../scalalib/installation-ide.html">Installation and IDE Support</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../scalalib/builtin-commands.html">Built-in Commands</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../scalalib/module-config.html">Scala Module Configuration</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../scalalib/dependencies.html">Scala Library Dependencies</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../scalalib/testing.html">Testing Scala Projects</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../scalalib/linting.html">Linting Scala Projects</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../scalalib/publishing.html">Publishing Scala Projects</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../scalalib/build-examples.html">Scala Build Examples</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../scalalib/web-examples.html">Scala Web Examples</a>
  </li>
</ul>
  </li>

  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../kotlinlib/intro.html">(Experimental) Kotlin with Mill</a>
<ul class="nav-list">

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../kotlinlib/installation-ide.html">Installation and IDE Support</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../kotlinlib/builtin-commands.html">Built-in Commands</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../kotlinlib/module-config.html">Kotlin Module Configuration</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../kotlinlib/dependencies.html">Kotlin Library Dependencies</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../kotlinlib/testing.html">Testing Kotlin Projects</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../kotlinlib/linting.html">Linting Kotlin Projects</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../kotlinlib/publishing.html">Publishing Kotlin Projects</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../kotlinlib/build-examples.html">Kotlin Build Examples</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../kotlinlib/web-examples.html">Kotlin Web Examples</a>
  </li>
</ul>
  </li>

  <li class="nav-item is-active" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Build Tool Comparisons</span>
<ul class="nav-list">

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../comparisons/maven.html">Case Study: Mill vs Maven</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../comparisons/gradle.html">Case Study: Mill vs Gradle</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../comparisons/sbt.html">Case Study: Mill vs SBT</a>
  </li>
</ul>
  </li>

  <li class="nav-item is-active" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Mill Fundamentals</span>
<ul class="nav-list">

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="library-deps.html">Library Dependencies in Mill</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="out-dir.html">The Output Directory</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="query-syntax.html">Task Query Syntax</a>
  </li>

  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="tasks.html">Tasks</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="modules.html">Modules</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="cross-builds.html">Cross Builds</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="bundled-libraries.html">Bundled Libraries</a>
  </li>
</ul>
  </li>

  <li class="nav-item is-active" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Extending Mill</span>
<ul class="nav-list">

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../extending/import-ivy.html">import $ivy</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../extending/using-plugins.html">Using Plugins</a>
  </li>

  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../extending/contrib-plugins.html">Contrib Plugins</a>
<ul class="nav-list">

  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../contrib/artifactory.html">Artifactory</a>
  </li>

  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../contrib/bintray.html">Bintray</a>
  </li>

  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../contrib/bloop.html">Bloop</a>
  </li>

  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../contrib/buildinfo.html">BuildInfo</a>
  </li>

  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../contrib/codeartifact.html">Codeartifact</a>
  </li>

  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../contrib/docker.html">Docker</a>
  </li>

  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../contrib/flyway.html">Flyway</a>
  </li>

  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../contrib/gitlab.html">Gitlab</a>
  </li>

  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../contrib/jmh.html">JMH</a>
  </li>

  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../contrib/playlib.html">Play Framework</a>
  </li>

  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../contrib/proguard.html">Proguard</a>
  </li>

  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../contrib/scalapblib.html">ScalaPB</a>
  </li>

  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../contrib/scoverage.html">Scoverage</a>
  </li>

  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../contrib/sonatypecentral.html">Sonatype Central</a>
  </li>

  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../contrib/testng.html">TestNG</a>
  </li>

  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../contrib/twirllib.html">Twirl</a>
  </li>

  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../contrib/versionfile.html">Version file</a>
  </li>
</ul>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../extending/thirdparty-plugins.html">Third-Party Plugins</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../extending/writing-plugins.html">Writing Mill Plugins</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../extending/meta-build.html">The Mill Meta-Build</a>
  </li>
</ul>
  </li>

  <li class="nav-item is-active" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Mill In Depth</span>
<ul class="nav-list">

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../depth/large-builds.html">Structuring Large Builds</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../depth/sandboxing.html">Mill Sandboxing</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../depth/evaluation-model.html">The Mill Evaluation Model</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../depth/design-principles.html">Mill Design Principles</a>
  </li>
</ul>
  </li>

  <li class="nav-item is-active" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Reference</span>
<ul class="nav-list">

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="https://mill-build.org/api/latest/mill/index.html">Mill Scaladoc</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../reference/changelog.html">Changelog</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Mill Documentation</a></li>
    <li>Mill Fundamentals</li>
    <li><a href="tasks.html">Tasks</a></li>
  </ul>
</nav>
<div class="page-versions">
  <button class="version-menu-toggle" title="Show other versions of page">0.12.0-RC3-12-4d5976</button>
  <div class="version-menu">
    <a class="version is-current" href="tasks.html">0.12.0-RC3-12-4d5976</a>
    <a class="version" href="../0.11.12/Tasks.html">0.11.12</a>
    <a class="version" href="../0.11.11/Tasks.html">0.11.11</a>
    <a class="version" href="../0.11.10/Tasks.html">0.11.10</a>
    <a class="version" href="../0.11.0-M7/Tasks.html">0.11.0-M7</a>
    <a class="version" href="../0.10.15/Tasks.html">0.10.15</a>
    <a class="version" href="../0.10.12/Tasks.html">0.10.12</a>
    <a class="version" href="../0.10.0/Tasks.html">0.10.0</a>
    <a class="version" href="../0.9.12/Tasks.html">0.9.12</a>
  </div>
</div>
<div class="edit-this-page"><a href="https://github.com/com-lihaoyi/mill/edit/main/docs/modules/ROOT/pages/fundamentals/tasks.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Tasks</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>One of Mill’s core abstractions is its <em>Task Graph</em>: this is how Mill defines,
orders and caches work it needs to do, and exists independently of any support
for building Scala.</p>
</div>
<div class="paragraph">
<p>Mill task graphs are primarily built using methods and macros defined on
<code>mill.define.Task</code>, aliased as <code>T</code> for conciseness:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://mill-build.org/api/latest/mill/define/Task$.html">mill.define.Task</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_task_cheat_sheet"><a class="anchor" href="#_task_cheat_sheet"></a>Task Cheat Sheet</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following table might help you make sense of the small collection of
different Task types:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 14.2857%;" />
<col style="width: 14.2857%;" />
<col style="width: 14.2857%;" />
<col style="width: 14.2857%;" />
<col style="width: 14.2857%;" />
<col style="width: 14.2857%;" />
<col style="width: 14.2858%;" />
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">Target</th>
<th class="tableblock halign-left valign-top">Command</th>
<th class="tableblock halign-left valign-top">Source/Input</th>
<th class="tableblock halign-left valign-top">Anonymous Task</th>
<th class="tableblock halign-left valign-top">Persistent Target</th>
<th class="tableblock halign-left valign-top">Worker</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cached to Disk</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON Writable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON Readable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CLI Runnable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Takes Arguments</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cached In-Memory</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following is a simple self-contained example using Mill to compile Java:</p>
</div>
<div class="listingblock">
<div class="title">build.mill (<a href="https://github.com/com-lihaoyi/mill/releases/download/0.12.0-RC3/0.12.0-RC3-example-fundamentals-tasks-1-task-graph.zip">download</a>, <a href="https://github.com/com-lihaoyi/mill/blob/0.12.0-RC3//example/fundamentals/tasks/1-task-graph">browse</a>)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">package build
import mill._

def mainClass: T[Option[String]] = Some(&quot;foo.Foo&quot;)

def sources = Task.Source(millSourcePath / &quot;src&quot;)
def resources = Task.Source(millSourcePath / &quot;resources&quot;)

def compile = Task {
  val allSources = os.walk(sources().path)
  os.proc(&quot;javac&quot;, allSources, &quot;-d&quot;, Task.dest).call()
  PathRef(Task.dest)
}

def assembly = Task {
  for(p &lt;- Seq(compile(), resources())) os.copy(p.path, Task.dest, mergeFolders = true)

  val mainFlags = mainClass().toSeq.flatMap(Seq(&quot;-e&quot;, _))
  os.proc(&quot;jar&quot;, &quot;-c&quot;, mainFlags, &quot;-f&quot;, Task.dest / s&quot;assembly.jar&quot;, &quot;.&quot;)
    .call(cwd = Task.dest)

  PathRef(Task.dest / s&quot;assembly.jar&quot;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This code defines the following task graph, with the boxes being the tasks
and the arrows representing the <em>data-flow</em> between them:</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="../_images/diag-1e660bf848df31ec317c586edab4c21b759d5efb.svg" alt="Diagram" />
</div>
</div>
<div class="paragraph">
<p>This example does not use any of Mill’s builtin support for building Java or
Scala projects, and instead builds a pipeline &quot;from scratch&quot; using Mill
tasks and <code>javac</code>/<code>jar</code>/<code>java</code> subprocesses. We define <code>Task.Source</code> folders,
plain <code>T{…​}</code> tasks that depend on them, and a <code>Task.Command</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">&gt; ./mill show assembly
&quot;.../out/assembly.dest/assembly.jar&quot;

&gt; java -jar out/assembly.dest/assembly.jar i am cow
Foo.value: 31337
args: i am cow

&gt; unzip -p out/assembly.dest/assembly.jar foo.txt
My Example Text</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you first evaluate <code>assembly</code> (e.g. via <code>mill assembly</code> at the command
line), it will evaluate all the defined tasks: <code>mainClass</code>, <code>sources</code>,
<code>compile</code>, and <code>assembly</code>.</p>
</div>
<div class="paragraph">
<p>Subsequent invocations of <code>mill assembly</code> will evaluate only as much as is
necessary, depending on what input sources changed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the files in <code>sources</code> change, it will re-evaluate
<code>compile</code>, and <code>assembly</code> (red)</p>
</li>
</ul>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="../_images/diag-feb2f2204c8b398ddb70d61d78da9c03a677ca2b.svg" alt="Diagram" />
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>If the files in <code>resources</code> change, it will only re-evaluate <code>assembly</code> (red)
and use the cached output of <code>compile</code> (green)</p>
</li>
</ul>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="../_images/diag-3381ff258d3393d8bb232659a19756c527479aa9.svg" alt="Diagram" />
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="primitive-tasks"><a class="anchor" href="#primitive-tasks"></a>Primary Tasks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are three primary kinds of <em>Tasks</em> that you should care about:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#_sources">Sources</a>, defined using <code>Task.Sources {…​}</code></p>
</li>
<li>
<p><a href="#_tasks">[_tasks]</a>, defined using <code>Task {…​}</code></p>
</li>
<li>
<p><a href="#_commands">Commands</a>, defined using <code>Task.Command {…​}</code></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_sources"><a class="anchor" href="#_sources"></a>Sources</h3>
<div class="listingblock">
<div class="title">build.mill (<a href="https://github.com/com-lihaoyi/mill/releases/download/0.12.0-RC3/0.12.0-RC3-example-fundamentals-tasks-2-primary-tasks.zip">download</a>, <a href="https://github.com/com-lihaoyi/mill/blob/0.12.0-RC3//example/fundamentals/tasks/2-primary-tasks">browse</a>)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">package build

import mill.{Module, T, _}

def sources = Task.Source { millSourcePath / &quot;src&quot; }
def resources = Task.Source { millSourcePath / &quot;resources&quot; }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Source</code>s are defined using <code>Task.Source{…​}</code> taking one <code>os.Path</code>, or <code>Task.Sources{…​}</code>,
taking multiple <code>os.Path</code>s as arguments. A <code>Source</code>'s':
its build signature/<code>hashCode</code> depends not just on the path
it refers to (e.g. <code>foo/bar/baz</code>) but also the MD5 hash of the filesystem
tree under that path.</p>
</div>
<div class="paragraph">
<p><code>Task.Source</code> and <code>Task.Sources</code> are most common inputs in any Mill build:
they watch source files and folders and cause downstream tasks to
re-compute if a change is detected.</p>
</div>
</div>
<div class="sect2">
<h3 id="_targets"><a class="anchor" href="#_targets"></a>Targets</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">def allSources = Task {
  os.walk(sources().path)
    .filter(_.ext == &quot;java&quot;)
    .map(PathRef(_))
}

def lineCount: T[Int] = Task {
  println(&quot;Computing line count&quot;)
  allSources()
    .map(p =&gt; os.read.lines(p.path).size)
    .sum
}</code></pre>
</div>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="../_images/diag-33a0725be37eddc6658f9d8c1d80f8735c88f881.svg" alt="Diagram" />
</div>
</div>
<div class="paragraph">
<p><code>Target</code>s are defined using the <code>def foo = Task {…​}</code> syntax, and dependencies
on other tasks are defined using <code>foo()</code> to extract the value from them.
Apart from the <code>foo()</code> calls, the <code>Task {…​}</code> block contains arbitrary code that
does some work and returns a result.</p>
</div>
<div class="paragraph">
<p>The <code>os.walk</code> and <code>os.read.lines</code> statements above are from the
<a href="https://github.com/com-lihaoyi/os-lib">OS-Lib</a> library, which provides all common
filesystem and subprocess operations for Mill builds. You can see the OS-Lib library
documentation for more details:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/com-lihaoyi/os-lib">OS-Lib Library Documentation</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a target’s inputs change but its output does not, e.g. someone changes a
comment within the source files that doesn’t affect the classfiles, then
downstream tasks do not re-evaluate. This is determined using the
<code>.hashCode</code> of the Target’s return value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">&gt; ./mill show lineCount
Computing line count
16

&gt; ./mill show lineCount # line count already cached, doesn't need to be computed
16</code></pre>
</div>
</div>
<div class="paragraph">
<p>Furthermore, when code changes occur, targets only invalidate if the code change
may directly or indirectly affect it. e.g. adding a comment to <code>lineCount</code> will
not cause it to recompute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-diff hljs" data-lang="diff"> def lineCount: T[Int] = Task {
  println(&quot;Computing line count&quot;)
+  // Hello World
  allSources()
    .map(p =&gt; os.read.lines(p.path).size)
    .sum</code></pre>
</div>
</div>
<div class="paragraph">
<p>But changing the code of the target or any upstream helper method will cause the
old value to be invalidated and a new value re-computed (with a new <code>println</code>)
next time it is invoked:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-diff hljs" data-lang="diff">  def lineCount: T[Int] = Task {
-  println(&quot;Computing line count&quot;)
+  println(&quot;Computing line count!!!&quot;)
  allSources()
    .map(p =&gt; os.read.lines(p.path).size)
    .sum</code></pre>
</div>
</div>
<div class="paragraph">
<p>For more information on how the bytecode analysis necessary for invalidating targets
based on code-changes work, see <a href="https://github.com/com-lihaoyi/mill/pull/2417">PR#2417</a>
that implemented it.</p>
</div>
<div class="paragraph">
<p>The return-value of targets has to be JSON-serializable via
<a href="https://github.com/com-lihaoyi/upickle">uPickle</a>. You can run targets directly from the command
line, or use <code>show</code> if you want to see the JSON content or pipe it to
external tools. See the uPickle library documentation for more details:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/com-lihaoyi/upickle">uPickle Library Documentation</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_task_dest"><a class="anchor" href="#_task_dest"></a>Task.dest</h4>
<div class="paragraph">
<p>Each task, e.g. <code>classFiles</code>, is assigned a <a href="https://mill-build.org/api/latest/mill/api/Ctx.html#dest:os.Path">Task.dest</a>
folder e.g. <code>out/classFiles.dest/</code> on disk as scratch space &amp; to store its
output files , and its returned metadata is automatically JSON-serialized
and stored at <code>out/classFiles.json</code>. If you want to return a file or a set
of files as the result of a <code>Task</code>, write them to disk within your <code>Task.dest</code>
folder and return a <code>PathRef()</code> that referencing the files or folders
you want to return:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">def classFiles = Task {
  println(&quot;Generating classfiles&quot;)

  os.proc(&quot;javac&quot;, allSources().map(_.path), &quot;-d&quot;, Task.dest)
    .call(cwd = Task.dest)

  PathRef(Task.dest)
}

def jar = Task {
  println(&quot;Generating jar&quot;)
  os.copy(classFiles().path, Task.dest, mergeFolders = true)
  os.copy(resources().path, Task.dest, mergeFolders = true)

  os.proc(&quot;jar&quot;, &quot;-cfe&quot;, Task.dest / &quot;foo.jar&quot;, &quot;foo.Foo&quot;, &quot;.&quot;).call(cwd = Task.dest)

  PathRef(Task.dest / &quot;foo.jar&quot;)
}</code></pre>
</div>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="../_images/diag-df1a84c313e8b66679e19b33303e6f9bfa93e69b.svg" alt="Diagram" />
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">&gt; ./mill jar
Generating classfiles
Generating jar

&gt; ./mill show jar
&quot;.../out/jar.dest/foo.jar&quot;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Note that <code>os.pwd</code> of the Mill process is set to an empty <code>sandbox/</code> folder by default.</strong>
This is to stop you from accidentally reading and writing files to the base repository root,
which would cause problems with Mill’s caches not invalidating properly or files from different
tasks colliding and causing issues.
You should never use <code>os.pwd</code> or rely on the process working directory, and always explicitly
use <code>Task.dest</code> or the <code>.path</code> of upstream <code>PathRef</code>s when accessing files. In the rare case where
you truly need the Mill project root folder, you can access it via <code>Task.workspace</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_dependent_tasks"><a class="anchor" href="#_dependent_tasks"></a>Dependent Tasks</h4>
<div class="paragraph">
<p>Tasks can depend on other tasks via the <code>foo()</code> syntax.
The graph of inter-dependent tasks is evaluated in topological order; that
means that the body of a task will not even begin to evaluate if one of its
upstream dependencies has failed. Similar, even if the upstream tasks is
not used in one branch of an <code>if</code> condition, it will get computed regardless
before the <code>if</code> condition is even considered.</p>
</div>
<div class="paragraph">
<p>The following example demonstrates this behavior, with the <code>println</code> defined
in <code>def largeFile</code> running even though the <code>largeFile()</code> branch of the
<code>if</code> conditional does not get used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">def largeFile = Task {
  println(&quot;Finding Largest File&quot;)
  allSources()
    .map(_.path)
    .filter(_.ext == &quot;java&quot;)
    .maxBy(os.read.lines(_).size)
}

def hugeFileName = Task {
  if (lineCount() &gt; 999) largeFile().last
  else &quot;&lt;no-huge-file&gt;&quot;
}</code></pre>
</div>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="../_images/diag-51dc4c55a8a863d078baaddc299357e759363bd4.svg" alt="Diagram" />
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">&gt; ./mill show lineCount
16

&gt; ./mill show hugeFileName # This still runs `largestFile` even though `lineCount() &lt; 999`
Finding Largest File
&quot;&lt;no-huge-file&gt;&quot;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_custom_types"><a class="anchor" href="#_custom_types"></a>Custom Types</h4>
<div class="paragraph">
<p>uPickle comes with built-in support for most Scala primitive types and
builtin data structures: tuples, collections, <code>PathRef</code>s, etc. can be
returned and automatically serialized/de-serialized as necessary. One
notable exception is <code>case class</code>es: if you want return your own
<code>case class</code>, you must mark it JSON-serializable by adding the following
<code>implicit</code> to its companion object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">case class ClassFileData(totalFileSize: Long, largestFile: String)
object ClassFileData {
  implicit val rw: upickle.default.ReadWriter[ClassFileData] = upickle.default.macroRW
}

def summarizeClassFileStats = Task {
  val files = os.walk(classFiles().path)
  ClassFileData(
    totalFileSize = files.map(os.size(_)).sum,
    largestFile = files.maxBy(os.size(_)).last
  )
}</code></pre>
</div>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="../_images/diag-92644512b00b3ff050cbcf980292a049ec819fa5.svg" alt="Diagram" />
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">&gt; ./mill show summarizeClassFileStats
{
  &quot;totalFileSize&quot;: ...,
  &quot;largestFile&quot;: &quot;...&quot;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_commands"><a class="anchor" href="#_commands"></a>Commands</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">def run(mainClass: String, args: String*) = Task.Command {
  os.proc(
      &quot;java&quot;,
      &quot;-cp&quot;, s&quot;${classFiles().path}:${resources().path}&quot;,
      mainClass,
      args
    )
    .call(stdout = os.Inherit)
}</code></pre>
</div>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="../_images/diag-435d38aa16feb53ce9c5c3696bfc41c46d8d8cae.svg" alt="Diagram" />
</div>
</div>
<div class="paragraph">
<p>Defined using <code>Task.Command {…​}</code> syntax, <code>Command</code>s can run arbitrary code, with
dependencies declared using the same <code>foo()</code> syntax (e.g. <code>classFiles()</code> above).
Commands can be parametrized, but their output is not cached, so they will
re-evaluate every time even if none of their inputs have changed.
A command with no parameter is defined as <code>def myCommand() = Task.Command {…​}</code>.
It is a compile error if <code>()</code> is missing.</p>
</div>
<div class="paragraph">
<p>Tasks can take command line params, parsed by the <a href="https://github.com/com-lihaoyi/mainargs">MainArgs</a>
library. Thus the signature <code>def run(mainClass: String, args: String*)</code> takes
params of the form <code>--main-class &lt;str&gt; &lt;arg1&gt; &lt;arg2&gt; …​ &lt;argn&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">&gt; ./mill run --main-class foo.Foo hello world
Foo.value: 31337
args: hello world
foo.txt resource: My Example Text</code></pre>
</div>
</div>
<div class="paragraph">
<p>Command line arguments can take most primitive types: <code>String</code>, <code>Int</code>, <code>Boolean</code>, etc.,
along with <code>Option[T]</code> representing optional values and <code>Seq[T]</code> representing repeatable values,
and <code>mainargs.Flag</code> representing flags and <code>mainargs.Leftover[T]</code> representing any command line
arguments not parsed earlier. Default values for command line arguments are also supported.
See the mainargs documentation for more details:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[MainArgs Library Documentation](<a href="https://github.com/com-lihaoyi/mainargs">MainArgs</a>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By default, all command parameters need to be named, except for variadic parameters
of type <code>T*</code> or <code>mainargs.Leftover[T]</code>. You can use the flag <code>--allow-positional-command-args</code>
to allow arbitrary arguments to be passed positionally, as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">&gt; ./mill run foo.Foo hello world # this raises an error because `--main-class` is not given
error: Missing argument: --mainClass &lt;str&gt;
Expected Signature: run
  --mainClass &lt;str&gt;
  args &lt;str&gt;...
...

&gt; ./mill --allow-positional run foo.Foo hello world # this succeeds due to --allow-positional
Foo.value: 31337
args: hello world
foo.txt resource: My Example Text</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like <a href="#_targets">Targets</a>, a command only evaluates after all its upstream
dependencies have completed, and will not begin to run if any upstream
dependency has failed.</p>
</div>
<div class="paragraph">
<p>Commands are assigned the same scratch/output folder <code>out/run.dest/</code> as
Tasks are, and its returned metadata stored at the same <code>out/run.json</code>
path for consumption by external tools.</p>
</div>
<div class="paragraph">
<p>Commands can only be defined directly within a <code>Module</code> body.</p>
</div>
</div>
<div class="sect2">
<h3 id="_overrides"><a class="anchor" href="#_overrides"></a>Overrides</h3>
<div class="paragraph">
<p>Tasks can be overriden, with the overriden task callable via <code>super</code>.
You can also override a task with a different type of task, e.g. below
we override <code>sourceRoots</code> which is a <code>Task.Sources</code> with a <code>Task{}</code> target:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">trait Foo extends Module {
  def sourceRoots = Task.Sources(millSourcePath / &quot;src&quot;)
  def sourceContents = Task {
    sourceRoots()
      .flatMap(pref =&gt; os.walk(pref.path))
      .filter(_.ext == &quot;txt&quot;)
      .sorted
      .map(os.read(_))
  }
}

trait Bar extends Foo {
  def additionalSources = Task.Sources(millSourcePath / &quot;src2&quot;)
  def sourceRoots = Task { super.sourceRoots() ++ additionalSources() }
}

object bar extends Bar</code></pre>
</div>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="../_images/diag-33412e17b2bcfe88a8e185a846ec073a5f9cdc41.svg" alt="Diagram" />
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">&gt; ./mill show bar.sourceContents # includes both source folders
[
  &quot;File Data From src/&quot;,
  &quot;File Data From src2/&quot;
]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_other_tasks"><a class="anchor" href="#_other_tasks"></a>Other Tasks</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_anonymous_tasks"><a class="anchor" href="#_anonymous_tasks"></a>Anonymous Tasks</h3>
<div class="listingblock">
<div class="title">build.mill (<a href="https://github.com/com-lihaoyi/mill/releases/download/0.12.0-RC3/0.12.0-RC3-example-fundamentals-tasks-3-anonymous-tasks.zip">download</a>, <a href="https://github.com/com-lihaoyi/mill/blob/0.12.0-RC3//example/fundamentals/tasks/3-anonymous-tasks">browse</a>)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">package build
import mill._, define.Task

def data = Task.Source(millSourcePath / &quot;data&quot;)

def anonTask(fileName: String): Task[String] = Task.Anon {
  os.read(data().path / fileName)
}

def helloFileData = Task { anonTask(&quot;hello.txt&quot;)() }
def printFileData(fileName: String) = Task.Command {
  println(anonTask(fileName)())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can define anonymous tasks using the <code>Task.Anon {…​}</code> syntax. These are
not runnable from the command-line, but can be used to share common code you
find yourself repeating in <code>Task</code>s and <code>Command</code>s.</p>
</div>
<div class="paragraph">
<p>Anonymous task’s output does not need to be JSON-serializable, their output is
not cached, and they can be defined with or without arguments.
Unlike <a href="#_targets">Targets</a> or <a href="#_commands">Commands</a>, anonymous tasks can be defined
anywhere and passed around any way you want, until you finally make use of them
within a downstream task or command.</p>
</div>
<div class="paragraph">
<p>While an anonymous task <code>foo</code>'s own output is not cached, if it is used in a
downstream task <code>baz</code> and the upstream task <code>bar</code> hasn’t changed,
<code>baz</code>'s cached output will be used and <code>foo</code>'s evaluation will be skipped
altogether.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">&gt; ./mill show helloFileData
&quot;Hello&quot;

&gt; ./mill printFileData --file-name hello.txt
Hello

&gt; ./mill printFileData --file-name world.txt
World!</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_inputs"><a class="anchor" href="#_inputs"></a>Inputs</h3>
<div class="listingblock">
<div class="title">build.mill (<a href="https://github.com/com-lihaoyi/mill/releases/download/0.12.0-RC3/0.12.0-RC3-example-fundamentals-tasks-4-inputs.zip">download</a>, <a href="https://github.com/com-lihaoyi/mill/blob/0.12.0-RC3//example/fundamentals/tasks/4-inputs">browse</a>)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">package build
import mill._

def myInput = Task.Input {
  os.proc(&quot;git&quot;, &quot;rev-parse&quot;, &quot;HEAD&quot;).call(cwd = Task.workspace)
    .out
    .text()
    .trim()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A generalization of <a href="#_sources">Sources</a>, <code>Task.Input</code>s are tasks that re-evaluate
<em>every time</em> (unlike <a href="#_anonymous_tasks">Anonymous Tasks</a>), containing an
arbitrary block of code.</p>
</div>
<div class="paragraph">
<p>Inputs can be used to force re-evaluation of some external property that may
affect your build. For example, if I have a <a href="#_targets">Target</a> <code>bar</code> that
calls out to <code>git</code> to compute the latest commit hash and message directly,
that target does not have any <code>Task</code> inputs and so will never re-compute
even if the external <code>git</code> status changes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">def gitStatusTask = Task {
  &quot;v-&quot; +
  os.proc(&quot;git&quot;, &quot;log&quot;, &quot;-1&quot;, &quot;--pretty=format:%h-%B &quot;)
    .call(cwd = Task.workspace)
    .out
    .text()
    .trim()
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">&gt; git init .
&gt; git commit --allow-empty -m &quot;Initial-Commit&quot;

&gt; ./mill show gitStatusTask
&quot;v-...-Initial-Commit&quot;

&gt; git commit --allow-empty -m &quot;Second-Commit&quot;

&gt; ./mill show gitStatusTask # Mill didn't pick up the git change!
&quot;v-...-Initial-Commit&quot;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gitStatusTask</code> will not know that <code>git rev-parse</code> can change, and will
not know to re-evaluate when your <code>git log</code> <em>does</em> change. This means
<code>gitStatusTask</code> will continue to use any previously cached value, and
<code>gitStatusTask</code>'s output will  be out of date!</p>
</div>
<div class="paragraph">
<p>To fix this, you can wrap your <code>git log</code> in a <code>Task.Input</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">def gitStatusInput = Task.Input {
  os.proc(&quot;git&quot;, &quot;log&quot;, &quot;-1&quot;, &quot;--pretty=format:%h-%B &quot;)
    .call(cwd = Task.workspace)
    .out
    .text()
    .trim()
}
def gitStatusTask2 = Task { &quot;v-&quot; + gitStatusInput() }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This makes <code>gitStatusInput</code> to always re-evaluate every build, and only if
the output of <code>gitStatusInput</code> changes will <code>gitStatusTask2</code> re-compute</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">&gt; git commit --allow-empty -m &quot;Initial-Commit&quot;

&gt; ./mill show gitStatusTask2
&quot;v-...-Initial-Commit&quot;

&gt; git commit --allow-empty -m &quot;Second-Commit&quot;

&gt; ./mill show gitStatusTask2 # Mill picked up git change
&quot;v-...-Second-Commit&quot;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that because <code>Task.Input</code>s re-evaluate every time, you should ensure that the
code you put in <code>Task.Input</code> runs quickly. Ideally it should just be a simple check
&quot;did anything change?&quot; and any heavy-lifting should be delegated to downstream
tasks where it can be cached if possible.</p>
</div>
</div>
<div class="sect2">
<h3 id="_persistent_tasks"><a class="anchor" href="#_persistent_tasks"></a>Persistent Tasks</h3>
<div class="paragraph">
<p>Persistent targets defined using <code>Task(Persistent = True)</code> are similar to normal
<code>Target</code>s, except their <code>Task.dest</code> folder is not cleared before every
evaluation. This makes them useful for caching things on disk in a more
fine-grained manner than Mill’s own Target-level caching.</p>
</div>
<div class="paragraph">
<p>Below is a semi-realistic example of using a <code>Task(Persistent = True)</code> target:</p>
</div>
<div class="listingblock">
<div class="title">build.mill (<a href="https://github.com/com-lihaoyi/mill/releases/download/0.12.0-RC3/0.12.0-RC3-example-fundamentals-tasks-5-persistent-tasks.zip">download</a>, <a href="https://github.com/com-lihaoyi/mill/blob/0.12.0-RC3//example/fundamentals/tasks/5-persistent-tasks">browse</a>)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">package build
import mill._, scalalib._
import java.util.Arrays
import java.io.ByteArrayOutputStream
import java.util.zip.GZIPOutputStream

def data = Task.Source(millSourcePath / &quot;data&quot;)

def compressedData = Task(persistent = true) {
  println(&quot;Evaluating compressedData&quot;)
  os.makeDir.all(Task.dest / &quot;cache&quot;)
  os.remove.all(Task.dest / &quot;compressed&quot;)

  for(p &lt;- os.list(data().path)){
    val compressedPath = Task.dest / &quot;compressed&quot; / s&quot;${p.last}.gz&quot;
    val bytes = os.read.bytes(p)
    val hash = Arrays.hashCode(bytes)
    val cachedPath = Task.dest / &quot;cache&quot; / hash.toHexString
    if (!os.exists(cachedPath)) {
      println(&quot;Compressing: &quot; + p.last)
      os.write(cachedPath, compressBytes(bytes))
    } else {
      println(&quot;Reading Cached from disk: &quot; + p.last)
    }
    os.copy(cachedPath, compressedPath, createFolders = true)
  }

  os.list(Task.dest / &quot;compressed&quot;).map(PathRef(_))
}

def compressBytes(input: Array[Byte]) = {
  val bos = new ByteArrayOutputStream(input.length)
  val gzip = new GZIPOutputStream(bos)
  gzip.write(input)
  gzip.close()
  bos.toByteArray
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, we implement a <code>compressedData</code> task that takes a folder
of files in <code>inputData</code> and compresses them, while maintaining a cache of
compressed contents for each file. That means that if the <code>inputData</code> folder
is modified, but some files remain unchanged, those files would not be
unnecessarily re-compressed when <code>compressedData</code> evaluates.</p>
</div>
<div class="paragraph">
<p>Since persistent tasks have long-lived state on disk that lives beyond a
single evaluation, this raises the possibility of the disk contents getting
into a bad state and causing all future evaluations to fail. It is left up
to the person implementing the <code>Task(Persistent = True)</code> to ensure their implementation
is eventually consistent. You can also use <code>mill clean</code> to manually purge
the disk contents to start fresh.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">&gt; ./mill show compressedData
Evaluating compressedData
Compressing: hello.txt
Compressing: world.txt
[
  &quot;.../hello.txt.gz&quot;,
  &quot;.../world.txt.gz&quot;
]

&gt; ./mill compressedData # when no input changes, compressedData does not evaluate at all

&gt; sed -i.bak 's/Hello/HELLO/g' data/hello.txt

&gt; ./mill compressedData # when one input file changes, only that file is re-compressed
Compressing: hello.txt
Reading Cached from disk: world.txt

&gt; ./mill clean compressedData

&gt; ./mill compressedData
Evaluating compressedData
Compressing: hello.txt
Compressing: world.txt</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_workers"><a class="anchor" href="#_workers"></a>Workers</h3>
<div class="paragraph">
<p>Mill workers defined using <code>Task.Worker</code> are long-lived in-memory objects that
can persistent across multiple evaluations. These are similar to persistent
tasks in that they let you cache things, but the fact that they let you
cache the worker object in-memory allows for greater performance and
flexibility: you are no longer limited to caching only serializable data
and paying the cost of serializing it to disk every evaluation. This example
uses a Worker to provide simple in-memory caching for compressed files.</p>
</div>
<div class="listingblock">
<div class="title">build.mill (<a href="https://github.com/com-lihaoyi/mill/releases/download/0.12.0-RC3/0.12.0-RC3-example-fundamentals-tasks-6-workers.zip">download</a>, <a href="https://github.com/com-lihaoyi/mill/blob/0.12.0-RC3//example/fundamentals/tasks/6-workers">browse</a>)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">package build
import mill._, scalalib._
import java.util.Arrays
import java.io.ByteArrayOutputStream
import java.util.zip.GZIPOutputStream

def data = Task.Source(millSourcePath / &quot;data&quot;)

def compressWorker = Task.Worker{ new CompressWorker(Task.dest) }

def compressedData = Task {
  println(&quot;Evaluating compressedData&quot;)
  for(p &lt;- os.list(data().path)){
    os.write(
      Task.dest / s&quot;${p.last}.gz&quot;,
      compressWorker().compress(p.last, os.read.bytes(p))
    )
  }
  os.list(Task.dest).map(PathRef(_))
}

class CompressWorker(dest: os.Path){
  val cache = collection.mutable.Map.empty[Int, Array[Byte]]
  def compress(name: String, bytes: Array[Byte]): Array[Byte] = {
    val hash = Arrays.hashCode(bytes)
    if (!cache.contains(hash)) {
      val cachedPath = dest / hash.toHexString
      if (!os.exists(cachedPath)) {
        println(&quot;Compressing: &quot; + name)
        cache(hash) = compressBytes(bytes)
        os.write(cachedPath, cache(hash))
      }else{
        println(&quot;Cached from disk: &quot; + name)
        cache(hash) = os.read.bytes(cachedPath)
      }
    }else {
      println(&quot;Cached from memory: &quot; + name)
    }
    cache(hash)
  }
}

def compressBytes(input: Array[Byte]) = {
  val bos = new ByteArrayOutputStream(input.length)
  val gzip = new GZIPOutputStream(bos)
  gzip.write(input)
  gzip.close()
  bos.toByteArray
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Common things to put in workers include:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>References to third-party daemon processes, e.g. Webpack or wkhtmltopdf,
which perform their own in-memory caching</p>
</li>
<li>
<p>Classloaders containing plugin code, to avoid classpath conflicts while
also avoiding classloading cost every time the code is executed</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Workers live as long as the Mill process. By default, consecutive <code>mill</code>
commands in the same folder will re-use the same Mill process and workers,
unless <code>--no-server</code> is passed which will terminate the Mill process and
workers after every command. Commands run repeatedly using <code>--watch</code> will
also preserve the workers between them.</p>
</div>
<div class="paragraph">
<p>Workers can also make use of their <code>Task.dest</code> folder as a cache that persist
when the worker shuts down, as a second layer of caching. The example usage
below demonstrates how using the <code>--no-server</code> flag will make the worker
read from its disk cache, where it would have normally read from its
in-memory cache</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">&gt; ./mill show compressedData
Evaluating compressedData
Compressing: hello.txt
Compressing: world.txt
[
  &quot;.../hello.txt.gz&quot;,
  &quot;...world.txt.gz&quot;
]

&gt; ./mill compressedData # when no input changes, compressedData does not evaluate at all

&gt; sed -i.bak 's/Hello/HELLO/g' data/hello.txt

&gt; ./mill compressedData # not --no-server, we read the data from memory
Compressing: hello.txt
Cached from memory: world.txt

&gt; ./mill compressedData # --no-server, we read the data from disk
Compressing: hello.txt
Cached from disk: world.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mill uses workers to manage long-lived instances of the
<a href="https://github.com/sbt/zinc">Zinc Incremental Scala Compiler</a> and the
<a href="https://github.com/scala-js/scala-js">Scala.js Optimizer</a>.
This lets us keep them in-memory with warm caches and fast incremental execution.</p>
</div>
</div>
<div class="sect2">
<h3 id="_autoclosable_workers"><a class="anchor" href="#_autoclosable_workers"></a><code>Autoclosable</code> Workers</h3>
<div class="paragraph">
<p>As <a href="#_workers">Workers</a> may also hold limited resources, it may be necessary to free up these resources once a worker is no longer needed.
This is especially the case, when your worker tasks depends on other tasks and these tasks change, as Mill will then also create a new worker instance.</p>
</div>
<div class="paragraph">
<p>To implement resource cleanup, your worker can implement <code>java.lang.AutoCloseable</code>.
Once the worker is no longer needed, Mill will call the <code>close()</code> method on it before any newer version of this worker is created.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">import mill._
import java.lang.AutoCloseable

class MyWorker() extends AutoCloseable {
  // ...
  override def close() = { /* cleanup and free resources */ }
}

def myWorker = Task.Worker { new MyWorker() }</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_scalamodule_run_as_a_task"><a class="anchor" href="#_using_scalamodule_run_as_a_task"></a>Using ScalaModule.run as a task</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="title">build.mill (<a href="https://github.com/com-lihaoyi/mill/releases/download/0.12.0-RC3/0.12.0-RC3-example-fundamentals-tasks-11-module-run-task.zip">download</a>, <a href="https://github.com/com-lihaoyi/mill/blob/0.12.0-RC3//example/fundamentals/tasks/11-module-run-task">browse</a>)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">package build
import mill._, scalalib._
import mill.util.Jvm

object foo extends ScalaModule {
  def scalaVersion = &quot;2.13.8&quot;
  def moduleDeps = Seq(bar)
  def ivyDeps = Agg(ivy&quot;com.lihaoyi::mainargs:0.4.0&quot;)

  def sources = Task {
    bar.runner().run(args = super.sources())
    Seq(PathRef(Task.dest))
  }
}

object bar extends ScalaModule{
  def scalaVersion = &quot;2.13.8&quot;
  def ivyDeps = Agg(ivy&quot;com.lihaoyi::os-lib:0.10.7&quot;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example demonstrates using Mill <code>ScalaModule</code>s as build tasks: rather
than defining the task logic in the <code>build.mill</code>, we instead put the build
logic within the <code>bar</code> module as <code>bar/src/Bar.scala</code>. In this example, we use
<code>Bar.scala</code> as a source-code pre-processor on the <code>foo</code> module source code:
we override <code>foo.sources</code>, passing the <code>super.sources()</code> and <code>bar.runClasspath</code>
to <code>bar.runner().run</code> along with a <code>Task.dest</code>, and returning a <code>PathRef(Task.dest)</code>
as the new <code>foo.sources</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">&gt; mill foo.run
...
Foo.value: HELLO</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example does a trivial string-replace of &quot;hello&quot; with &quot;HELLO&quot;, but is
enough to demonstrate how you can use Mill <code>ScalaModule</code>s to implement your
own arbitrarily complex transformations. This is useful for build logic that
may not fit nicely inside a <code>build.mill</code> file, whether due to the sheer lines
of code or due to dependencies that may conflict with the Mill classpath
present in <code>build.mill</code></p>
</div>
<div class="paragraph">
<p><code>bar.runner().run</code> by default inherits the <code>mainClass</code>, <code>forkEnv</code>, <code>forkArgs</code>,
from the owning module <code>bar</code>, and the working directory from the calling task’s
<code>Task.dest</code>. You can also pass in these parameters explicitly to <code>run()</code> as named
arguments if you wish to override the defaults</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">trait Runner{
  def run(args: os.Shellable,
          mainClass: String = null,
          forkArgs: Seq[String] = null,
          forkEnv: Map[String, String] = null,
          workingDir: os.Path = null,
          useCpPassingJar: java.lang.Boolean = null)
         (implicit ctx: Ctx): Unit
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_experimental_forking_concurrent_futures_within_tasks"><a class="anchor" href="#_experimental_forking_concurrent_futures_within_tasks"></a>(Experimental) Forking Concurrent Futures within Tasks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Mill provides the <code>T.fork.async</code> and <code>T.fork.await</code> APIs for spawning async
futures within a task and aggregating their results later:</p>
</div>
<div class="listingblock">
<div class="title">build.mill (<a href="https://github.com/com-lihaoyi/mill/releases/download/0.12.0-RC3/0.12.0-RC3-example-fundamentals-tasks-7-forking-futures.zip">download</a>, <a href="https://github.com/com-lihaoyi/mill/blob/0.12.0-RC3//example/fundamentals/tasks/7-forking-futures">browse</a>)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">package build

import mill._

def taskSpawningFutures = Task {
  val f1 = T.fork.async(dest = T.dest / &quot;future-1&quot;, key = &quot;1&quot;, message = &quot;First Future&quot;){
    println(&quot;Running First Future inside &quot; + os.pwd)
    Thread.sleep(3000)
    val res = 1
    println(&quot;Finished First Future&quot;)
    res
  }
  val f2 = T.fork.async(dest = T.dest / &quot;future-2&quot;, key = &quot;2&quot;, message = &quot;Second Future&quot;){
    println(&quot;Running Second Future inside &quot; + os.pwd)
    Thread.sleep(3000)
    val res = 2
    println(&quot;Finished Second Future&quot;)
    res
  }

  T.fork.await(f1) + T.fork.await(f2)
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">&gt; ./mill show taskSpawningFutures
[1] Running First Future inside .../out/taskSpawningFutures.dest/future-1
[2] Running Second Future inside .../out/taskSpawningFutures.dest/future-2
[1] Finished First Future
[2] Finished Second Future
3</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>T.fork.async</code> takes several parameters in addition to the code block to be run:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>dest</code> is a folder for which the async future is to be run, overriding <code>os.pwd</code>
for the duration of the future</p>
</li>
<li>
<p><code>key</code> is a short prefix prepended to log lines to let you easily identify the future’s
log lines and distinguish them from logs of other futures and tasks running concurrently</p>
</li>
<li>
<p><code>message</code> is a one-line description of what the future is doing</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Futures spawned by <code>T.fork.async</code> count towards Mill’s <code>-j</code>/<code>--jobs</code> concurrency limit
(which defaults to one-per-core), so you can freely use <code>T.fork.async</code> without worrying
about spawning too many concurrent threads and causing CPU or memory contention. <code>T.fork</code>
uses Java’s built in <code>ForkJoinPool</code> and <code>ManagedBlocker</code> infrastructure under the hood
to effectively manage the number of running threads.</p>
</div>
<div class="paragraph">
<p>While <code>scala.concurrent</code> and <code>java.util.concurrent</code> can also be used to spawn thread
pools and run async futures, <code>T.fork</code> provides a way to do so that integrates with Mill’s
existing concurrency, sandboxing and logging systems. Thus you should always prefer to
run async futures on <code>T.fork</code> whenever possible.</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="query-syntax.html">Task Query Syntax</a></span>
  <span class="next"><a href="modules.html">Modules</a></span>
</nav>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async="async" src="../../_/js/vendor/highlight.js"></script>
<script src="../../_/js/vendor/lunr.js"></script>
<script src="../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../.." data-snippet-length="100" data-stylesheet="../../_/css/search.css"></script>
<script async="async" src="../../search-index.js"></script>
  
</body></html>