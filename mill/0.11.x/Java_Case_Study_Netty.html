<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Java Case Study: Netty :: The Mill Build Tool</title>
    <link rel="canonical" href="https://mill-build.org/mill/0.11.x/Java_Case_Study_Netty.html" />
    <link rel="prev" href="Java_Web_Build_Examples.html" />
    <link rel="next" href="Scala_Intro_to_Mill.html" />
    <meta name="generator" content="Antora 3.1.12" />
    <link rel="stylesheet" href="../../_/css/site.css" />
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-1C582ZJR85"></script>
    <script>function gtag(){dataLayer.push(arguments)};window.dataLayer=window.dataLayer||[];gtag('js',new Date());gtag('config','G-1C582ZJR85')</script>
<link rel="icon" href="../../_/favicon.png" type="image/x-icon" />
  
  <style>
  /* auto-hyphenation is super ugly */
  *{
    hyphens: manual !important;
  }

  /* Reduce font size from 17px to something reasonable */
  .doc {
   font-size: 16px !important;
  }
  .doc pre {
   font-size: 14px !important;
  }
  /* Shrink unreasonably large top bar */
  nav.navbar{
    height: 2.5rem;
  }
  body.article{
    padding-top: 2.5rem;
  }
  div.nav-container{
    top: 2.5rem;
  }
  div.toolbar{
    top: 2.5rem;
  }
  aside.nav{
    top: 2.5rem;
    height: calc(100vh - 2.5rem);
  }
  </style></head><body class="article">
  
<header class="header">
  
  <script>
  gtag('config', 'AW-16649289906');

  document.addEventListener('DOMContentLoaded', function() {
  const links = document.querySelectorAll('a');
    links.forEach(link => {
      if (link.textContent.trim().toLowerCase() === 'download') {
        link.addEventListener('click', function(event) {
          console.log("download link clicked")
          gtag('event', 'conversion', {'send_to': 'AW-16649289906/rsphCKfVq8QZELKBgIM-'});
        });
      }
    });
  });
  </script>
  <nav class="navbar">
    <div class="navbar-brand">
      <!-- TODO: add mill icon -->
      <a class="navbar-item" href="https://mill-build.org"><img src="../../_/logo-white.svg" height="20" /> The Mill Build Tool</a>
      <div class="navbar-item search">
        <input id="search-input" type="text" placeholder="Search the docs" />
      </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/com-lihaoyi/mill">GitHub</a>
        <a class="navbar-item" href="https://mill-build.org/blog/index.html">Blog</a>
        <a class="navbar-item" href="https://mill-build.org/api/latest/mill.html">API</a>
        <a class="navbar-item" href="https://github.com/com-lihaoyi/mill/issues">Issues</a>
        <a class="navbar-item" href="https://github.com/com-lihaoyi/mill/discussions">Discuss</a>


            <!--
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Documentation</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#"></a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Plugins</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Resource A</a>
            <a class="navbar-item" href="#">Resource B</a>
            <a class="navbar-item" href="#">Resource C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
        -->
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="mill" data-version="0.11.x">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
<ul class="nav-list">

  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Java Quick Start</span>
<ul class="nav-list">

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Java_Intro_to_Mill.html">Introduction to Mill for Java</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Java_Installation_IDE_Support.html">Installation and IDE Support</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Java_Builtin_Commands.html">Built-in Commands</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="Java_Build_Examples.html">Java Build Examples</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="Java_Module_Config.html">Java Module Configuration</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="Java_Web_Build_Examples.html">Java Web Build Examples</a>
  </li>

  <li class="nav-item is-current-page is-active" data-depth="1">
    <a class="nav-link" href="Java_Case_Study_Netty.html">Java Case Study: Netty</a>
  </li>
</ul>
  </li>

  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Scala Quick Start</span>
<ul class="nav-list">

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Scala_Intro_to_Mill.html">Introduction to Mill for Scala</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Scala_Installation_IDE_Support.html">Installation and IDE Support</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Scala_Builtin_Commands.html">Built-in Commands</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="Scala_Build_Examples.html">Scala Build Examples</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="Scala_Module_Config.html">Scala Module Configuration</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="Scala_Web_Build_Examples.html">Scala Web Build Examples</a>
  </li>
</ul>
  </li>

  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Mill In Depth</span>
<ul class="nav-list">

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Library_Dependencies.html">Library Dependencies in Mill</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Out_Dir.html">The Output Directory</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Tasks.html">Tasks</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="Modules.html">Modules</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="Cross_Builds.html">Cross Builds</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="Target_Query_Syntax.html">Target Query Syntax</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="Extending_Mill.html">Extending Mill</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="The_Mill_Evaluation_Model.html">The Mill Evaluation Model</a>
  </li>
</ul>
  </li>

  <li class="nav-item is-active" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Mill Plugins</span>
<ul class="nav-list">

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Using_Plugins.html">Using Plugins</a>
  </li>

  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="Contrib_Plugins.html">Contrib Plugins</a>
<ul class="nav-list">

  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="contrib/artifactory.html">Artifactory</a>
  </li>

  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="contrib/bintray.html">Bintray</a>
  </li>

  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="contrib/bloop.html">Bloop</a>
  </li>

  <li class="nav-item is-active" data-depth="2">
    <a class="nav-link" href="contrib/buildinfo.html">BuildInfo</a>
  </li>

  <li class="nav-item is-active" data-depth="2">
    <a class="nav-link" href="Plugin_BSP.html">BSP - Build Server Protocol</a>
  </li>

  <li class="nav-item is-active" data-depth="2">
    <a class="nav-link" href="contrib/codeartifact.html">Codeartifact</a>
  </li>

  <li class="nav-item is-active" data-depth="2">
    <a class="nav-link" href="contrib/docker.html">Docker</a>
  </li>

  <li class="nav-item is-active" data-depth="2">
    <a class="nav-link" href="contrib/flyway.html">Flyway</a>
  </li>

  <li class="nav-item is-active" data-depth="2">
    <a class="nav-link" href="contrib/gitlab.html">Gitlab</a>
  </li>

  <li class="nav-item is-active" data-depth="2">
    <a class="nav-link" href="contrib/jmh.html">JMH</a>
  </li>

  <li class="nav-item is-active" data-depth="2">
    <a class="nav-link" href="contrib/playlib.html">Play Framework</a>
  </li>

  <li class="nav-item is-active" data-depth="2">
    <a class="nav-link" href="contrib/proguard.html">Proguard</a>
  </li>

  <li class="nav-item is-active" data-depth="2">
    <a class="nav-link" href="contrib/scalapblib.html">ScalaPB</a>
  </li>

  <li class="nav-item is-active" data-depth="2">
    <a class="nav-link" href="contrib/scoverage.html">Scoverage</a>
  </li>

  <li class="nav-item is-active" data-depth="2">
    <a class="nav-link" href="contrib/testng.html">TestNG</a>
  </li>

  <li class="nav-item is-active" data-depth="2">
    <a class="nav-link" href="contrib/twirllib.html">Twirl</a>
  </li>

  <li class="nav-item is-active" data-depth="2">
    <a class="nav-link" href="contrib/versionfile.html">Version file</a>
  </li>
</ul>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Thirdparty_Plugins.html">Third-Party Plugins</a>
  </li>
</ul>
  </li>

  <li class="nav-item is-active" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Reference</span>
<ul class="nav-list">

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="Mill_Design_Principles.html">Mill Design Principles</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="External_References.html">External References</a>
  </li>

  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="https://mill-build.org/api/latest/mill/index.html">Mill Scaladoc</a>
  </li>

  <li class="nav-item is-active" data-depth="1">
    <a class="nav-link" href="Changelog.html">Changelog</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Mill Documentation</span>
    <span class="version">0.11.13</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <div class="title"><a href="../index.html">Mill Documentation</a></div>
      <ul class="versions">
        <li class="version">
          <a href="../main-branch/index.html">main-branch</a>
        </li>
        <li class="version is-latest">
          <a href="../index.html">1.0.4</a>
        </li>
        <li class="version">
          <a href="../dev-1.0.4-8-28c1bd/index.html">dev-1.0.4-8-28c1bd</a>
        </li>
        <li class="version">
          <a href="../0.12.x/index.html">0.12.14</a>
        </li>
        <li class="version is-current">
          <a href="index.html">0.11.13</a>
        </li>
        <li class="version">
          <a href="../0.10.15/index.html">0.10.15</a>
        </li>
        <li class="version">
          <a href="../0.9.12/index.html">0.9.12</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <div class="title"><a href="../../blog/index.html">The Mill Build Engineering Blog</a></div>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">

<div class="toolbar" role="navigation" style="position: fixed; top: 2.5rem; height: 2rem; left: 0px;">
<button class="nav-toggle"></button>
</div>
<div class="toolbar" style="position: fixed; top: 2.5rem; height: 1.5rem; right: 0px;">
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Java Case Study: Netty</h1>
<div id="preamble">
<div class="sectionbody">
<script>
gtag('config', 'AW-16649289906');
</script>
<div class="paragraph">
<p>This page compares using Mill to Maven, using the <a href="https://github.com/netty/netty">Netty Network Server</a>
codebase as the example. Netty is a large, old codebase. 500,000 lines of Java, written by
over 100 contributors across 15 years, split over 47 subprojects, with over 10,000 lines of
Maven <code>pom.xml</code> configuration alone. By porting it to Mill, this case study should give you
an idea of how Mill compares to Maven in larger, real-world projects.</p>
</div>
<div class="paragraph">
<p>To do this, we have written a Mill <code>build.sc</code> file for the Netty project. This can be used
with Mill to build and test the various submodules of the Netty project without needing to
change any other files in the repository:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/com-lihaoyi/mill/blob/main/example/thirdparty/netty/build.sc">Netty build.sc file</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_completeness"><a class="anchor" href="#_completeness"></a>Completeness</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Mill build for Netty is not 100% complete, but it covers most of the major parts of Netty:
compiling Java, compiling and linking C code via JNI, running JUnit tests and some integration
tests using H2Spec. All 47 Maven subprojects are modelled using Mill, with the entire Netty codebase
being approximately 500,000 lines of code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ git ls-files | grep \\.java | xargs wc -l
...
513805 total</code></pre>
</div>
</div>
<div class="paragraph">
<p>The goal of this exercise is not to be 100% feature complete enough to replace the Maven build
today. It is instead meant to provide a realistic comparison of how using Mill in a large,
complex project compares to using Maven.</p>
</div>
<div class="paragraph">
<p>Both Mill and Maven builds end up compiling the same set of files, although the number being
reported by the command line is slightly higher for Mill (2915 files) than Maven (2822) due
to differences in the reporting (e.g. Maven does not report <code>package-info.java</code> files as part
of the compiled file count).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_performance"><a class="anchor" href="#_performance"></a>Performance</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Mill build for Netty is much more performant than the default Maven build. This applies to
most workflows.</p>
</div>
<div class="paragraph">
<p>For the benchmarks below, each provided number is the wall time of three consecutive runs
on my M1 Macbook Pro. While ad-hoc, these benchmarks are enough to give you a flavor of how
Mill’s performance compares to Maven:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;" />
<col style="width: 25%;" />
<col style="width: 25%;" />
<col style="width: 25%;" />
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Benchmark</th>
<th class="tableblock halign-left valign-top">Maven</th>
<th class="tableblock halign-left valign-top">Mill</th>
<th class="tableblock halign-left valign-top">Speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_sequential_clean_compile_all">Sequential Clean Compile All</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2m 31.12s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0m 22.19s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6.8x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_parallel_clean_compile_all">Parallel Clean Compile All</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1m 16.45s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0m 09.95s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7.7x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_clean_compile_single_module">Clean Compile Single-Module</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0m 19.62s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0m 02.17s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">9.0x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_incremental_compile_single_module">Incremental Compile Single-Module</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0m 21.10s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0m 00.54s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">39.1x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#_no_op_compile_single_module">No-Op Compile Single-Module</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0m 17.34s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0m 00.47s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">39.1x</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The column on the right shows the speedups of how much faster Mill is compared to the
equivalent Maven workflow. In most cases,  Mill is 5-10x faster than Maven. Below, we
will go into more detail of each benchmark: how they were run, what they mean, and how
we can explain the difference in performing the same task with the two different build tools.</p>
</div>
<div class="sect2">
<h3 id="_sequential_clean_compile_all"><a class="anchor" href="#_sequential_clean_compile_all"></a>Sequential Clean Compile All</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ time ./mvnw -DskipTests  -Dcheckstyle.skip -Denforcer.skip=true clean install
2m 42.96s
2m 27.58s
2m 31.12s

$ ./mill clean; time ./mill __.compile
0m 29.14s
0m 22.19s
0m 20.79s</code></pre>
</div>
</div>
<div class="paragraph">
<p>This benchmark exercises the simple &quot;build everything from scratch&quot; workflow, with all remote
artifacts already in the local cache. The actual files
being compiled are the same in either case (as mentioned in the <a href="#_completeness">Completeness</a> section).
I have explicitly disabled the various linters and tests for the Maven build, to just focus
on the compilation of Java source code making it an apples-to-apples comparison.</p>
</div>
<div class="paragraph">
<p>As a point of reference, Java typically compiles at 10,000-50,000 lines per second on a
single thread, and the Netty codebase is ~500,000 lines of code, so we would expect compile
to take 10-50 seconds without parallelism.
The 20-30s taken by Mill seems about what you would expect for a codebase of this size,
and the ~150s taken by Maven is far beyond what you would expect from simple Java compilation.</p>
</div>
<div class="sect3">
<h4 id="_where_is_maven_spending_its_time"><a class="anchor" href="#_where_is_maven_spending_its_time"></a>Where is Maven spending its time?</h4>
<div class="paragraph">
<p>From eyeballing the logs, the added overhead comes from things like:</p>
</div>
<div class="paragraph">
<p><em>Downloading Metadata from Maven Central</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Downloading from sonatype-nexus-snapshots: https://oss.sonatype.org/content/repositories/snapshots/io/netty/netty-transport-native-unix-common/maven-metadata.xml
Downloading from central: https://repo.maven.apache.org/maven2/io/netty/netty-transport-native-unix-common/maven-metadata.xml
Downloaded from central: https://repo.maven.apache.org/maven2/io/netty/netty-transport-native-unix-common/maven-metadata.xml (4.3 kB at 391 kB/s)
Downloaded from sonatype-nexus-snapshots: https://oss.sonatype.org/content/repositories/snapshots/io/netty/netty-transport-native-unix-common/maven-metadata.xml (2.7 kB at 7.4 kB/s)</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Comparing Jars</em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Comparing [io.netty:netty-transport-sctp:jar:4.1.112.Final] against [io.netty:netty-transport-sctp:jar:4.1.113.Final-SNAPSHOT] (including their transitive dependencies).</code></pre>
</div>
</div>
<div class="paragraph">
<p>In general, Maven spends much of time working with Jar files: packing them, unpacking them,
comparing them, etc. None of this is strictly necessary for compiling Java source files to
classfiles! But if they are not necessary, then why is Maven doing it? It turns out the
reason comes own to the difference of <code>mvn compile</code> vs <code>mvn install</code></p>
</div>
</div>
<div class="sect3">
<h4 id="_maven_compile_vs_install"><a class="anchor" href="#_maven_compile_vs_install"></a>Maven Compile vs Install</h4>
<div class="paragraph">
<p>In general, the reason we have to use <code>./mvwn install</code> rather than <code>./mvnw compile</code> is that
Maven’s main mechanism for managing inter-module dependencies is via the local artifact cache
at <code>~/.m2/repository</code>. Although many workflows work with <code>compile</code>, some don’t, and
<code>./mvnw clean compile</code> on the Netty repository fails with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">[ERROR] Failed to execute goal org.apache.maven.plugins:maven-dependency-plugin:2.10:unpack-dependencies
(unpack) on project netty-resolver-dns-native-macos: Artifact has not been packaged yet.
When used on reactor artifact, unpack should be executed after packaging: see MDEP-98. -&gt; [Help 1]
[ERROR]
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR]
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoExecutionException
[ERROR]
[ERROR] After correcting the problems, you can resume the build with the command
[ERROR]   mvn &lt;args&gt; -rf :netty-resolver-dns-native-macos</code></pre>
</div>
</div>
<div class="paragraph">
<p>In contrast, Mill builds do not rely on the local artifact cache, even though Mill is able
to publish to it. That means Mill builds are able to work directly with classfiles on disk,
simply referencing them and using them as-is without spending time packing and unpacking them
into <code>.jar</code> files. Furthermore, even if we <em>did</em> want Mill to generate the <code>.jar</code>s, the
overhead of doing so is just a few seconds, far less than the two entire minutes that
Maven’s overhead adds to the clean build:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ time ./mvnw -DskipTests  -Dcheckstyle.skip -Denforcer.skip=true clean install
2m 42.96s
2m 27.58s
2m 31.12s

$ ./mill clean; time ./mill __.compile
0m 29.14s
0m 22.19s
0m 20.79s

$ ./mill clean; time ./mill __.jar
0m 32.58s
0m 24.90s
0m 23.35s</code></pre>
</div>
</div>
<div class="paragraph">
<p>From this benchmark, we can see that although both Mill and Maven are doing the same work,
Mill takes about as long as it <em>should</em> for this task of compiling 500,000 lines of Java source
code, while Maven takes considerably longer. And much of this overhead comes from Maven
doing unnecessary work packing/unpacking jar files and publishing to a local repository,
whereas Mill directly uses the classfiles generated on disk to bypass all that work.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_parallel_clean_compile_all"><a class="anchor" href="#_parallel_clean_compile_all"></a>Parallel Clean Compile All</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ time ./mvnw -T 4 -DskipTests  -Dcheckstyle.skip -Denforcer.skip=true clean install
1m 19.58s
1m 16.34s
1m 16.45s

$ ./mill clean; time ./mill -j 4  __.compile
0m 14.80s
0m 09.95s
0m 08.83s</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example compares Maven v.s. Mill, when performing the clean build on 4 threads.
Both build tools support parallelism (<code>-T 4</code> in Maven and <code>-j 4</code> in Mill), and both
tools see a similar ~2x speedup for building the Netty project using 4 threads. Again,
this tests a clean build using <code>./mvnw clean</code> or <code>./mill clean</code>.</p>
</div>
<div class="paragraph">
<p>This comparison shows that much of Mill’s speedup over Maven is unrelated to parallelism.
Whether sequential or parallel, Mill has approximately the same ~7x speedup over Maven
when performing a clean build of the Netty repository.</p>
</div>
</div>
<div class="sect2">
<h3 id="_clean_compile_single_module"><a class="anchor" href="#_clean_compile_single_module"></a>Clean Compile Single-Module</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ time ./mvnw -pl common -DskipTests  -Dcheckstyle.skip -Denforcer.skip=true clean install
0m 19.62s
0m 20.52s
0:19:50

$ ./mill clean common; time ./mill common.test.compile
0m 04.94s
0m 02.17s
0m 01.95s</code></pre>
</div>
</div>
<div class="paragraph">
<p>This exercise limits the comparison to compiling a single module, in this case <code>common/</code>.
<code>./mvnw -pl common install</code> compiles both the <code>main/</code> and <code>test/</code> sources, whereas
<code>./mill common.compile</code> would only compile the <code>main/</code> sources, and we need to explicitly
reference <code>common.test.compile</code> to compile both (because <code>common.test.compile</code> depends on
<code>common.compile</code>, <code>common.compile</code> gets run automatically)</p>
</div>
<div class="paragraph">
<p>Again, we can see a significant speedup of Mill v.s. Maven remains even when compiling a
single module: a clean compile of <code>common/</code> is about 9x faster with Mill than with Maven!
Again, <code>common/</code> is about 40,000 lines of Java source code, so at 10,000-50,000 lines per
second we would expect it to compile in about 1-4s. That puts Mill’s compile times right
at what you would expect, whereas Maven’s has a significant overhead.</p>
</div>
</div>
<div class="sect2">
<h3 id="_incremental_compile_single_module"><a class="anchor" href="#_incremental_compile_single_module"></a>Incremental Compile Single-Module</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ echo &quot;&quot; &gt;&gt; common/src/main/java/io/netty/util/AbstractConstant.java
$ time ./mvnw -pl common -DskipTests  -Dcheckstyle.skip -Denforcer.skip=true install
Compiling 174 source files to /Users/lihaoyi/Github/netty/common/target/classes
Compiling 60 source files to /Users/lihaoyi/Github/netty/common/target/test-classes

0m 21.10s
0m 19.64s
0:21:29


$ echo &quot;&quot; &gt;&gt; common/src/main/java/io/netty/util/AbstractConstant.java
$ time ./mill common.test.compile
compiling 1 Java source to /Users/lihaoyi/Github/netty/out/common/compile.dest/classes ...

0m 00.78s
0m 00.54s
0m 00.51s</code></pre>
</div>
</div>
<div class="paragraph">
<p>This benchmark explores editing a single file and re-compiling <code>common/</code>.</p>
</div>
<div class="paragraph">
<p>Maven by default takes about as long to re-compile <code>common/</code>s <code>main/</code> and <code>test/</code> sources
after a single-line edit as it does from scratch, about 20 seconds. However, Mill
takes just about 0.5s to compile and be done! Looking at the logs, we can see it is
because Mill only compiles the single file we changed, and not the others.</p>
</div>
<div class="paragraph">
<p>For this incremental compilation, Mill uses the
<a href="https://github.com/sbt/zinc">Zinc Incremental Compiler</a>. Zinc is able to analyze the dependencies
between files to figure out what needs to re-compile: for an internal change that doesn’t
affect downstream compilation (e.g. changing a string literal) Zinc only needs to compile
the file that changed, taking barely half a second:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-diff hljs" data-lang="diff">$ git diff
diff --git a/common/src/main/java/io/netty/util/AbstractConstant.java b/common/src/main/java/io/netty/util/AbstractConstant.java
index de16653cee..9818f6b3ce 100644
--- a/common/src/main/java/io/netty/util/AbstractConstant.java
+++ b/common/src/main/java/io/netty/util/AbstractConstant.java
@@ -83,7 +83,7 @@ public abstract class AbstractConstant&lt;T extends AbstractConstant&lt;T&gt;&gt; implements
             return 1;
         }

-        throw new Error(&quot;failed to compare two different constants&quot;);
+        throw new Error(&quot;failed to compare two different CONSTANTS!!&quot;);
     }

 }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ time ./mill common.test.compile
[info] compiling 1 Java source to /Users/lihaoyi/Github/netty/out/common/compile.dest/classes ...
0m 00.55s6</code></pre>
</div>
</div>
<div class="paragraph">
<p>In contrast, a change to a class or function public signature (e.g. adding a method) may
require downstream code to re-compile, and we can see that below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-diff hljs" data-lang="diff">$ git diff
diff --git a/common/src/main/java/io/netty/util/AbstractConstant.java b/common/src/main/java/io/netty/util/AbstractConstant.java
index de16653cee..f5f5a93e0d 100644
--- a/common/src/main/java/io/netty/util/AbstractConstant.java
+++ b/common/src/main/java/io/netty/util/AbstractConstant.java
@@ -41,6 +41,10 @@ public abstract class AbstractConstant&lt;T extends AbstractConstant&lt;T&gt;&gt; implements
         return name;
     }

+    public final String name2() {
+        return name;
+    }
+
     @Override
     public final int id() {
         return id;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ time ./mill common.test.compile
[25/48] common.compile
[info] compiling 1 Java source to /Users/lihaoyi/Github/netty/out/common/compile.dest/classes ...
[info] compiling 2 Java sources to /Users/lihaoyi/Github/netty/out/common/compile.dest/classes ...
[info] compiling 4 Java sources to /Users/lihaoyi/Github/netty/out/common/compile.dest/classes ...
[info] compiling 3 Java sources to /Users/lihaoyi/Github/netty/out/common/test/compile.super/mill/scalalib/JavaModule/compile.dest/classes ...
[info] compiling 1 Java source to /Users/lihaoyi/Github/netty/out/common/test/compile.super/mill/scalalib/JavaModule/compile.dest/classes ...
0m 00.81s2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, we can see that Zinc ended up re-compiling 7 files in <code>common/src/main/</code> and 3 files
in <code>common/src/test/</code> as a result of adding a method to <code>AbstractConstant.java</code>.</p>
</div>
<div class="paragraph">
<p>In general, Zinc is conservative, and does not always end up selecting the minimal set of
files that need re-compiling: e.g. in the above example, the new method <code>name2</code> does not
interfere with any existing method, and the ~9 downstream files did not actually need to
be re-compiled! However, even conservatively re-compiling 9 files is much faster than
Maven blindly re-compiling all 234 files, and as a result the iteration loop of
editing-compiling-testing your Java projects in Mill can be much faster than doing
the same thing in Maven</p>
</div>
</div>
<div class="sect2">
<h3 id="_no_op_compile_single_module"><a class="anchor" href="#_no_op_compile_single_module"></a>No-Op Compile Single-Module</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ time ./mvnw -pl common -DskipTests  -Dcheckstyle.skip -Denforcer.skip=true install
0m 16.34s
0m 17.34s
0m 18.28s

$ time ./mill common.test.compile
0m 00.49s
0m 00.47s
0m 00.45s</code></pre>
</div>
</div>
<div class="paragraph">
<p>This last benchmark explores the boundaries of Maven and Mill: what happens if
we ask to compile a single module <em>that has already been compiled</em>? In this case,
there is literally <em>nothing to do</em>. For Maven, &quot;doing nothing&quot; takes ~17 seconds,
whereas for Mill we can see it complete and return in less than 0.5 seconds</p>
</div>
<div class="paragraph">
<p>Grepping the logs, we can confirm that both build tools skip re-compilation of the
<code>common/</code> source code. In Maven, skipping compilation only saves us ~2 seconds,
bringing down the 19s we saw in <a href="#_clean_compile_single_module">Clean Compile Single-Module</a> to 17s here. This
matches what we expect about Java compilation speed, with the 2s savings on
40,000 lines of code telling us Java compiles at ~20,000 lines per second. However,
we still see Maven taking <strong>17 entire seconds</strong> before it can decide to do nothing!</p>
</div>
<div class="paragraph">
<p>In contrast, doing the same no-op compile using Mill, we see the timing from 2.2s
in <a href="#_clean_compile_single_module">Clean Compile Single-Module</a> to 0.5 seconds here. This is the same ~2s reduction
we saw with Maven, but due to Mill’s minimal overhead, in the end the command
finishes in less than half a second.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conciseness"><a class="anchor" href="#_conciseness"></a>Conciseness</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A common misconception is that conciseness makes code easier to write and harder to read,
but really it is the opposite that is true: copy-pasting out thousands of lines of
boilerplate is <em>easy</em>! It is refactoring those thousands of lines, maintaining those
thousands of lines, debugging those thousands of lines when a bug slips in: <em>that</em>
is what is actually difficult.</p>
</div>
<div class="paragraph">
<p>The Mill <code>build.sc</code> file is approximately 600 lines of code, an order of magnitude
more concise than the Maven <code>pom.xml</code> files which add up to over 10,000 lines.
That’s ~9,000 fewer lines of config you have to read, maintain, refactor, and debug.
Mill builds are concise not because they’re awkwardly compressed, but because they allow you
to use standard software engineering techniques to structure the complexities of your
project’s build pipelines.</p>
</div>
<div class="sect2">
<h3 id="_simple_modules"><a class="anchor" href="#_simple_modules"></a>Simple Modules</h3>
<div class="paragraph">
<p>This can be seen in some of the simplest of the submodules, e.g. <code>resolver</code>, where the Mill
config is just 3 lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">object resolver extends NettyModule{
  def moduleDeps = Seq(common)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the equivalent <code>pom.xml</code> is 30 lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;

  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;parent&gt;
    &lt;groupId&gt;io.netty&lt;/groupId&gt;
    &lt;artifactId&gt;netty-parent&lt;/artifactId&gt;
    &lt;version&gt;4.1.113.Final-SNAPSHOT&lt;/version&gt;
  &lt;/parent&gt;

  &lt;artifactId&gt;netty-resolver&lt;/artifactId&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;Netty/Resolver&lt;/name&gt;

  &lt;properties&gt;
    &lt;javaModuleName&gt;io.netty.resolver&lt;/javaModuleName&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;${project.groupId}&lt;/groupId&gt;
      &lt;artifactId&gt;netty-common&lt;/artifactId&gt;
      &lt;version&gt;${project.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.mockito&lt;/groupId&gt;
      &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/project&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In general, the Mill snippet contains all the same information as the Maven snippet: the name
of the module and its dependency on <code>common</code>. Much of the other information in the Maven XML
is inherited from the <code>trait NettyModule</code> we defined earlier in the file, where it can be
shared with the rest of the modules rather than being duplicated for each one.</p>
</div>
<div class="paragraph">
<p>The benefit of short module definitions is not just that they’re easier to write, but they
are also easier to <em>read</em>. In the example above, <code>object resolve</code> specifies exactly what
is unique to it: it is a <code>NettyModule</code> with a module dependency on <code>common</code>. In contrast,
the XML blob above contains a lot of repetitive boilerplate: this makes it difficult
to see at a glance where <code>netty-resolver</code> differs from the other modules in the Netty codebase,
and the boilerplate provides space for bugs to hide where config that should be identical
accidentally falls out of sync.</p>
</div>
<div class="paragraph">
<p>The concise <code>object resolve</code> example above makes use of a <code>NettyModule</code> to provide the
&quot;default&quot; configuration for a module in the Netty codebase. This is known as a &quot;Module Trait&quot;,
which we will explore below</p>
</div>
</div>
<div class="sect2">
<h3 id="_module_traits"><a class="anchor" href="#_module_traits"></a>Module Traits</h3>
<div class="paragraph">
<p>&quot;Module Traits&quot; are groups of definitions that modules can inherit. For example, the
<code>NettyModule</code> above is defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">trait NettyModule extends NettyBaseModule{
  def testModuleDeps: Seq[MavenModule] = Nil
  def testIvyDeps: T[Agg[mill.scalalib.Dep]] = T{ Agg() }

  object test extends NettyTestSuiteModule with MavenTests{
    def moduleDeps = super.moduleDeps ++ testModuleDeps
    def ivyDeps = super.ivyDeps() ++ testIvyDeps()
    def forkWorkingDir = NettyModule.this.millSourcePath
    def forkArgs = super.forkArgs() ++ Seq(
      &quot;-Dnativeimage.handlerMetadataArtifactId=netty-&quot; + NettyModule.this.millModuleSegments.parts.last,
    )
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>NettyModule</code> is a <code>NettyBaseModule</code> with some <code>testModuleDeps</code> and <code>testIvyDeps</code> that
can be overriden, and a <code>test</code> module internally that makes use of them along with some standard
configuration. <code>NettyBaseModule</code> is shown below, and is just a builtin <code>MavenModule</code> with the
<code>javacOptions</code> set:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">trait NettyBaseModule extends MavenModule{
  def javacOptions = Seq(&quot;-source&quot;, &quot;1.8&quot;, &quot;-target&quot;, &quot;1.8&quot;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>NettyTestSuiteModule</code> is another module trait, that for conciseness I’ll skip over for now.</p>
</div>
<div class="paragraph">
<p>Now that <code>trait NettyModule</code> is defined, you can re-use it over and over many different
modules:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">object `codec-dns` extends NettyModule{
  def moduleDeps = Seq(common, buffer, transport, codec)
  def testModuleDeps = Seq(transport.test)
}

object `codec-haproxy` extends NettyModule{
  def moduleDeps = Seq(buffer, transport, codec)
  def testModuleDeps = Seq(transport.test)
}

object `codec-http` extends NettyModule{
  def moduleDeps = Seq(common, buffer, transport, codec, handler)
  def testModuleDeps = Seq(transport.test)
  def compileIvyDeps = Agg(
    ivy&quot;com.jcraft:jzlib:1.1.3&quot;,
    ivy&quot;com.aayushatharva.brotli4j:brotli4j:1.16.0&quot;,
  )
}

object `codec-http2` extends NettyModule{
  def moduleDeps = Seq(common, buffer, transport, codec, handler, `codec-http`)
  def testModuleDeps = Seq(transport.test)
  def compileIvyDeps = Agg(
    ivy&quot;com.aayushatharva.brotli4j:brotli4j:1.16.0&quot;,
  )
}

object `codec-memcache` extends NettyModule{
  def moduleDeps = Seq(common, buffer, transport, codec)
  def testModuleDeps = Seq(transport.test)
}

object `codec-mqtt` extends NettyModule{
  def moduleDeps = Seq(common, buffer, transport, codec)
  def testModuleDeps = Seq(transport.test)
}

object `codec-redis` extends NettyModule{
  def moduleDeps = Seq(common, buffer, transport, codec)
  def testModuleDeps = Seq(transport.test)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Shared module traits make it very easy to skim over a bunch of different definitions and
see what is important: how those modules are uniquely configured. I can glance over
the handful of modules above and see exactly what differs between them, which is much
easier than digging through the equivalent group of Maven <code>pom.xml</code> files and trying to
spot the differences.</p>
</div>
<div class="paragraph">
<p>Software build pipelines tend to be very repetitive.
Mill’s module traits allow you to template out common parts of your Mill build: not just
the configuration flags for a single module, but common multi-step workflows or pipelines
(<em>&quot;these application modules also contain C code which is compiled and linked for use from Java&quot;</em>)
but even entire groups of modules (e.g. <em>&quot;every <code>NettyModule</code> should have a <code>test</code> module</em>).
This helps you structure your project’s build pipelines and keep them manageable, while
still accommodating the repetitiveness inherent in any software project’s build.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_extensibility"><a class="anchor" href="#_extensibility"></a>Extensibility</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Even though Maven is designed to be declarative, in many real-world codebases you end
up needing to run ad-hoc scripts and logic. This section will explore two such scenarios,
so you can see how Mill differs from Maven in the handling of these requirements.</p>
</div>
<div class="sect2">
<h3 id="_groovy"><a class="anchor" href="#_groovy"></a>Groovy</h3>
<div class="paragraph">
<p>The Maven build for the <code>common/</code> subproject
uses a Groovy script for code generation. This is configured via:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;properties&gt;
  &lt;collection.template.dir&gt;${project.basedir}/src/main/templates&lt;/collection.template.dir&gt;
  &lt;collection.template.test.dir&gt;${project.basedir}/src/test/templates&lt;/collection.template.test.dir&gt;
  &lt;collection.src.dir&gt;${project.build.directory}/generated-sources/collections/java&lt;/collection.src.dir&gt;
  &lt;collection.testsrc.dir&gt;${project.build.directory}/generated-test-sources/collections/java&lt;/collection.testsrc.dir&gt;
&lt;/properties&gt;
&lt;plugin&gt;
  &lt;groupId&gt;org.codehaus.gmaven&lt;/groupId&gt;
  &lt;artifactId&gt;groovy-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;2.1.1&lt;/version&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.codehaus.groovy&lt;/groupId&gt;
      &lt;artifactId&gt;groovy&lt;/artifactId&gt;
      &lt;version&gt;3.0.9&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;ant&lt;/groupId&gt;
      &lt;artifactId&gt;ant-optional&lt;/artifactId&gt;
      &lt;version&gt;1.5.3-1&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;generate-collections&lt;/id&gt;
      &lt;phase&gt;generate-sources&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;execute&lt;/goal&gt;
      &lt;/goals&gt;
      &lt;configuration&gt;
        &lt;source&gt;${project.basedir}/src/main/script/codegen.groovy&lt;/source&gt;
      &lt;/configuration&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In contrast, the Mill build configures the code generation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">import $ivy.`org.codehaus.groovy:groovy:3.0.9`
import $ivy.`org.codehaus.groovy:groovy-ant:3.0.9`
import $ivy.`ant:ant-optional:1.5.3-1`

object common extends NettyModule{
  ...
  def script = T.source(millSourcePath / &quot;src&quot; / &quot;main&quot; / &quot;script&quot;)
  def generatedSources0 = T{
    val shell = new groovy.lang.GroovyShell()
    val context = new java.util.HashMap[String, Object]

    context.put(&quot;collection.template.dir&quot;, &quot;common/src/main/templates&quot;)
    context.put(&quot;collection.template.test.dir&quot;, &quot;common/src/test/templates&quot;)
    context.put(&quot;collection.src.dir&quot;, (T.dest / &quot;src&quot;).toString)
    context.put(&quot;collection.testsrc.dir&quot;, (T.dest / &quot;testsrc&quot;).toString)

    shell.setProperty(&quot;properties&quot;, context)
    shell.setProperty(&quot;ant&quot;, new groovy.ant.AntBuilder())

    shell.evaluate((script().path / &quot;codegen.groovy&quot;).toIO)

    (PathRef(T.dest / &quot;src&quot;), PathRef(T.dest / &quot;testsrc&quot;))
  }

  def generatedSources = T{ Seq(generatedSources0()._1)}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>While the number of lines of code <em>written</em> is not that different, the Mill configuration
is a lot more direct: rather than writing 35 lines of XML to configure an opaque third-party
plugin, we instead write 25 lines of code to directly do what we want: import <code>groovy</code>,
configure a <code>GroovyShell</code>, and use it to evaluate our <code>codegen.groovy</code> script.</p>
</div>
<div class="paragraph">
<p>This direct control means you are not beholden to third party plugins: rather than being
limited to what an existing plugin <em>allows</em> you to do, Mill allows you to directly write
the code necessary to do what <em>you need to do</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_calling_make"><a class="anchor" href="#_calling_make"></a>Calling Make</h3>
<div class="paragraph">
<p>The Maven build for the <code>transport-native-unix-common/</code> subproject needs to call
<code>make</code> in order to compile its C code to modules that can be loaded into Java applications
via JNI. Maven does this via the <code>maven-dependency-plugin</code> and <code>maven-antrun-plugin</code> which are
approximately configured as below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;properties&gt;
  &lt;exe.make&gt;make&lt;/exe.make&gt;
  &lt;exe.compiler&gt;gcc&lt;/exe.compiler&gt;
  &lt;exe.archiver&gt;ar&lt;/exe.archiver&gt;
  &lt;nativeLibName&gt;libnetty-unix-common&lt;/nativeLibName&gt;
  &lt;nativeIncludeDir&gt;${project.basedir}/src/main/c&lt;/nativeIncludeDir&gt;
  &lt;jniUtilIncludeDir&gt;${project.build.directory}/netty-jni-util/&lt;/jniUtilIncludeDir&gt;
  &lt;nativeJarWorkdir&gt;${project.build.directory}/native-jar-work&lt;/nativeJarWorkdir&gt;
  &lt;nativeObjsOnlyDir&gt;${project.build.directory}/native-objs-only&lt;/nativeObjsOnlyDir&gt;
  &lt;nativeLibOnlyDir&gt;${project.build.directory}/native-lib-only&lt;/nativeLibOnlyDir&gt;
&lt;/properties&gt;

&lt;plugins&gt;
  &lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
      &lt;!-- unpack netty-jni-util files --&gt;
      &lt;execution&gt;
        &lt;id&gt;unpack&lt;/id&gt;
        &lt;phase&gt;generate-sources&lt;/phase&gt;
        &lt;goals&gt;
          &lt;goal&gt;unpack-dependencies&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
          &lt;includeGroupIds&gt;io.netty&lt;/includeGroupIds&gt;
          &lt;includeArtifactIds&gt;netty-jni-util&lt;/includeArtifactIds&gt;
          &lt;classifier&gt;sources&lt;/classifier&gt;
          &lt;outputDirectory&gt;${jniUtilIncludeDir}&lt;/outputDirectory&gt;
          &lt;includes&gt;**.h,**.c&lt;/includes&gt;
          &lt;overWriteReleases&gt;false&lt;/overWriteReleases&gt;
          &lt;overWriteSnapshots&gt;true&lt;/overWriteSnapshots&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
  &lt;/plugin&gt;
  &lt;plugin&gt;
    &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
      &lt;!-- invoke the make file to build a static library --&gt;
      &lt;execution&gt;
        &lt;id&gt;build-native-lib&lt;/id&gt;
        &lt;phase&gt;generate-sources&lt;/phase&gt;
        &lt;goals&gt;
          &lt;goal&gt;run&lt;/goal&gt;
        &lt;/goals&gt;
        &lt;configuration&gt;
          &lt;target&gt;
            &lt;exec executable=&quot;${exe.make}&quot; failonerror=&quot;true&quot; resolveexecutable=&quot;true&quot;&gt;
              &lt;env key=&quot;CC&quot; value=&quot;${exe.compiler}&quot; /&gt;
              &lt;env key=&quot;AR&quot; value=&quot;${exe.archiver}&quot; /&gt;
              &lt;env key=&quot;LIB_DIR&quot; value=&quot;${nativeLibOnlyDir}&quot; /&gt;
              &lt;env key=&quot;OBJ_DIR&quot; value=&quot;${nativeObjsOnlyDir}&quot; /&gt;
              &lt;env key=&quot;JNI_PLATFORM&quot; value=&quot;${jni.platform}&quot; /&gt;
              &lt;env key=&quot;CFLAGS&quot; value=&quot;-O3 -Werror -Wno-attributes -fPIC -fno-omit-frame-pointer -Wunused-variable -fvisibility=hidden&quot; /&gt;
              &lt;env key=&quot;LDFLAGS&quot; value=&quot;-Wl,--no-as-needed -lrt -Wl,-platform_version,macos,10.9,10.9&quot; /&gt;
              &lt;env key=&quot;LIB_NAME&quot; value=&quot;${nativeLibName}&quot; /&gt;
              &lt;!-- support for __attribute__((weak_import)) by the linker was added in 10.2 so ensure we
                   explicitly set the target platform. Otherwise we may get fatal link errors due to weakly linked
                   methods which are not expected to be present on MacOS (e.g. accept4). --&gt;
              &lt;env key=&quot;MACOSX_DEPLOYMENT_TARGET&quot; value=&quot;10.9&quot; /&gt;
            &lt;/exec&gt;
          &lt;/target&gt;
        &lt;/configuration&gt;
      &lt;/execution&gt;
    &lt;/executions&gt;
  &lt;/plugin&gt;
&lt;/plugins&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>maven-dependency-plugin</code> is used to download and unpack a single <code>jar</code> file,
while <code>maven-antrun-plugin</code> is used to call <code>make</code>. Both are configured via XML,
with the <code>make</code> command essentially being a bash script wrapped in layers of XML.</p>
</div>
<div class="paragraph">
<p>In contrast, the Mill configuration for this logic is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-scala hljs" data-lang="scala">def makefile = T.source(millSourcePath / &quot;Makefile&quot;)
def cSources = T.source(millSourcePath / &quot;src&quot; / &quot;main&quot; / &quot;c&quot;)
def cHeaders = T{
  for(p &lt;- os.walk(cSources().path) if p.ext == &quot;h&quot;){
    os.copy(p, T.dest / p.relativeTo(cSources().path), createFolders = true)
  }
  PathRef(T.dest)
}

def make = T{
  os.copy(makefile().path, T.dest / &quot;Makefile&quot;)
  os.copy(cSources().path, T.dest / &quot;src&quot; / &quot;main&quot; / &quot;c&quot;, createFolders = true)

  val Seq(sourceJar) = resolveDeps(
    deps = T.task(Agg(ivy&quot;io.netty:netty-jni-util:0.0.9.Final&quot;).map(bindDependency())),
    sources = true
  )().toSeq

  os.proc(&quot;jar&quot;, &quot;xf&quot;, sourceJar.path).call(cwd = T.dest  / &quot;src&quot; / &quot;main&quot; / &quot;c&quot;)

  os.proc(&quot;make&quot;).call(
    cwd = T.dest,
    env = Map(
      &quot;CC&quot; -&gt; &quot;clang&quot;,
      &quot;AR&quot; -&gt; &quot;ar&quot;,
      &quot;JNI_PLATFORM&quot; -&gt; &quot;darwin&quot;,
      &quot;LIB_DIR&quot; -&gt; &quot;lib-out&quot;,
      &quot;OBJ_DIR&quot; -&gt; &quot;obj-out&quot;,
      &quot;MACOSX_DEPLOYMENT_TARGET&quot; -&gt; &quot;10.9&quot;,
      &quot;CFLAGS&quot; -&gt; Seq(
        &quot;-mmacosx-version-min=10.9&quot;, &quot;-O3&quot;, &quot;-Werror&quot;, &quot;-Wno-attributes&quot;, &quot;-fPIC&quot;,
        &quot;-fno-omit-frame-pointer&quot;, &quot;-Wunused-variable&quot;, &quot;-fvisibility=hidden&quot;,
        &quot;-I&quot; + sys.props(&quot;java.home&quot;) + &quot;/include/&quot;,
        &quot;-I&quot; + sys.props(&quot;java.home&quot;) + &quot;/include/darwin&quot;,
        &quot;-I&quot; + sys.props(&quot;java.home&quot;) + &quot;/include/linux&quot;,
      ).mkString(&quot; &quot;),
      &quot;LD_FLAGS&quot; -&gt; &quot;-Wl,--no-as-needed -lrt -Wl,-platform_version,macos,10.9,10.9&quot;,
      &quot;LIB_NAME&quot; -&gt; &quot;libnetty-unix-common&quot;
    )
  )

  (PathRef(T.dest / &quot;lib-out&quot;), PathRef(T.dest / &quot;obj-out&quot;))
}</code></pre>
</div>
</div>
<div class="paragraph">
<center>
<svg width="179px" height="76px" viewBox="0.00 0.00 178.60 75.80" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1.0 1.0) rotate(0.0) translate(4.0 71.8)">
<title>G</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-71.8 174.6,-71.8 174.6,4 -4,4"></polygon>
<!-- makefile -->
<g id="node1" class="node">
<title>makefile</title>
<polygon fill="white" stroke="black" points="65.74,-67.7 0.79,-67.7 0.79,-43.1 65.74,-43.1 65.74,-67.7"></polygon>
<text text-anchor="middle" x="33.27" y="-51.2" font-family="Times,serif" font-size="14.00">makefile</text>
</g>
<!-- make -->
<g id="node2" class="node">
<title>make</title>
<polygon fill="white" stroke="black" points="159.89,-67.7 113.25,-67.7 113.25,-43.1 159.89,-43.1 159.89,-67.7"></polygon>
<text text-anchor="middle" x="136.57" y="-51.2" font-family="Times,serif" font-size="14.00">make</text>
</g>
<!-- makefile&#45;&gt;make -->
<g id="edge1" class="edge">
<title>makefile-&gt;make</title>
<path fill="none" stroke="black" d="M65.76,-55.4C77.62,-55.4 91.12,-55.4 103.07,-55.4"></path>
<polygon fill="black" stroke="black" points="103.09,-58.9 113.09,-55.4 103.09,-51.9 103.09,-58.9"></polygon>
</g>
<!-- cSources -->
<g id="node3" class="node">
<title>cSources</title>
<polygon fill="white" stroke="black" points="66.3,-24.7 0.23,-24.7 0.23,-0.1 66.3,-0.1 66.3,-24.7"></polygon>
<text text-anchor="middle" x="33.27" y="-8.2" font-family="Times,serif" font-size="14.00">cSources</text>
</g>
<!-- cSources&#45;&gt;make -->
<g id="edge2" class="edge">
<title>cSources-&gt;make</title>
<path fill="none" stroke="black" d="M63.29,-24.72C75.97,-30.1 90.86,-36.42 103.83,-41.93"></path>
<polygon fill="black" stroke="black" points="102.72,-45.26 113.3,-45.95 105.46,-38.82 102.72,-45.26"></polygon>
</g>
<!-- cHeaders -->
<g id="node4" class="node">
<title>cHeaders</title>
<polygon fill="white" stroke="black" points="170.64,-24.7 102.5,-24.7 102.5,-0.1 170.64,-0.1 170.64,-24.7"></polygon>
<text text-anchor="middle" x="136.57" y="-8.2" font-family="Times,serif" font-size="14.00">cHeaders</text>
</g>
<!-- cSources&#45;&gt;cHeaders -->
<g id="edge3" class="edge">
<title>cSources-&gt;cHeaders</title>
<path fill="none" stroke="black" d="M66.32,-12.4C74.57,-12.4 83.58,-12.4 92.3,-12.4"></path>
<polygon fill="black" stroke="black" points="92.33,-15.9 102.33,-12.4 92.33,-8.9 92.33,-15.9"></polygon>
</g>
</g>
</svg>

</center>
</div>
<div class="paragraph">
<p>In Mill, we define the <code>makefile</code>, <code>cSources</code>, <code>cHeaders</code>, and <code>make</code> tasks. The bulk
of the logic is in <code>def make</code>, which prepares the <code>makefile</code> and C sources,
resolves the <code>netty-jni-util</code> source jar and unpacks it with <code>jar xf</code>, and calls <code>make</code>
with the given environment variables. Both <code>cHeaders</code> and the output of <code>make</code> are used
in downstream modules.</p>
</div>
<div class="paragraph">
<p>Again, the Maven XML and Mill code contains exactly the same logic, and neither is
much more concise or verbose than the other. Rather, what is interesting is that
it is much easier to work with this kind of <em>build logic</em> via <em>direct code</em>, rather
than configuring a bunch of third-party plugins to try and achieve what you want.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion"><a class="anchor" href="#_conclusion"></a>Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Both the Mill and Maven builds we discussed in this case study do the same thing: they
compile Java code, zip them into Jar files, run tests. Sometimes they compile and link
C code or run <code>make</code> or Groovy. Mill doesn’t try to do <em>more</em> than Maven does, but it
tries to do it <em>better</em>: faster compiles, shorter and easier to read configs, easier
extensibility via libraries (e.g. <code>org.codehaus.groovy:groovy</code>) and subprocesses
(e.g. <code>make</code>).</p>
</div>
<div class="paragraph">
<p>This case study demonstrates that</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="Java_Web_Build_Examples.html">Java Web Build Examples</a></span>
  <span class="next"><a href="Scala_Intro_to_Mill.html">Introduction to Mill for Scala</a></span>
</nav>
</article>
  </div>
</main>
</div>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async="async" src="../../_/js/vendor/highlight.js"></script>
<script src="../../_/js/vendor/lunr.js"></script>
<script src="../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../.." data-snippet-length="100" data-stylesheet="../../_/css/search.css"></script>
<script async="async" src="../../search-index.js"></script>
  
</body></html>