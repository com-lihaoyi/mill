package build.runner
// imports
import mill._
import mill.contrib.buildinfo.BuildInfo

/**
 * Logic around the Mill command-line runner, script loading,
 * process management, and build bootstrapping process.
 *
 * Mostly tested by [[build.integration]] and [[build.example]] tests.
 */
object `package` extends RootModule with build.MillPublishScalaModule with BuildInfo {
  object api extends build.MillPublishScalaModule with BuildInfo {
    def moduleDeps = Seq(build.core.constants)
    def ivyDeps = Seq(build.Deps.sbtTestInterface)

    def buildInfoObjectName = "Versions"

    def buildInfoPackageName = "mill.runner.api"
    def buildInfoMembers = Seq(
      BuildInfo.Value(
        "semanticDBVersion",
        build.Deps.semanticDBscala.version,
        "SemanticDB version."
      ),
      BuildInfo.Value(
        "semanticDbJavaVersion",
        build.Deps.semanticDbJava.version,
        "Java SemanticDB plugin version."
      )
    )
  }

  object `worker-api` extends build.MillPublishScalaModule {
    // def ivyDeps = Agg(build.Deps.osLib)
  }

  object worker extends build.MillPublishScalaModule {
    def moduleDeps = Seq(`worker-api`)
    def ivyDeps = Agg(build.Deps.scalaCompiler(scalaVersion()))

    private[runner] def bootstrapDeps = Task {
      val moduleDep = {
        val m = artifactMetadata()
        s"${m.group}:${m.id}:${m.version}"
      }
      val boundIvys = allIvyDeps()
      val nameFilter = "scala(.*)-compiler(.*)".r
      Agg(moduleDep) ++ boundIvys.collect {
        case dep if nameFilter.matches(dep.name) =>
          s"${dep.organization}:${dep.name}:${dep.version}"
      }
    }

    def reportDeps() = Task.Command {
      bootstrapDeps().foreach(d => T.log.info(s"ivy dep: $d"))
    }
  }

  object client extends build.MillPublishScalaModule with BuildInfo {
    // Disable scalafix because it seems to misbehave and cause
    // spurious errors when there are mixed Java/Scala sources
    def fix(args: String*): Command[Unit] = Task.Command {}
    def buildInfoPackageName = "mill.runner.client"
    def moduleDeps = Seq(build.runner.server.client)
    def ivyDeps = Agg(
      build.Deps.nativeTerminal,
      build.Deps.coursier,
      build.Deps.coursierInterface,
      build.Deps.coursierJvm,
      build.Deps.logback
    )
    def buildInfoObjectName = "Versions"
    def buildInfoMembers = Task {
      val jlineNativeVersion = compileClasspath().map(_.path.last)
        .find(name => name.startsWith("jline-native-") && name.endsWith(".jar"))
        .map(_.stripPrefix("jline-native-").stripSuffix(".jar"))
        .getOrElse {
          sys.error("Cannot get jline-native version from compile class path")
        }
      Seq(
        BuildInfo.Value("coursierJvmIndexVersion", build.Deps.coursierJvmIndexVersion),
        BuildInfo.Value("jlineNativeVersion", jlineNativeVersion)
      )
    }
  }

  def moduleDeps = Seq(
    build.core,
    build.main,
    build.scalalib,
    build.bsp,
    build.core.codesig,
    build.runner.server,
    client,
    `worker-api`
  )

  def buildInfoPackageName = "mill.runner.worker"

  def buildInfoMembers = Seq(
    BuildInfo.Value(
      "bootstrapDeps",
      worker.bootstrapDeps().mkString(";"),
      "Depedendencies used to bootstrap the scala compiler worker."
    )
  )
}
