//| mill-version: 0.13.0-M2-59-17fa7b

package build

import millbuild.*

//import com.github.lolgab.mill.mima.Mima
import coursier.maven.MavenRepository
import coursier.VersionConstraint
import mill.main.VcsVersion
//import com.goyeau.mill.scalafix.ScalafixModule
import mill._
import mill.define.NamedTask
import mill.main.Tasks
import mill.scalalib._
import mill.scalalib.api.JvmWorkerUtil
import mill.scalalib.publish._
import mill.define.SelectMode
import mill.T
import mill.define.Cross
import scala.util.Properties

def millVersionIsStable: T[Boolean] = Task.Input {
  Task.env.contains("MILL_STABLE_VERSION")
}

def isCI: T[Boolean] = Task.Input {
  Task.env.contains("CI")
}

def millVersionTruth: T[String] = Task.Input {
  VcsVersion.calcVcsState(Task.log).format()
}

def millVersion: T[String] = Task {
  if (millVersionIsStable()) {
    val vcsState = VcsVersion.calcVcsState(Task.log)
    // Ignore local changes when computing the VCS version string in CI,
    // since we make those in CI and can promise they are safe, but make
    // sure we include local dirty changes when iterating locally.
    if (isCI()) vcsState.copy(dirtyHash = None).format()
    else vcsState.format()
  } else "SNAPSHOT"
}

def millLastTagTruth: T[String] = Task {
  VcsVersion.calcVcsState(Task.log).lastTag.getOrElse(
    sys.error("No (last) git tag found. Your git history seems incomplete!")
  )
}

def millLastTag: T[String] = Task {
  if (millVersionIsStable())
    VcsVersion.calcVcsState(Task.log).lastTag.getOrElse(
      sys.error("No (last) git tag found. Your git history seems incomplete!")
    )
  else "SNAPSHOT"
}

def millDownloadPrefix = Task {
  s"${Settings.mavenRepoUrl}/com/lihaoyi/mill-dist"
}
def millDownloadUrl = Task {
  s"${millDownloadPrefix()}/${millLastTag()}"
}

def millBinPlatform: T[String] = Task {
  val tag = millLastTag()
  if (tag.contains("-M")) tag
  else {
    val pos = if (tag.startsWith("0.")) 2 else 1
    tag.split("[.]", pos + 1).take(pos).mkString(".")
  }
}

def millJvmVersion = Task.Source(Task.workspace / ".mill-jvm-version")

val essentialBridgeScalaVersions =
  Seq(Deps.scalaVersion, Deps.scala2Version, Deps.workerScalaVersion212)
// published compiler bridges
val bridgeScalaVersions = Seq(
  // Our version of Zinc doesn't work with Scala 2.12.0 and 2.12.4 compiler
  // bridges. We skip 2.12.1 because it's so old not to matter, and we need a
  // non-supported scala version for testing purposes. We skip 2.13.0-2 because
  // scaladoc fails on windows
  /*"2.12.0",*/ /*2.12.1",*/ "2.12.2",
  "2.12.3", /*"2.12.4",*/ "2.12.5",
  "2.12.6",
  "2.12.7",
  "2.12.8",
  "2.12.9",
  "2.12.10",
  "2.12.11",
  "2.12.12",
  "2.12.13",
  "2.12.14",
  "2.12.15",
  "2.12.16",
  "2.12.17",
  "2.12.18",
  "2.12.19",
  /*"2.13.0", "2.13.1", "2.13.2",*/
  "2.13.3",
  "2.13.4",
  "2.13.5",
  "2.13.6",
  "2.13.7",
  "2.13.8",
  "2.13.9",
  "2.13.10",
  "2.13.11",
  "2.13.12",
  "2.13.13",
  "2.13.14",
  "2.13.15",
  "2.13.16"
)

// We limit the number of compiler bridges to compile and publish for local
// development and testing, because otherwise it takes forever to compile all
// of them. Compiler bridges not in this set will get downloaded and compiled
// on the fly anyway. For publishing, we publish everything or a specific version
// if given.
val compilerBridgeScalaVersions =
  interp.watchValue(sys.env.get("MILL_COMPILER_BRIDGE_VERSIONS")) match {
    case None | Some("") | Some("none") => Seq.empty[String]
    case Some("all") => (essentialBridgeScalaVersions ++ bridgeScalaVersions).distinct
    case Some("essential") => essentialBridgeScalaVersions
    case Some(versions) => versions.split(',').map(_.trim()).filterNot(_.isEmpty).toSeq
  }
val bridgeVersion = "0.0.1"

trait MillJavaModule extends JavaModule {

  // Test setup
  def localTestOverride =
    Task { (s"com.lihaoyi-${artifactId()}", localTestOverridePaths().map(_.path).mkString("\n")) }

  def testArgs: T[Seq[String]] = Task {
    // Workaround for Zinc/JNA bug
    // https://github.com/sbt/sbt/blame/6718803ee6023ab041b045a6988fafcfae9d15b5/main/src/main/scala/sbt/Main.scala#L130
    val jnaArgs = Seq("-Djna.nosys=true")
    val userLang =
      if (Properties.isMac || Properties.isWin) Seq("-Duser.language=en")
      else Nil
    jnaArgs ++ userLang
  }
  def localTestOverridePaths =
    Task { upstreamAssemblyClasspath() ++ Seq(compile().classes) ++ resources() }

  def transitiveLocalTestOverrides: T[Map[String, String]] = Task {
    val upstream = Task.traverse(moduleDeps ++ compileModuleDeps) {
      case m: MillJavaModule => m.transitiveLocalTestOverrides.map(Some(_))
      case _ => Task.Anon(None)
    }().flatten.flatten
    val current = Seq(localTestOverride())
    upstream.toMap ++ current
  }

  def testMvnDeps: T[Agg[Dep]] = Agg(Deps.TestDeps.utest)
  def testForkEnv: T[Map[String, String]] = forkEnv()
  def testModuleDeps: Seq[JavaModule] =
    if (this == build.libs.main) Seq(build.libs.main, build.core.util)
    else Seq(this, build.libs.main.test)

  def localTestOverridesClasspath = Task {
    for ((k, v) <- transitiveLocalTestOverrides()) {
      os.write(Task.dest / "mill/local-test-overrides" / k, v, createFolders = true)
    }
    PathRef(Task.dest)
  }

  def runClasspath = super.runClasspath() ++ Seq(localTestOverridesClasspath())

  def repositoriesTask = Task.Anon {
    super.repositoriesTask() ++
      Seq(MavenRepository("https://oss.sonatype.org/content/repositories/releases"))
  }

  def mapDependencies: Task[coursier.Dependency => coursier.Dependency] = Task.Anon {
    super.mapDependencies().andThen { dep =>
      forcedVersions.find(f =>
        f.dep.module.organization.value == dep.module.organization.value &&
          f.dep.module.name.value == dep.module.name.value
      ).map { forced =>
        val newDep = dep.withVersionConstraint(VersionConstraint(forced.version))
        Task.log.debug(
          s"Forcing version of ${dep.module} from ${dep.versionConstraint.asString} to ${newDep.versionConstraint.asString}"
        )
        newDep
      }.getOrElse(dep)
    }
  }
  val forcedVersions: Seq[Dep] = Deps.transitiveDeps ++ Seq(
    Deps.jline,
    Deps.jna
  )

  def javadocOptions = super.javadocOptions() ++ Seq(
    // Disable warnings for missing documentation comments or tags (for example,
    // a missing comment or class, or a missing @return tag or similar tag on a method).
    // We have many methods without JavaDoc comments, so those warnings are useless
    // and significantly clutter the output.
    "-Xdoclint:all,-missing"
  )
}

trait MillPublishJavaModule extends MillJavaModule with PublishModule {
  def commonPomSettings(artifactName: String) = {
    PomSettings(
      description = artifactName,
      organization = Settings.pomOrg,
      url = Settings.projectUrl,
      licenses = Seq(License.MIT),
      versionControl = VersionControl.github(Settings.githubOrg, Settings.githubRepo),
      developers = Seq(
        Developer("lihaoyi", "Li Haoyi", "https://github.com/lihaoyi"),
        Developer("lefou", "Tobias Roeser", "https://github.com/lefou")
      )
    )
  }

  def artifactName = "mill-" + super.artifactName()
  def publishVersion = millVersion()
  def publishProperties = super.publishProperties() ++ Map(
    "info.releaseNotesURL" -> Settings.changelogUrl
  )
  def pomSettings = commonPomSettings(artifactName())
  def javacOptions = Seq("-source", "1.8", "-target", "1.8", "-encoding", "UTF-8")
}

/**
 * Some custom scala settings and test convenience
 */
trait MillScalaModule extends ScalaModule with MillJavaModule /* with ScalafixModule*/ { outer =>
  def scalaVersion = Deps.scalaVersion
  def scalapVersion: T[String] = Deps.scala2Version
  def scalafixScalaBinaryVersion = T {
    def sv = scalaVersion()
    if (JvmWorkerUtil.isScala3(sv)) "2.13"
    else JvmWorkerUtil.scalaBinaryVersion(sv)
  }

  def scalafixConfig = T { Some(T.workspace / ".scalafix.conf") }

  def semanticDbVersion = Deps.semanticDBscala.version

  def scaladocOptions = Seq("-Xsource:3")

  def scalacOptions =
    super.scalacOptions() ++ Seq(
      "-deprecation",
      "-feature"
    ) ++ (
      if (JvmWorkerUtil.isScala3(scalaVersion())) Seq(
        // "-Werror",
        "-Wunused:all",
        // "-Xfatal-warnings",
        "-Wconf:msg=An existential type that came from a Scala-2 classfile:silent",
        "-Wconf:msg=import scala.language.implicitConversions:silent",
        "-Wconf:msg=IterableOnceExtensionMethods:silent",
        "-Wconf:msg=is deprecated:silent",
        "-Wconf:msg=cannot be checked at runtime:silent"
        // "-Wconf:msg=unused:silent"
        // "-no-indent",
        // "-Wvalue-discard",
        // "-Wshadow:all",
        // "-Wsafe-init",
        // "-Wnonunit-statement",
        // "-Wimplausible-patterns",
        // "-rewrite", "-source", "3.6-migration"
      )
      else Seq(
        "-P:acyclic:force",
        // "-Xfatal-warnings",
        "-Xlint:unused",
        "-Xlint:adapted-args",
        "-Xsource:3",
        "-Wconf:msg=inferred type changes:silent",
        "-Wconf:msg=case companions no longer extend FunctionN:silent",
        "-Wconf:msg=access modifiers for:silent",
        "-Wconf:msg=is deprecated:silent",
        "-Wconf:msg=found in a package prefix of the required type:silent"
      )
    )

  def scalacPluginMvnDeps = T {
    val sv = scalaVersion()
    val binaryVersion = JvmWorkerUtil.scalaBinaryVersion(sv)
    val hasModuleDefs = binaryVersion == "2.13" || binaryVersion == "3"
    super.scalacPluginMvnDeps() ++
      Option.when(binaryVersion != "3")(Deps.acyclic) ++
      Option.when(hasModuleDefs)(Deps.millModuledefsPlugin)
  }

  def mandatoryMvnDeps = T {
    val sv = scalaVersion()
    val binaryVersion = JvmWorkerUtil.scalaBinaryVersion(sv)
    val hasModuleDefs = binaryVersion == "2.13" || binaryVersion == "3"
    super.mandatoryMvnDeps() ++
      Option.when(hasModuleDefs)(Deps.millModuledefs)
  }

  /** Default tests module. */
  lazy val test: MillScalaTests = new MillScalaTests {}
  trait MillScalaTests extends ScalaTests with MillJavaModule with MillBaseTestsModule
      /*with ScalafixModule*/ {
    def scalafixConfig = T { Some(T.workspace / ".scalafix.conf") }
    def forkArgs = super.forkArgs() ++ outer.testArgs()
    def moduleDeps = outer.testModuleDeps
    def mvnDeps = super.mvnDeps() ++ outer.testMvnDeps()
    def forkEnv = super.forkEnv() ++ outer.testForkEnv()
  }
}

trait MillBaseTestsModule extends TestModule {
  def forkArgs = Task {
    Seq(
      s"-DMILL_SCALA_3_NEXT_VERSION=${Deps.scalaVersion}",
      s"-DMILL_SCALA_2_13_VERSION=${Deps.scala2Version}",
      s"-DMILL_SCALA_2_12_VERSION=${Deps.workerScalaVersion212}",
      s"-DTEST_SCALA_2_13_VERSION=${Deps.testScala213Version}",
      s"-DTEST_SCALA_2_13_VERSION_FOR_SCALANATIVE_4_2=${Deps.testScala213VersionForScalaNative42}",
      s"-DTEST_SCALA_2_12_VERSION=${Deps.testScala212Version}",
      s"-DTEST_SCALA_3_2_VERSION=${Deps.testScala32Version}",
      s"-DTEST_SCALA_3_3_VERSION=${Deps.testScala33Version}",
      s"-DTEST_SCALAJS_VERSION=${Deps.Scalajs_1.scalaJsVersion}",
      s"-DTEST_SCALANATIVE_0_5_VERSION=${Deps.Scalanative_0_5.scalanativeVersion}",
      s"-DTEST_UTEST_VERSION=${Deps.TestDeps.utest.version}",
      s"-DTEST_SCALATEST_VERSION=${Deps.TestDeps.scalaTest.version}",
      s"-DTEST_TEST_INTERFACE_VERSION=${Deps.sbtTestInterface.version}",
      s"-DTEST_ZIOTEST_VERSION=${Deps.TestDeps.zioTest.version}",
      s"-DTEST_ZINC_VERSION=${Deps.zinc.version}",
      s"-DTEST_KOTLIN_VERSION=${Deps.kotlinCompiler.version}",
      s"-DTEST_SBT_VERSION=${Deps.sbt.version}",
      s"-DTEST_PROGUARD_VERSION=${Deps.RuntimeDeps.proguard.version}",
      s"-DTEST_KOTEST_VERSION=${Deps.RuntimeDeps.kotestJvm.version}"
    )
  }

  def testFramework = "mill.UTestFramework"
  def testParallelism = true
}

/** Published module which does not contain strictly handled API. */
trait MillPublishScalaModule extends MillScalaModule with MillPublishJavaModule

/** Publishable module which contains strictly handled API. */
trait MillStableScalaModule extends MillPublishScalaModule /*with Mima*/ {
  /*
  import com.github.lolgab.mill.mima._
//  override def mimaBinaryIssueFilters: T[Seq[ProblemFilter]] = Seq()

  def mimaPreviousVersions: T[Seq[String]] = Settings.mimaBaseVersions

  def mimaPreviousArtifacts: T[Agg[Dep]] = Task {
    Agg.from(
      Settings.mimaBaseVersions
        .filter(v => !skipPreviousVersions().contains(v))
        .map({ version =>
          val patchedSuffix = {
            val base = artifactSuffix()
            version match {
              case s"0.$minor.$_" if minor.toIntOption.exists(_ < 12) =>
                base match {
                  case "_3" => "_2.13"
                  case s"_3_$suffix" => s"_2.13_$suffix"
                  case _ => base
                }
              case _ => base
            }
          }
          val patchedId = artifactName() + patchedSuffix
          mvn"${pomSettings().organization}:${patchedId}:${version}"
        })
    )
  }

  def mimaExcludeAnnotations = Seq("mill.api.internal", "mill.api.experimental")
//  def mimaCheckDirection = CheckDirection.Backward
  def skipPreviousVersions: T[Seq[String]] = T {
    T.log.info("Skipping mima for previous versions (!!1000s of errors due to Scala 3)")
    mimaPreviousVersions() // T(Seq.empty[String])
  }*/
}

trait MillPublishCrossScalaModule extends MillPublishJavaModule with CrossScalaModule

object bridge extends Cross[BridgeModule](compilerBridgeScalaVersions)
trait BridgeModule extends MillPublishCrossScalaModule {
  def scalaVersion = crossScalaVersion
  def publishVersion = bridgeVersion
  def artifactName = "mill-scala-compiler-bridge"
  def pomSettings = commonPomSettings(artifactName())
  def crossFullScalaVersion = true
  def mvnDeps = Agg(
    mvn"org.scala-sbt:compiler-interface:${Deps.zinc.version}",
    mvn"org.scala-sbt:util-interface:${Deps.zinc.version}"
  ) ++ Agg(
    if (JvmWorkerUtil.isScala3(crossScalaVersion))
      mvn"org.scala-lang::scala3-compiler:${crossScalaVersion}"
    else mvn"org.scala-lang:scala-compiler:${crossScalaVersion}"
  )

  def resources = Task {
    os.copy(generatedSources().head.path / "META-INF", Task.dest / "META-INF")
    Seq(PathRef(Task.dest))
  }

  def compilerBridgeMvnDeps: T[Agg[Dep]] = Agg(
    (if (JvmWorkerUtil.isScala3(crossScalaVersion))
       mvn"org.scala-lang:scala3-sbt-bridge:${crossScalaVersion}"
     else mvn"org.scala-sbt::compiler-bridge:${Deps.zinc.version}").exclude("*" -> "*")
  )

  def compilerBridgeSourceJars: T[Agg[PathRef]] = Task {
    defaultResolver().classpath(
      compilerBridgeMvnDeps().map(bindDependency()),
      sources = true
    )
  }

  def generatedSources = Task {

    compilerBridgeSourceJars().foreach { jar =>
      os.unzip(jar.path, Task.dest)
    }

    Seq(PathRef(Task.dest))
  }
}

def formatDep(dep: Dep) = {
  val d = Lib.depToDependency(dep, Deps.scalaVersion)
  s"${d.module.organization.value}:${d.module.name.value}:${d.versionConstraint.asString}"
}

def listIn(path: os.Path) = interp.watchValue(os.list(path).map(_.last))

val dummyDeps: Seq[Dep] = Seq(
  Deps.DocDeps.millScip,
  Deps.semanticDbJava,
  Deps.semanticDBscala,
  Deps.TestDeps.scalaTest,
  Deps.TestDeps.zioTest,
  Deps.acyclic,
  Deps.scalacScoverage2Plugin,
  mvn"com.lihaoyi:::ammonite:${Deps.ammoniteVersion}"
) ++ Deps.transitiveDeps ++ Deps.RuntimeDeps.all

implicit object DepSegment extends Cross.ToSegments[Dep]({ dep =>
      val depString = formatDep(dep)
      // these cross module names cause problems on windows, and anyway they
      // are not necessary in order to load the project into IntelliJ anyway
      List(depString.replace(':', '_'))
    })

/**
 * Dummy module(s) to let Dependency/showUpdates or Scala-Steward find
 * and bump dependency versions we use at runtime
 */
object dummy extends Cross[DependencyFetchDummy](dummyDeps)
trait DependencyFetchDummy extends ScalaModule with Cross.Module[Dep] {
  def scalaVersion = Deps.scala2Version
  def compileMvnDeps = Agg(crossValue)
}
