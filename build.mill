package build

// imports
import build_.{package_ => build}
import com.github.lolgab.mill.mima.Mima
import coursier.maven.MavenRepository
import de.tobiasroeser.mill.vcs.version.VcsVersion
import com.goyeau.mill.scalafix.ScalafixModule
import mill.{Cross, T, _}
import mill.define.NamedTask
import mill.main.Tasks
import mill.scalalib._
import mill.scalalib.api.ZincWorkerUtil
import mill.scalalib.publish._
import mill.resolve.SelectMode
import mill.api.WorkspaceRoot
import millbuild._

// plugins and dependencies
import $meta._

import $packages._

def millVersion: T[String] = Task.Input {
  if (Task.env.contains("MILL_STABLE_VERSION")) {
    // Ignore local changes when computing the VCS version string,
    // since we make those in CI and can promise they are safe
    VcsVersion.calcVcsState(Task.log).copy(dirtyHash = None).format()
  } else "SNAPSHOT"
}

def millLastTag: T[String] = Task.Input {
  if (Task.env.contains("MILL_STABLE_VERSION")) {
    VcsVersion.calcVcsState(Task.log).lastTag.getOrElse(
      sys.error("No (last) git tag found. Your git history seems incomplete!")
    )
  } else "SNAPSHOT"
}

def millDownloadPrefix = Task {
  s"https://repo1.maven.org/maven2/com/lihaoyi/mill-dist"
}
def millDownloadUrl = Task {
  s"${millDownloadPrefix()}/${millLastTag()}"
}

def millBinPlatform: T[String] = Task {
  val tag = millLastTag()
  if (tag.contains("-M")) tag
  else {
    val pos = if (tag.startsWith("0.")) 2 else 1
    tag.split("[.]", pos + 1).take(pos).mkString(".")
  }
}

def millJvmVersion = Task.Source(Task.workspace / ".mill-jvm-version")

val essentialBridgeScalaVersions =
  Seq(Deps.scalaVersion, Deps.scala2Version, Deps.workerScalaVersion212)
// published compiler bridges
val bridgeScalaVersions = Seq(
  // Our version of Zinc doesn't work with Scala 2.12.0 and 2.12.4 compiler
  // bridges. We skip 2.12.1 because it's so old not to matter, and we need a
  // non-supported scala version for testing purposes. We skip 2.13.0-2 because
  // scaladoc fails on windows
  /*"2.12.0",*/ /*2.12.1",*/ "2.12.2",
  "2.12.3", /*"2.12.4",*/ "2.12.5",
  "2.12.6",
  "2.12.7",
  "2.12.8",
  "2.12.9",
  "2.12.10",
  "2.12.11",
  "2.12.12",
  "2.12.13",
  "2.12.14",
  "2.12.15",
  "2.12.16",
  "2.12.17",
  "2.12.18",
  "2.12.19",
  /*"2.13.0", "2.13.1", "2.13.2",*/
  "2.13.3",
  "2.13.4",
  "2.13.5",
  "2.13.6",
  "2.13.7",
  "2.13.8",
  "2.13.9",
  "2.13.10",
  "2.13.11",
  "2.13.12",
  "2.13.13",
  "2.13.14",
  "2.13.15"
)

// We limit the number of compiler bridges to compile and publish for local
// development and testing, because otherwise it takes forever to compile all
// of them. Compiler bridges not in this set will get downloaded and compiled
// on the fly anyway. For publishing, we publish everything or a specific version
// if given.
val compilerBridgeScalaVersions =
  interp.watchValue(sys.env.get("MILL_COMPILER_BRIDGE_VERSIONS")) match {
    case None | Some("") | Some("none") => Seq.empty[String]
    case Some("all") => (essentialBridgeScalaVersions ++ bridgeScalaVersions).distinct
    case Some("essential") => essentialBridgeScalaVersions
    case Some(versions) => versions.split(',').map(_.trim()).filterNot(_.isEmpty).toSeq
  }
val bridgeVersion = "0.0.1"


object bridge extends Cross[BridgeModule](build.compilerBridgeScalaVersions)
trait BridgeModule extends MillPublishCrossScalaModule {
  def scalaVersion = crossScalaVersion
  def publishVersion = build.bridgeVersion
  def artifactName = "mill-scala-compiler-bridge"
  def pomSettings = commonPomSettings(artifactName())
  def crossFullScalaVersion = true
  def ivyDeps = Agg(
    ivy"org.scala-sbt:compiler-interface:${Deps.zinc.version}",
    ivy"org.scala-sbt:util-interface:${Deps.zinc.version}"
  ) ++ Agg(
    if (ZincWorkerUtil.isScala3(crossScalaVersion))
      ivy"org.scala-lang::scala3-compiler:${crossScalaVersion}"
    else ivy"org.scala-lang:scala-compiler:${crossScalaVersion}"
  )

  def resources = Task {
    os.copy(generatedSources().head.path / "META-INF", Task.dest / "META-INF")
    Seq(PathRef(Task.dest))
  }

  def compilerBridgeIvyDeps: T[Agg[Dep]] = Agg(
    (if (ZincWorkerUtil.isScala3(crossScalaVersion))
      ivy"org.scala-lang:scala3-sbt-bridge:${crossScalaVersion}"
    else ivy"org.scala-sbt::compiler-bridge:${Deps.zinc.version}").exclude("*" -> "*")
  )

  def compilerBridgeSourceJars: T[Agg[PathRef]] = Task {
    defaultResolver().resolveDeps(
      compilerBridgeIvyDeps().map(bindDependency()),
      sources = true
    )
  }

  def generatedSources = Task {

    compilerBridgeSourceJars().foreach { jar =>
      os.unzip(jar.path, Task.dest)
    }

    Seq(PathRef(Task.dest))
  }
}

def formatDep(dep: Dep) = {
  val d = Lib.depToDependency(dep, Deps.scalaVersion)
  s"${d.module.organization.value}:${d.module.name.value}:${d.version}"
}

def listIn(path: os.Path) = interp.watchValue(os.list(path).map(_.last))

object idea extends MillPublishScalaModule {
  def moduleDeps = Seq(build.scalalib, build.runner)
}

val dummyDeps: Seq[Dep] = Seq(
  Deps.DocDeps.millScip,
  Deps.semanticDbJava,
  Deps.semanticDBscala,
  Deps.TestDeps.scalaTest,
  Deps.TestDeps.zioTest,
  Deps.acyclic,
  Deps.scalacScoverage2Plugin,
  ivy"com.lihaoyi:::ammonite:${Deps.ammoniteVersion}"
) ++ Deps.transitiveDeps ++ Deps.RuntimeDeps.all

implicit object DepSegment extends Cross.ToSegments[Dep]({ dep =>
      val depString = formatDep(dep)
      // these cross module names cause problems on windows, and anyway they
      // are not necessary in order to load the project into IntelliJ anyway
      List(depString.replace(':', '_'))
    })

/**
 * Dummy module(s) to let Dependency/showUpdates or Scala-Steward find
 * and bump dependency versions we use at runtime
 */
object dummy extends Cross[DependencyFetchDummy](dummyDeps)
trait DependencyFetchDummy extends ScalaModule with Cross.Module[Dep] {
  def scalaVersion = Deps.scala2Version
  def compileIvyDeps = Agg(crossValue)
}
