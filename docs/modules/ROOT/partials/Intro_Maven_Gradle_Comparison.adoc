

Mill borrows ideas from other tools like https://maven.apache.org/[Maven],
https://gradle.org/[Gradle], https://bazel.build/[Bazel], but tries to learn from the
strengths of each tool and improve on their weaknesses. Although Maven and Gradle
are mature widely-used tools, they have fundamental limitations in their design
(https://blog.ltgt.net/maven-is-broken-by-design/[Maven Design],
https://www.bruceeckel.com/2021/01/02/the-problem-with-gradle/[Gradle Design]) that make
them difficult to improve upon incrementally.

xref:comparisons/maven.adoc[Compared to Maven]:

* **Mill follows Maven's innovation of good built-in defaults**: Mill's built-in
  ``JavaModule``s follow Maven's "convention over configuration" style. Small mill
  projects require minimal effort to get started, and larger Mill projects have a consistent
  structure building on these defaults.

* **Mill makes customizing the build tool much easier than Maven**. Projects usually
  grow beyond just compiling a single language: needing custom
  code generation, linting workflows, output artifacts, or support for
  additional languages. Mill makes doing this yourself easy, so you are not beholden
  to third-party plugins that may not exist, be well maintained, or interact well with each other.

* **Mill automatically caches and parallelizes your build**: Not just the
  built-in tasks that Mill ships with, but also any custom tasks or modules.
  This maximizes performance and snappiness of
  your command-line build workflows, and especially matters in larger codebases where builds
  tend to get slow: a Maven `clean install` taking over a minute might take just a 
  few seconds in Mill.

xref:comparisons/gradle.adoc[Compared to Gradle]:

* **Mill follows Gradle's conciseness**: Rather than pages and pages of verbose XML, every
  line in a Mill build is meaningful. e.g. adding a dependency is 1 line in
  Mill, like it is in Gradle, and unlike the 5 line `<dependency>` declaration you find in Maven.
  Skimming and understanding a 100-line Mill `build.mill` file is
  often much easier than skimming the equivalent 500-line Maven `pom.xml`.

* **Mill builds more performant**: Although both Mill and Gradle automatically cache and
  parallelize your build, Mill does so with much less fixed overhead, resulting in 2-3x
  speedups in common command-line workflows. This means less time waiting for your build
  tool, and more time focusing on the things that really matter to your project.

* **Mill enforces best practices by default**. All Mill tasks are cached by default, even
  custom tasks. All Mill tasks write their output to disk xref:depth/out-dir.adoc[a
  standard place]. All task inter-dependencies are automatically captured, without
  needing manual annotation. All Mill builds are incremental, not just tasks but also
  xref:depth/evaluation-model.adoc#_caching_at_each_layer_of_the_evaluation_model[configuration
  and other phases]. Where Gradle requires considerable
  https://docs.gradle.org/current/userguide/incremental_build.html[effort and expertise]
  to maintain your build, Mill automates it so the
  easiest thing to do is almost always the right thing to do.

Mill build files are written in Scala, but you do not need to have prior experience
in Scala to read or write them. Like Gradle Groovy or Maven XML, it's easy to learn
enough Scala for Mill without needing to become an expert in the language.

