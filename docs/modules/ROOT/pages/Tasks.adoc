= Tasks

One of Mill's core abstractions is its _Task Graph_: this is how Mill defines,
orders and caches work it needs to do, and exists independently of any support
for building Scala.

Mill target graphs are primarily built using methods and macros defined on
`mill.define.Target`, aliased as `T` for conciseness:

- {mill-doc-url}/api/latest/mill/define/Target$.html[mill.define.Target]

include::example/tasks/1-task-graph.adoc[]

== Primary Tasks

include::example/tasks/2-primary-tasks.adoc[]

== Other Tasks

* <<_anonymous_tasks>>, defined using `T.task {...}`
* <<_persistent_targets>>
* <<_inputs>>
* <<_workers>>

=== Anonymous Tasks

[source,scala]
----
def foo(x: Int) = T.task { ... x ... bar() ... }
----

You can define anonymous tasks using the `T.task {...}` syntax.
These are not runnable from the command-line, but can be used to share common code you find yourself repeating in ``Target``s and ``Command``s.

[source,scala]
----
def downstreamTarget = T { ... foo(42)() ... } 
def downstreamCommand(x: Int) = T.command { ... foo(x)() ... }
----

Anonymous task's output does not need to be JSON-serializable, their output is
not cached, and they can be defined with or without arguments.
Unlike <<_targets>> or <<_commands>>, anonymous tasks can be defined
anywhere and passed around any way you want, until you finally make use of them
within a downstream target or command.

While an anonymous task ``foo``'s own output is not cached, if it is used in a
downstream target `baz` and the upstream target `bar` hasn't changed,
``baz``'s cached output will be used and ``foo``'s evaluation will be skipped
altogether.

=== Persistent Targets

[source,scala]
----
def foo = T.persistent { ... }
----

Identical to <<_targets>>, except that the `dest/` folder is not cleared in between runs.

This is useful if you are running external incremental-compilers, such as
Scala's https://github.com/sbt/zinc[Zinc], Javascript's
https://webpack.js.org/[WebPack], which rely on filesystem caches to speed up
incremental execution of their particular build step.

Since Mill no longer forces a "clean slate" re-evaluation of `T.persistent`
targets, it is up to you to ensure your code (or the third-party incremental
compilers you rely on!) are deterministic. They should always converge to the
same outputs for a given set of inputs, regardless of what builds and what
filesystem states existed before.

=== Inputs

[source,scala]
----
def foo = T.input { ... }
----

A generalization of <<_sources>>, ``T.input``s are tasks that re-evaluate
_every time_ (unlike <<_anonymous_tasks>>), containing an
arbitrary block of code.

Inputs can be used to force re-evaluation of some external property that may
affect your build. For example, if I have a <<_targets, Target>> `bar` that makes
use of the current git version:


[source,scala]
----
def bar = T { ... os.proc("git", "rev-parse", "HEAD").call().out.text() ... }
----

`bar` will not know that `git rev-parse` can change, and will
not know to re-evaluate when your `git rev-parse HEAD` _does_ change. This means
`bar` will continue to use any previously cached value, and ``bar``'s output will
be out of date!

To fix this, you can wrap your `git rev-parse HEAD` in a `T.input`:

[source,scala]
----
def foo = T.input { os.proc("git", "rev-parse", "HEAD").call().out.text() }
def bar = T { ... foo() ... }
----

This makes `foo` to always re-evaluate every build; if `git rev-parse HEAD`
does not change, that will not invalidate ``bar``'s caches.
But if `git rev-parse HEAD` _does_ change, ``foo``'s output will change and `bar` will be correctly invalidated and re-compute using the new version of `foo`.

Note that because ``T.input``s re-evaluate every time, you should ensure that the
code you put in `T.input` runs quickly. Ideally it should just be a simple check
"did anything change?" and any heavy-lifting should be delegated to downstream
targets.

=== Workers

[source,scala]
----
def foo = T.worker { ... }
----

Most tasks dispose of their in-memory return-value every evaluation; in the case
of <<_targets>>, this is stored on disk and loaded next time if
necessary, while <<_commands>> just re-compute them each time.
Even if you use `--watch` or the Build REPL to keep the Mill process running, all this state is still discarded and re-built every evaluation.

Workers are unique in that they store their in-memory return-value between
evaluations.
This makes them useful for storing in-memory caches or references to long-lived external worker processes that you can re-use.

Mill uses workers to manage long-lived instances of the
https://github.com/sbt/zinc[Zinc Incremental Scala Compiler] and the
https://github.com/scala-js/scala-js[Scala.js Optimizer].
This lets us keep them in-memory with warm caches and fast incremental execution.

Like <<_persistent_targets>>, Workers inherently involve
mutable state, and it is up to the implementation to ensure that this mutable
state is only used for caching/performance and does not affect the
externally-visible behavior of the worker.

=== `Autoclosable` Workers

As <<Workers>> may also hold limited resources, it may be necessary to free up these resources once a worker is no longer needed.
This is especially the case, when your worker tasks depends on other tasks and these tasks change, as Mill will then also create a new worker instance.

To implement resource cleanup, your worker can implement `java.lang.AutoCloseable`.
Once the worker is no longer needed, Mill will call the `close()` method on it before any newer version of this worker is created.

[source,scala]
----
import mill._
import java.lang.AutoCloseable

def myWorker = T.worker {
  new MyWorker with AutoCloseable {
    // ...
    override def close() = { /* cleanup and free resources */ }
  }
}
----

== Task Cheat Sheet

The following table might help you make sense of the small collection of
different Task types:

[cols="<,<,<,<,<,<,<"]
|===
| |Target |Command |Source/Input |Anonymous Task |Persistent Target |Worker 

|Cached to Disk |X |X | | |X |
|Must be JSON Writable |X |X |X| |X |
|Must be JSON Readable |X | | | |X | 
|Runnable from the Command Line |X |X | | |X | 
|Can Take Arguments | |X | |X | | 
|Cached between Evaluations | | | | | |X 
|===