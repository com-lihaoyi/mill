= Why Mill?

Mill is a fast build tool for Java, Scala, and Kotlin. Although the Java
compiler is very fast and the Java language is easy to learn, JVM build tools are
known to be sluggish and confusing. Mill offers a better alternative: 2-10x faster
than Maven or Gradle, better IDE support, and extensibility without needing plugins.

At a first glance, Mill looks like any other build tool. You have build files, you configure
dependencies, you can compile, run, or test your project:

```scala
// build.mill
package build
import mill._, javalib._

object foo extends JavaModule {
  def ivyDeps = Agg(
    ivy"net.sourceforge.argparse4j:argparse4j:0.9.0",
    ivy"org.thymeleaf:thymeleaf:3.1.1.RELEASE"
  )

  object test extends JavaTests with TestModule.Junit4
}
```
```bash
> /mill foo.compile
compiling 1 Java source...

> /mill foo.run --text hello
<h1>hello</h1>

> ./mill foo.test
Test foo.FooTest.testEscaping finished, ...
Test foo.FooTest.testSimple finished, ...
0 failed, 0 ignored, 2 total, ...
```

In general, Mill provides 3 major advantages over other build tools. The comparison pages
for the respective build tool go into more detail (for xref:comparisons/maven.adoc[Maven],
xref:comparisons/gradle.adoc[Gradle], and xref:comparisons/sbt.adoc[SBT])

1. Performance
    * *Mill offers a 2-10x speedup means less time waiting for your build tool*, meaning
      less time waiting for your build and more time doing useful work

2. Ease of Use
   * *Mill offers better IDE support in IntelliJ and VSCode and rich visualization tools*,
     to help understand your build and what it is doing

3. Extensibility
    * *Directly write code or use any Java library from Maven Central in your build*,
      without being beholden to third party plugins that may not exist or be well maintained.

We will discuss each one in turn:

## Performance

### Maven
|===
| Benchmark | Maven | Mill | Speedup
| xref:comparisons/maven.adoc#_sequential_clean_compile_all[Sequential Clean Compile All] | 2m 31.12s | 0m 22.19s | 6.8x
| xref:comparisons/maven.adoc#_parallel_clean_compile_all[Parallel Clean Compile All] | 1m 16.45s | 0m 09.95s | 7.7x
| xref:comparisons/maven.adoc#_clean_compile_single_module[Clean Compile Single Module] | 0m 19.62s | 0m 02.17s | 9.0x
| xref:comparisons/maven.adoc#_incremental_compile_single_module[Incremental Compile Single Module] | 0m 21.10s | 0m 00.54s | 39.1x
| xref:comparisons/maven.adoc#_no_op_compile_single_module[No-Op Compile Single Module] | 0m 17.34s | 0m 00.47s | 36.9x
|===

For the purposes of this page, we will focus on two benchmarks

#### Parallel Clean Compile All

|===
| Benchmark | Maven | Mill | Speedup
| xref:comparisons/maven.adoc#_parallel_clean_compile_all[Parallel Clean Compile All] | 1m 16.45s | 0m 09.95s | 7.7x
|===

```bash
> time ./mvnw -T 10 -DskipTests  -Dcheckstyle.skip -Denforcer.skip=true clean install

> ./mill clean; time ./mill __.compile
```

#### Incremental Compile Single-Module

|===
| Benchmark | Maven | Mill | Speedup
| xref:comparisons/maven.adoc#_incremental_compile_single_module[Incremental Compile Single Module] | 0m 21.10s | 0m 00.54s | 39.1x
|===

```bash
$ echo "" >> common/src/main/java/io/netty/util/AbstractConstant.java
$ time ./mvnw -pl common -DskipTests  -Dcheckstyle.skip -Denforcer.skip=true install
Compiling 174 source files to /Users/lihaoyi/Github/netty/common/target/classes
Compiling 60 source files to /Users/lihaoyi/Github/netty/common/target/test-classes


$ echo "" >> common/src/main/java/io/netty/util/AbstractConstant.java
$ time ./mill common.test.compile
compiling 1 Java source to /Users/lihaoyi/Github/netty/out/common/compile.dest/classes ...
```


### Gradle

|===
| Benchmark | Gradle | Mill | Speedup
| xref:comparisons/maven.adoc#_sequential_clean_compile_all[Sequential Clean Compile All] | 17.6s | 5.40s | 3.3x
| xref:comparisons/maven.adoc#_parallel_clean_compile_all[Parallel Clean Compile All] | 12.3s | 3.57s | 3.4x
| xref:comparisons/maven.adoc#_clean_compile_single_module[Clean Compile Single Module] | 4.41s | 1.20s | 3.7x
| xref:comparisons/maven.adoc#_incremental_compile_single_module[Incremental Compile Single Module] | 1.37s | 0.51s | 2.7x
| xref:comparisons/maven.adoc#_no_op_compile_single_module[No-Op Compile Single Module] | 0.94s | 0.46s | 2.0x
|===

Again, for the purposes of this page, we will focus on two benchmarks

#### Parallel Clean Compile All

|===
| Benchmark | Gradle | Mill | Speedup
| xref:comparisons/maven.adoc#_parallel_clean_compile_all[Parallel Clean Compile All] | 12.3s | 3.57s | 3.4x
|===

```bash
$ ./gradlew clean; time ./gradlew classes testClasses --no-build-cache

$ ./mill clean; time ./mill __.compile
```

#### Incremental Compile Single-Module


|===
| Benchmark | Gradle | Mill | Speedup
| xref:comparisons/maven.adoc#_incremental_compile_single_module[Incremental Compile Single Module] | 1.37s | 0.51s | 2.7x
|===

```bash
$ echo "" >> src/main/java/org/mockito/BDDMockito.java; time ./gradlew :classes

$ echo "" >> src/main/java/org/mockito/BDDMockito.java; time ./mill compile
compiling 1 Java source to /Users/lihaoyi/Github/netty/out/common/compile.dest/classes ...
```

## Ease of Use

### Chrome Profiles
### Mill Visualize
### IDE Support

## Extensibility

### Simple Custom Tasks

```scala
package build
import mill._, javalib._

object foo extends JavaModule {
}
```
```bash
> mill compile
Compiling 1 Java source...
```



```scala
package build
import mill._, javalib._

object foo extends JavaModule {
  /** Total number of lines in module source files */
  def lineCount = Task {
    allSourceFiles().map(f => os.read.lines(f.path).size).sum
  }
}
```
```bash
> mill show foo.lineCount
17
```



```scala
package build
import mill._, javalib._

object foo extends JavaModule {
  /** Total number of lines in module source files */
  def lineCount = Task {
    allSourceFiles().map(f => os.read.lines(f.path).size).sum
  }

  /** Generate resources using lineCount of sources */
  override def resources = Task {
    os.write(Task.dest / "line-count.txt", "" + lineCount())
    super.resources() ++ Seq(PathRef(Task.dest))
  }
}
```
```bash
> mill foo.run
Line Count: 17
```



### Using Libraries from Maven Central in Tasks


```scala
package build
import mill._, javalib._
import $ivy.`org.thymeleaf:thymeleaf:3.1.1.RELEASE`
import org.thymeleaf.TemplateEngine
import org.thymeleaf.context.Context
object foo extends JavaModule {
  def htmlSnippet = Task {
    val context = new Context()
    context.setVariable("heading", "hello")
    new TemplateEngine().process(
        "<h1 th:text=\"${heading}\"></h1>",
        context
    )
  }
  def resources = Task.Sources{
    os.write(Task.dest / "snippet.txt", htmlSnippet())
    super.resources() ++ Seq(PathRef(Task.dest))
  }
}
```
```bash
> mill show foo.htmlSnippet
"<h1>hello</h1>"

> mill foo.compile
compiling 1 Java source...
...

> mill foo.run
generated snippet.txt resource: <h1>hello</h1>
```

## Conclusion