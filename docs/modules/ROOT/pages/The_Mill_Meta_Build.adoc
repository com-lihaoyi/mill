
= The Mill Meta-Build

The meta-build manages the compilation of the `build.sc`.
If you don't configure it explicitly, a built-in synthetic meta-build is used.

To customize it, you need to explicitly enable it with `import $meta._`.
Once enabled, the meta-build lives in the `mill-build/` directory.
It needs to contain a top-level module of type `MillBuildRootModule`.

Meta-builds are recursive, which means, it can itself have a nested meta-builds, and so on.

To run a task on a meta-build, you specifying the `--meta-level` option to select the meta-build level.

== Autoformatting the `build.sc`

As an example of running a task on the meta-build, you can format the `build.sc` with Scalafmt.
Everything is already provided by Mill.
You only need a `.scalafmt.conf` config file which at least needs configure the Scalafmt version.

.Run Scalafmt on the `build.sc` (and potentially included files)
----
$ mill --meta-level 1 mill.scalalib.scalafmt.ScalafmtModule/reformatAll sources
----

* `--meta-level 1` selects the first meta-build. Without any customization, this is the only built-in meta-build.
* `mill.scalalib.scalafmt.ScalafmtModule/reformatAll` is a generic task to format scala source files with Scalafmt. It requires the targets that refer to the source files as argument
* `sources` this selects the `sources` targets of the meta-build, which at least contains the `build.sc`.

== Finding plugin updates

Mill plugins are defined as `ivyDeps` in the meta-build.
Hence, you can easily search for updates with the external `mill.scalalib.Dependency` module.

.Check for Mill Plugin updates
----
$ mill --meta-level 1 mill.scalalib.Dependency/showUpdates
Found 1 dependency update for
de.tototec:de.tobiasroeser.mill.vcs.version_mill0.11_2.13 : 0.3.1-> 0.4.0
----

== Sharing Libraries between `build.sc` and Application Code

include::example/extending/metabuild/4-meta-build.adoc[]

== Sharing Source Code between `build.sc` and Application Code

include::example/extending/metabuild/5-meta-shared-sources.adoc[]