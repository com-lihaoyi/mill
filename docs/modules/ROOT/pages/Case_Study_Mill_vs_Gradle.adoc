= Case Study: Mill vs Gradle

++++
<script>
gtag('config', 'AW-16649289906');
</script>
++++

This page compares using Mill to Gradle, using the https://github.com/mockito/mockito[Mockito Testing Library]
codebase as the example. Netty is a medium sized codebase, 100,000 lines of Java split over 22
subprojects. By porting it to Mill, this case study should give you
an idea of how Mill compares to Maven in more realistic, real-world projects.

To do this, we have written a Mill `build.sc` file for the Mockito project. This can be used
with Mill to build and test the various submodules of the Mockito project without needing to
change any other files in the repository:

- https://github.com/com-lihaoyi/mill/blob/main/example/thirdparty/mockity/build.sc[Mockito build.sc file]

== Completeness

The Mill build for Mockito is not 100% complete, but it covers most of the major parts of Mockito:
compiling Java, running JUnit tests. For now, the Java 21, Android, and OSGI tests are skipped.

The goal of this exercise is not to be 100% feature complete enough to replace the Gradle build
today. It is instead meant to provide a realistic comparison of how using Mill in a realistic,
real-world project compares to using Gradle.


== Performance

The Mill build for Netty is much more performant than the default Maven build. This applies to
most workflows.

For the benchmarks below, each provided number is the wall time of three consecutive runs
on my M1 Macbook Pro. While ad-hoc, these benchmarks are enough to give you a flavor of how
Mill's performance compares to Maven:

[cols="1,1,1,1"]
|===
| Benchmark | Maven | Mill | Speedup

| <<Sequential Clean Compile All>> | 2m 31.12s | 0m 22.19s | 6.8x

| <<Parallel Clean Compile All>> | 1m 16.45s | 0m 09.95s | 7.7x
| <<Clean Compile Single-Module>> | 0m 19.62s | 0m 02.17s | 9.0x
| <<Incremental Compile Single-Module>> | 0m 21.10s | 0m 00.54s | 39.1x
| <<No-Op Compile Single-Module>> | 0m 17.34s | 0m 00.47s | 39.1x
|===

The column on the right shows the speedups of how much faster Mill is compared to the
equivalent Maven workflow. In most cases,  Mill is 5-10x faster than Maven. Below, we
will go into more detail of each benchmark: how they were run, what they mean, and how
we can explain the difference in performing the same task with the two different build tools.

=== Sequential Clean Compile All

```bash
$ ./gradlew clean && time ./gradlew --no-build-cache build -x test

$ ./mill clean; time ./mill __.compile
```

=== Parallel Clean Compile All

```bash
$ time ./mvnw -T 4 -DskipTests  -Dcheckstyle.skip -Denforcer.skip=true clean install

$ ./mill clean; time ./mill -j 4  __.compile
```

=== Clean Compile Single-Module

```bash
$ time ./mvnw -pl common -DskipTests  -Dcheckstyle.skip -Denforcer.skip=true clean install

$ ./mill clean common; time ./mill common.test.compile
```

=== Incremental Compile Single-Module

```bash
$ echo "" >> common/src/main/java/io/netty/util/AbstractConstant.java
$ time ./mvnw -pl common -DskipTests  -Dcheckstyle.skip -Denforcer.skip=true install
Compiling 174 source files to /Users/lihaoyi/Github/netty/common/target/classes
Compiling 60 source files to /Users/lihaoyi/Github/netty/common/target/test-classes



$ echo "" >> common/src/main/java/io/netty/util/AbstractConstant.java
$ time ./mill common.test.compile
compiling 1 Java source to /Users/lihaoyi/Github/netty/out/common/compile.dest/classes ...

```

=== No-Op Compile Single-Module

```bash
$ time ./mvnw -pl common -DskipTests  -Dcheckstyle.skip -Denforcer.skip=true install

$ time ./mill common.test.compile
```

