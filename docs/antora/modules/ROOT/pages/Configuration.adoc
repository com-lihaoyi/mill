= Configuring your Project
:page-aliases: Configuring_Mill.adoc

You can configure your Mill build in a number of ways:

include::example/config/1-compilation-execution-flags.adoc[]

include::example/config/2-ivy-deps.adoc[]

include::example/config/3-run-compile-time-dependencies.adoc[]

include::example/config/4-scala-compiler-plugins.adoc[]

include::example/config/5-scaladoc.adoc[]

include::example/config/6-unmanaged-jars.adoc[]

include::example/config/7-main-class.adoc[]

include::example/config/8-downloading-non-maven-jars.adoc[]

include::example/config/9-assembly-config.adoc[]

include::example/config/10-repository-config.adoc[]

include::example/config/11-backticked-names.adoc[]

== Adding a Test Suite

.`build.sc`
[source,scala,subs="attributes,verbatim"]
----
import mill._, scalalib._

object foo extends ScalaModule {
  def scalaVersion = "{example-scala-2-13-version}"

  object test extends Tests {
    def ivyDeps = Agg(ivy"com.lihaoyi::utest:{example-utest-version}")
    def testFramework = "utest.runner.Framework"
  }
}
----

For convenience, you can also use one of the predefined test frameworks:

* `TestModule.Junit4`
* `TestModule.Junit5`
* `TestModule.TestNg`
* `TestModule.Munit`
* `TestModule.ScalaTest`
* `TestModule.Specs2`
* `TestModule.Utest`
* `TestModule.ZioTest`


.`build.sc`: `ScalaModule` with UTest tests using the predefined `TestModule.Utest`
[source,scala,subs="attributes,verbatim"]
----
import mill._, scalalib._

object foo extends ScalaModule {
  def scalaVersion = "{example-scala-2-13-version}"

  object test extends Tests with TestModule.Utest {
    def ivyDeps = Agg(ivy"com.lihaoyi::utest:{example-utest-version}")
  }
}
----



* {mill-github-url}/releases/download/{mill-last-tag}/{mill-last-tag}-example-3.zip[Example 3]

You can define a test suite by creating a nested module extending `Tests`, and
specifying the ivy coordinates and name of your test framework. This expects the
tests to be laid out as follows:

----
build.sc
foo/
    src/
        Example.scala
    resources/
        ...
    test/
        src/
            ExampleTest.scala
        resources/
            ...
out/
    foo/
        ...
        test/
            ...
----

The above example can be run via

[source,bash]
----
mill foo.test
----

By default, tests are run in a subprocess, and `forkArg` and `forkEnv` can be
overridden to pass JVM flags &amp; environment variables. You can also use

[source,bash]
----
mill foo.test.testLocal
----

To run tests in-process in an isolated classloader.

If you want to pass any arguments to the test framework, simply put them after
`foo.test` in the command line. e.g. {utest-github-url}[uTest]
lets you pass in a selector to decide which test to run, which in Mill would be:

[source,bash]
----
mill foo.test foo.MyTestSuite.testCaseName
----

You can define multiple test suites if you want, e.g.:

.`build.sc`
[source,scala,subs="attributes,verbatim"]
----
import mill._, scalalib._

object foo extends ScalaModule {
  def scalaVersion = "{example-scala-2-13-version}"

  object test extends Tests with TestModule.Utest {
    def ivyDeps = Agg(ivy"com.lihaoyi::utest:{example-utest-version}")
  }
  object integration extends Tests with TestModule.Utest {
    def ivyDeps = Agg(ivy"com.lihaoyi::utest:{example-utest-version}")
  }
}
----

Each of which will expect their sources to be in their respective `foo/test` and
`foo/integration` folder.

`Tests` modules are ``ScalaModule``s like any other, and all the same
configuration options apply.

== Custom Test Frameworks

Integrating with test frameworks like Scalatest or specs2 is simply a matter of adding it to `ivyDeps` and specifying the `testFramework` you want to use.

Scalatest example:

.`build.sc`
[source,scala,subs="attributes,verbatim"]
----
import mill._, scalalib._

object foo extends ScalaModule {
  def scalaVersion = "{example-scala-2-13-version}"

  object test extends Tests with TestModule.ScalaTest {
    def ivyDeps = Agg(ivy"org.scalatest::scalatest:3.0.4")
  }
}
----

Specs2 example:

.`build.sc`
[source,scala,subs="attributes,verbatim"]
----
import mill._, scalalib._

object foo extends ScalaModule {
  def scalaVersion = "{example-scala-2-13-version}"

  object test extends Tests with TestModule.Specs2 {
    def ivyDeps = Agg(ivy"org.specs2::specs2-core:4.6.0")
  }
}
----

ZIO-test example:

.`build.sc`
[source,scala,subs="attributes,verbatim"]
----
import mill._, scalalib._

object foo extends ScalaModule {
  def scalaVersion = "{example-scala-3-version}"

  object test extends Tests with TestModule.ZioTest {
    def ivyDeps = Agg(
      ivy"dev.zio::zio-test:2.0.12",
      ivy"dev.zio::zio-test-sbt:2.0.12",
    )
  }
}
----

After that, you can follow the instructions in <<_adding_a_test_suite>>, and use `mill foo.test` as usual, or pass args to the test suite via `mill foo.test arg1 arg2 arg3`.



== Reformatting your code

Mill supports code formatting via https://scalameta.org/scalafmt/[scalafmt] out of the box.

To have a formatting per-module you need to make your module extend `mill.scalalib.scalafmt.ScalafmtModule`:

.`build.sc`
[source,scala,subs="attributes,verbatim"]
----
import mill._, scalalib._, scalafmt._

object foo extends ScalaModule with ScalafmtModule {
  def scalaVersion = "{example-scala-2-13-version}"
}
----

Now you can reformat code with `mill foo.reformat` command, or only check for misformatted files with `mill foo.checkFormat`.

You can also reformat your project's code globally with `+mill mill.scalalib.scalafmt.ScalafmtModule/reformatAll __.sources+` command,
or only check the code's format with `+mill mill.scalalib.scalafmt.ScalafmtModule/checkFormatAll __.sources+`.
It will reformat all sources that matches `+__.sources+` query.

If you add a `.scalafmt.conf` file at the root of you project, it will be used
to configure formatting. It can contain a `version` key to specify the scalafmt
version used to format your code. See the
https://scalameta.org/scalafmt/docs/configuration.html[scalafmt configuration documentation]
for details.


== Using the Ammonite Repl / Scala console

All ``ScalaModule``s have a `console` and a `repl` target, to start a Scala console or an Ammonite Repl.

To use the latter, you can (and sometimes need to) customize the Ammonite version to work with your selected Scala version.
The default Ammonite version is the one, which is used by Mill internally (Mill's `build.sc` is an Ammonite script, after all).
But depending on the Scala version you are using, there is probably no matching Ammonite release available.
In order to start the repl, you have to specify a different available Ammonite version.

.Example: Overriding `ammoniteVersion` to select a release compatible to the `scalaVersion`
[source,scala,subs="attributes,verbatim"]
----
import mill._. scalalib._

object foo extends ScalaModule {
  def scalaVersion = "2.12.6"
  def ammoniteVersion = "2.4.0"
}
----

[TIP]
--
_Why is Ammonite tied to the exact Scala version?_

This is because Ammonite depends on the Scala compiler.
In contrast to the Scala library, compiler releases do not guarantee any binary compatibility between releases.
As a consequence, Ammonite needs full Scala version specific releases.

The older your used Mill version or the newer the Scala version you want to use, the higher is the risk that the default Ammonite version will not match.
--
