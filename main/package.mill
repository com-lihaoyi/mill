package build.main
// imports
import mill._
import mill.scalalib._
import mill.contrib.buildinfo.BuildInfo
import mill.T
import mill.define.Cross
import mill.scalalib.api.ZincWorkerUtil

object `package` extends RootModule with build.MillStableScalaModule with BuildInfo {

  def moduleDeps = Seq(eval, resolve, client)
  def ivyDeps = Agg(
    build.Deps.windowsAnsi,
    build.Deps.coursierInterface,
    build.Deps.mainargs,
    build.Deps.requests,
    build.Deps.logback,
    build.Deps.jgraphtCore,
    ivy"guru.nidi:graphviz-java-min-deps:0.18.1"
      // We only need the in-memory library for some stuff, and don't
      // need the heavyweight v8 binary that comes bundled with it
      .exclude("guru.nidi.com.eclipsesource.j2v8" -> "j2v8_macosx_x86_64")
  )

  def compileIvyDeps = Task {
    if (ZincWorkerUtil.isScala3(scalaVersion())) Agg.empty
    else Agg(build.Deps.scalaReflect(scalaVersion()))
  }

  def buildInfoPackageName = "mill.main"

  private def dist = build.dist.dist0
  // Inlining this method below currently triggers an error like
  // java.lang.IllegalArgumentException: Could not find proxy for â€¦
  private def distAllDeps = dist +: dist.recursiveModuleDeps

  def buildInfoMembers = Seq(
    BuildInfo.Value("scalaVersion", scalaVersion(), "Scala version used to compile mill core."),
    BuildInfo.Value(
      "workerScalaVersion213",
      build.Deps.scala2Version,
      "Scala 2.13 version used by some workers."
    ),
    BuildInfo.Value(
      "workerScalaVersion212",
      build.Deps.workerScalaVersion212,
      "Scala 2.12 version used by some workers."
    ),
    BuildInfo.Value("millVersion", build.millVersion(), "Mill version."),
    BuildInfo.Value("millBinPlatform", build.millBinPlatform(), "Mill binary platform version."),
    BuildInfo.Value(
      "millDistModule", {
        val selfDep = dist.artifactMetadata()
        s"${selfDep.group}:${selfDep.id}"
      },
      "Coordinates of the module pulling the whole of Mill"
    ),
    BuildInfo.Value(
      "millEmbeddedDeps", {
        // Maps internal modules from JavaModule#coursierDependency (like 'mill-internal:thing:0+mill-internal')
        // to actual coordinates used for publishing (like 'com.lihaoyi:mill-thing:0.13.1')
        val internalToPublishedModuleMap = Task.traverse(
          distAllDeps.collect { case m: PublishModule => m }
        ) { mod =>
          Task.Anon {
            val selfDep = mod.artifactMetadata()
            (
              s"${mod.coursierDependency.module.repr}:${mod.coursierDependency.version}",
              s"${selfDep.group}:${selfDep.id}:${selfDep.version}"
            )
          }
        }().toMap

        val result = Lib.resolveDependenciesMetadataSafe(
          repositories = dist.allRepositories(),
          Seq(BoundDep(dist.coursierDependency, force = false)),
          Some(dist.mapDependencies()),
          dist.resolutionCustomizer(),
          Some(Task.ctx()),
          dist.coursierCacheCustomizer()
        )
        result.getOrThrow.orderedDependencies
          .map(dep => s"${dep.module.repr}:${dep.version}")
          .distinct
          .map(mod => internalToPublishedModuleMap.getOrElse(mod, mod))
          .mkString(",")
      },
      "All Mill distribution dependencies"
    ),
    BuildInfo.Value(
      "millScalacPluginDeps",
      build.Deps.millModuledefsString,
      "Scalac compiler plugin dependencies to compile the build script."
    )
  )

  object api extends build.MillStableScalaModule with BuildInfo {
    def moduleDeps = Seq(client)
    def buildInfoPackageName = "mill.api"
    def buildInfoMembers = Seq(
      BuildInfo.Value("millVersion", build.millVersion(), "Mill version."),
      BuildInfo.Value("millDocUrl", build.Settings.docUrl, "Mill documentation url."),
      BuildInfo.Value(
        "millReportNewIssueUrl",
        build.Settings.newIssueUrl,
        "URL to create a new issue in Mills issue tracker."
      )
    )

    def ivyDeps = Agg(
      build.Deps.osLib,
      build.Deps.mainargs,
      build.Deps.upickle,
      build.Deps.pprint,
      build.Deps.fansi,
      build.Deps.sbtTestInterface
    )
  }

  object util extends build.MillStableScalaModule {
    def moduleDeps = Seq(api, client)
    def ivyDeps = Agg(
      build.Deps.coursier,
      build.Deps.coursierJvm,
      build.Deps.jline
    )
  }

  object define extends build.MillStableScalaModule {
    def moduleDeps = Seq(api, util)
    def compileIvyDeps = Task {
      if (ZincWorkerUtil.isScala3(scalaVersion())) Agg(build.Deps.scalaCompiler(scalaVersion()))
      else Agg(build.Deps.scalaReflect(scalaVersion()))
    }
    def ivyDeps = Agg(
      build.Deps.millModuledefs,
      // TODO: somewhere sourcecode is included transitively,
      // but we need the latest version to bring the macro improvements.
      build.Deps.sourcecode,
      // Necessary so we can share the JNA classes throughout the build process
      build.Deps.jna,
      build.Deps.jnaPlatform,
      build.Deps.jarjarabrams,
      build.Deps.mainargs,
      build.Deps.scalaparse
    )
  }

  object eval extends build.MillStableScalaModule {
    def moduleDeps = Seq(define)
  }

  object resolve extends build.MillStableScalaModule {
    def moduleDeps = Seq(define)
  }

  object client extends build.MillPublishJavaModule with BuildInfo {
    def buildInfoPackageName = "mill.main.client"
    def buildInfoMembers = Seq(BuildInfo.Value("millVersion", build.millVersion(), "Mill version."))

    object test extends JavaModuleTests with TestModule.Junit4 {
      def ivyDeps = Agg(build.Deps.junitInterface, build.Deps.commonsIo)
    }
  }

  object server extends build.MillPublishScalaModule {
    def moduleDeps = Seq(client, api)
  }
  object graphviz extends build.MillPublishScalaModule {
    def moduleDeps = Seq(build.main, build.scalalib)
    def ivyDeps = Agg(build.Deps.jgraphtCore) ++ build.Deps.graphvizJava ++ build.Deps.javet
  }

  def testModuleDeps = super.testModuleDeps ++ Seq(build.testkit)
}
