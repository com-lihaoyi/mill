= Unlocking Android Hilt Support with Mill

:link-github: https://github.com/com-lihaoyi/mill
:link-pr: {link-github}/pull
:link-perm: {link-github}/blob/

// tag::header[]
:author: Vasilis Nicolaou
:revdate: 31 July 2025

_{author}, {revdate}_#

Until recently, if you wanted to build Android apps, your only real option was Gradle. Mill, a fast and modular build tool for Scala and Java, now supports Android development, including complex setups like https://developer.android.com/training/dependency-injection/hilt-android[Hilt-based] dependency injection.

While building out Android support in Mill, we tested several complex projects to identify missing pieces. One setup we tested was https://github.com/android/architecture-samples[android-architecture-samples] which uses Hilt, a dependency injection framework that pushes the limits of typical Android build tooling.

This blog post is a deep dive into how we brought full Hilt support to Mill, and what it means for Android developers looking for a faster, simpler, and more transparent alternative to Gradle.

// end::header[]

== Introduction

With Mill's basic functionality for supporting Android in place, it was vital to start testing more complex
setups to extend the tool's capabilities. Such an example is https://github.com/android/architecture-samples[Android Architecture Samples].

What makes this example compelling is its use of both Hilt and Jetpack Compose, which pushes the boundaries of Mill's build tooling for Android.

=== Why Hilt?

To ensure Mill can support real-world Android apps, we set a high bar: making it possible to build and test the official Android Architecture Samples. These are small but representative apps that cover common development patterns, including:

1. Kotlin and Java mixed source sets
2. Dependency Injection with Dagger and Hilt
3. Jetpack components and Compose
4. Unit and instrumentation tests

The challenge? Hilt's code generation and bytecode transformation are quite dependent on Android Gradle Plugin (AGP). We either needed to re-implement it, or reuse Gradle independent functionality. Luckily,
we were able to reuse just enough, to create {link-perm}/6351d7f3a29dd272c9393f690a3eb82ffa2b4f41/libs/androidlib/Hilt/src/mill/androidlib/Hilt/AndroidHiltTransformAsm.scala[a small utility tool] that runs inside Mill and does the ASM transformation step.

== Android Builds Are Inherently Complex

Android builds are multi-step and intricate, even for basic apps. Unlike typical JVM builds—which often compile Java/Kotlin sources and then package them, Android introduces additional phases that increase complexity:

- *Resource compilation* (`aapt2`) for XML layouts, drawables, and strings
- *Manifest merging* for combining manifests from dependencies
- *DEX bytecode conversion* (via `d8` or `r8`) for the Android runtime
- *APK packaging* including resource and class merging
- *Code shrinking and obfuscation* using `r8` or Proguard
- *Multi-variant handling* for debug, release, and test builds
- *App signing* with either debug or production keystores
- *Emulator deployment and test execution* via ADB tools

.Standard Android build pipeline (without Hilt)
[graphviz]
....
digraph G {
  rankdir=TB
  node [shape=box width=0 height=0]

  "Java/Kotlin Sources" -> "Compile (Java/Kotlin)"
  "Resources (res/)" -> "Compile Resources (aapt2)"
  "AndroidManifest.xml" -> "Manifest Merging"
  "Manifest Merging" -> "Linked Resources"
  "Compile Resources (aapt2)" -> "Linked Resources"
  "Compile (Java/Kotlin)" -> "Compiled Classes"
  "Linked Resources" -> "Package APK"
  "Compiled Classes" -> "DEX (d8/r8)"
  "DEX (d8/r8)" -> "Package APK"
  "Package APK" -> "Code Shrinking (r8/Proguard)"
  "Code Shrinking (r8/Proguard)" -> "Sign APK"
  "Sign APK" -> "Install to Emulator"
  "Install to Emulator" -> "Run/Test via ADB"
}
....

The typical Android build process is encapsulated in `AndroidAppModule` and `AndroidModule`, including support for manifest merging, resource compilation, dexing, packaging, signing, and device installation.

When you add Hilt to the mix—bringing in code generation and bytecode manipulation—the complexity increases. Supporting this correctly meant understanding how Gradle orchestrates these steps and implementing a Mill idiomatic process that achieves equivalent results in a Mill-idiomatic approach.

== Enriching the Mill Toolchain to Support Hilt

=== Kotlin Symbol Processing (KSP)

Mill now runs https://kotlinlang.org/docs/ksp-overview.html[KSP] as a separate step before normal Kotlin compilation. This allows us to support annotation processors like `dagger-compiler` and `hilt-android-compiler`.

To prevent classpath conflicts between the compiler and its plugins (e.g., Guava related packages showing up in both), we use the embeddable Kotlin compiler, just like Gradle does.

=== Hilt Bytecode Transformation (ASM)

Gradle uses https://github.com/google/dagger/tree/b3d3443e3581b8530cd85929614a1765cd37b12c/java/dagger/hilt/android/plugin/main/src/main/kotlin/dagger/hilt/android/plugin[android-hilt-gradle-plugin] to rewrite bytecode at build time so that classes annotated with `@AndroidEntryPoint` or `@HiltAndroidApp` properly extend the generated base classes.

We reused key parts from the plugin and implement the ASM transformation step which is the critical bit that achieves the compile time dependency injection. For example, the bytecode of a component activity annotated with `@AndroidEntryPoint` would look like this with pure compilation:

[source]
----
.method public constructor <init>()V
    .registers 1

    .line 29
    invoke-direct {p0}, Landroidx/activity/ComponentActivity;-><init>()V

    .line 28
    return-void
.end method
----

While with the Hilt ASM transformation, it turns into:

[source]
----
.method public constructor <init>()V
    .registers 1

    .line 29
    invoke-direct {p0}, Lcom/example/android/architecture/blueprints/todoapp/Hilt_TodoActivity;-><init>()V

    return-void
.end method
----

=== How Hilt Integrates Into the Android Build Pipeline

In summary, Hilt introduces two major steps beyond the standard Android build process:

1. **Kotlin Symbol Processing (KSP)**: Generates code for dependency injection before normal compilation.
2. **ASM Bytecode Transformation**: Rewrites compiled classes at the bytecode level to inject runtime logic, similar to what the `android-hilt-gradle-plugin` does in Gradle.

These two steps hook directly into the existing pipeline:

.Android build pipeline with Hilt integration (KSP and ASM shown in red)
[graphviz]
....
digraph G {
  rankdir=TB
  node [shape=box width=0 height=0 fontsize=10]

  // Standard Android build steps
  "Java/Kotlin Sources" -> "Compile (Java/Kotlin)"
  "Resources (res/)" -> "Compile Resources (aapt2)"
  "AndroidManifest.xml" -> "Manifest Merging"
  "Manifest Merging" -> "Linked Resources"
  "Compile Resources (aapt2)" -> "Linked Resources"
  "Compile (Java/Kotlin)" -> "Compiled Classes"
  "Linked Resources" -> "Package APK"
  "Compiled Classes" -> "DEX (d8/r8)"
  "DEX (d8/r8)" -> "Package APK"
  "Package APK" -> "Code Shrinking (r8/Proguard)"
  "Code Shrinking (r8/Proguard)" -> "Sign APK"
  "Sign APK" -> "Install to Emulator"
  "Install to Emulator" -> "Run/Test via ADB"

  // Hilt integration
  "Java/Kotlin Sources" -> "KSP (Hilt/Dagger)" [color=red fontcolor=red label="Hilt" penwidth=2]
  "KSP (Hilt/Dagger)" -> "Generated Sources" [color=red penwidth=2]
  "Generated Sources" -> "Compile (Java/Kotlin)" [color=red penwidth=2]

  "Compiled Classes" -> "ASM Transform (Hilt)" [color=red penwidth=2]
  "ASM Transform (Hilt)" -> "DEX (d8/r8)" [color=red penwidth=2]
}
....

== It Works: Building Real Android Apps with Hilt in Mill

Here's what we can now support:

- Kotlin + Java mixed source projects
- Full Hilt/Dagger code generation
- Bytecode rewriting (ASM) for DI injection
- Unit tests (with friend-path support)
- Instrumentation tests on emulators
- Support for R8, desugaring, and manifest merging
- androidApplicationId/androidNamespace support

We validated all this by successfully building, running, and testing the https://github.com/android/architecture-samples[TODO app] from the Android Architecture Samples repo using Mill.

.Screenshot: Hilt-enabled TODO app running in an emulator
image:blog::hilt_first_success.png[]

== Try It Yourself

Here's how you can try the exact setup used to validate Mill's Hilt support:

Get the architecture-samples containing the Todo App.

[source,bash]
----
git clone git@github.com:android/architecture-samples.git
cd architecture-samples
----

Install mill

[source,bash]
----
curl -L https://repo1.maven.org/maven2/com/lihaoyi/mill-dist/1.0.2/mill-dist-1.0.2-mill.sh -o mill
chmod +x mill
echo "//| mill-version: 1.0.2-3-e42a40" > build.mill
./mill version
----

Configure the mill build

[source,bash]
----
curl https://raw.githubusercontent.com/com-lihaoyi/mill/6351d7f3a29dd272c9393f690a3eb82ffa2b4f41/example/thirdparty/androidtodo/build.mill >>build.mill
----

Start the emulator and run the app
[source,bash]
----
./mill show app.createAndroidVirtualDevice
./mill show app.startAndroidEmulator
./mill show app.androidInstall
./mill show app.androidRun --activity com.example.android.architecture.blueprints.todoapp.TodoActivity
----

Run the instrumented tests and watch the app being tested inside the emulator:

[source,bash]
----
./mill app.androidTest
----

.Screenshots: Instrumentation tests running inside emulator via Mill
image:blog::hilt_test_screen.png[]

image:blog::hilt_test_screen_2.png[]

== Conclusion: A New Option for Android Builds

This wasn't just about making Hilt work! It was about proving that Mill can support real Android development workflows, from build to test to emulator deployment.

We now support fully functional Android applications with Hilt, built using Mill.

If you're frustrated with Gradle's performance or complexity, or just want to try something new, give it a spin. You might be surprised how far you can go with a simple, transparent build tool.


