// tag::header[]

# What is a Build Tool and what does it do?


:author: Li Haoyi
:revdate: 12 February 2025
_{author}, {revdate}_

The most common question I get asked about the Mill build tool is: what does a build
tool even do? Even some developers may not be familiar with the idea: they may run
`pip install` and `python foo.py`, `javac Foo.java`, or `go build` or some other
language-specific CLI directly. They may have a folder full of custom Bash scripts
they use during development. This blog post explores what build tools are all about,
and why they are important to most software projects as they scale.

// end::header[]


## What is a Build Tool?

A build tool is a program that automates the process of
selecting which tools or tasks to run - and how to run them - whenever you want
to do something in your codebase.


A hello-world program may get by with `javac Foo.java` to compile your code and
`java Foo` to run it, or even a single command `python foo.py`. But most real-world
projects end up with a lot more requirements than that.
For example, before running your code, a project may need to:

- Use the configured _direct_ third-party dependencies to resolve the _transitive_ third-party dependencies
- Download all transitive third-party library dependencies to files on disk
- Compile upstream _internal_ library dependencies, i.e. upstream modules in the same codebase
- Run code generators on IDL files to generate source files (e.g. https://protobuf.dev/[protobuf], https://www.openapis.org/[openapi], https://thrift.apache.org/[thrift], etc.)
- Run the compiler  (if your language has one) on source files to generate binary files
- Package the binary files into an executable
- Run the static asset pipeline on input files to generate static files (e.g. for video games or websites)

So although the developer may have just asked to `run` their code, it is only after all
these tasks are done does it make sense to begin running it! However, it's not as
simple as running every one of the tasks listed above one after another. You also
need to decide _which ones_ to run and _how_ to run them:

- You want to skip tasks which have earlier results you can re-use (e.g. by not
  generating static assets if they have already been generated, because that task can be slow)

- You want to make sure to re-run tasks whose inputs have changed (e.g.
  if someone changes a static file, then the static asset pipeline needs to be re-run)

- You want to parallelize tasks which are independent of each other (e.g.
  _running the compiler_ can happen in parallel with _running static asset pipeline_),
  but not those which depend on one another (e.g. _running the compiler_ must happen after
  _running code generators_, and thus cannot happen in parallel)

Working on any real-world codebase will involve a large variety of tasks:
resolving and downloading dependencies, autoformatting, linting, code-generation, compiling,
testing, packaging and publishing. These tasks depend on each other in various,
ways, and it is the job of the build tool to take what you (as a developer) want
to do, and select _which_ tasks to run and _how_ to run them in order to accomplish
what you want.

## Build Tools across Languages

Although programming languages are very different, developers in all languages have similar
requirements. Thus most languages have one-or-more build tools, that then integrate with
the equivalent external tools and services specific to that language:

|===
| Language   | Build Tool          | Package Repository    | Compiler | ...

| Java
| https://maven.apache.org[Maven], https://gradle.org[Gradle], https://mill-build.org[Mill]
| https://central.sonatype.com/[Maven Central]
| https://docs.oracle.com/javase/8/docs/technotes/tools/windows/javac.html[javac]
| ...

| Python
| https://python-poetry.org/[Poetry]
| https://pypi.org/[PyPI]
| https://github.com/python/mypy[mypy]
| ...

| Javascript
| https://webpack.js.org/[Webpack], https://vite.dev/[Vite]
| https://www.npmjs.com/[NPM]
| https://www.typescriptlang.org/[tsc]
| ...

| Rust
| https://doc.rust-lang.org/cargo/[Cargo]
| https://crates.io/[Crates]
| https://doc.rust-lang.org/rustc/what-is-rustc.html[rustc]
| ...

|===

Generally each language's build tools will come with integrations for
the languages other tooling by default: package repositories, compilers, linters, etc.
There are also language agnostic build tools out there like `make`, or multi-language
build tools such as https://bazel.build/[Bazel]
which supports multiple languages and is optimized for large monorepos. The Mill build
tool also supports multiple languages: xref:mill:ROOT:javalib/intro.adoc[Java],
xref:mill:ROOT:kotlinlib/intro.adoc[Kotlin], xref:mill:ROOT:scalalib/intro.adoc[Scala],
xref:mill:ROOT:pythonlib/intro.adoc[Python], and (experimentally)
xref:mill:ROOT:javascriptlib/intro.adoc[Javascript], allowing it to be used
for xref:mill:ROOT:large/multi-language-builds.adoc[Multi-Language Builds].

## The Need for Build Tools

Most projects start off small, and while they _can_ use a build tool, do not _need_ one.
A single-file application has few enough tasks that whatever built-in CLI the
language provides is enough to compile/run/test their code, and the tasks are
fast and simple enough that parallelization or caching are not needed.

Nevertheless, even in a small project, a simple task like "installing third party
dependencies" can be surprisingly challenging without a build tool:

- You start off `pip install something`, run your code with `python foo.py`, and it
  works. Great!

- The project bumped the version of `something` required, and now everyone working on
  the project must `pip install` it again, or else they will get weird errors from
  having the wrong version installed

- If you change branch to work on an old release branch of the project, you need
  to remember to `pip install` to go back to the old version of `something`. And then `pip install`
  the new version when you come back to the `main` branch!

- What if two modules in your codebase `foo.py` and `bar.py`  require different versions
  of the same dependency? Now you need to remember to manually `python -m venv` to create
  a virtual environment for each module, and remember to update each one
  whenever a dependency changes

As you can see, even for the single problem of "managing third-party dependencies",
keeping everything in sync and everyone's laptops up to date can be a real headache!


As a project grows, the required workflows get both more complex and slower
over time. The developer ends up needing to manually juggle a dozen different tools
to run linters/code-generation/autoformatting/etc., making sure to run them in the
right order for things to work. They also end up spending time just _waiting_, as their
code takes longer to compile and their tests take longer to run. Automating that busywork
and speeding up the slow development workflows is exactly what build tools are for.


## Build Tools vs Scripts

One common alternative to build tools is to write scripts to help manage the development
of the project: e.g. you may find a `dev/` folder full of scripts like `run-tests.sh` or
`lint.sh`, and so on. While this works, the approach of scripting your development
workflows directly in Bash runs into trouble as the codebase grows:

- Initially, these scripts serve to just enumerate the necessary steps to do something
  in your code, e.g.

** `integration-tests` may require `download-dependencies`,
  `codegen`, `compile`, `package` to be run in order first

** `unit-tests` on the other hand may need `download-dependencies`, `codegen`, `compile`, but not need  `package`

- Next, these scripts inevitably begin performing rudimentary caching: e.g. if you
  ran `unit-tests` earlier and now want to run `integration-tests`, we can skip
  `download-dependencies`, `codegen`, `compile`, but need to now run `package`

- After that, these scripts inevitably start parallelizing parts of the workflow:
  e.g. `codegen` and `download-dependencies` may be able to run in parallel, while
  `compile` can only run after both of those are finished

At this stage, your scripts have their own ad-hoc dependency-management, caching,
and parallelization engine! Because your main focus is on your _actual_ project,
they will never be in great shape: the performance won't be optimal, the
error messages and usability won't be great, and bugs and issues won't be fixed.
This will likely be a drag on your productivity, since even if your focus is on
your main project, you still need to interact with your build scripts constantly
throughout the work day.

At its core, a build tool basically automates these things that you would have
implemented yourself anyway: it provides the ordering of tasks, parallelism,
caching, and probably does so better than you could implement in your own
ad-hoc build scripts.

## Custom Tasks

Most codebases have some amount of custom tasks and workflows. While many workflows
are standardized - e.g. using the same Java compiler, Python interpreter, etc. -
it is almost inevitable that over time the codebase will pick up workflows unique
to its place in the business and organization:

- Custom code generation
- Custom linters and security analysis
- Custom deployment artifacts and deployment workflows

The default way of handling this customization is the aforementioned
folder-full-of-scripts, where you have a `do-custom-thing.sh` script to run
your custom logic. However, this approach can be problematic:

1. Bash scripts are not an easy programming environment to work in, so
   custom tasks implemented as scripts tend to be buggy and fragile.
   Even implementing logic like "if-else" or "for-loops" in Bash can
   be error-prone and easy to mess up!

2. Non-Bash scripting languages have their own problems: e.g. Python
   scripts tend to be difficult to run reliably on different machines which
   may have different Python version or dependencies installed, and Ruby
   scripts may have issues running on Windows

3. Implementing your custom task, you usually want caching and
   parallelism in order to make your workflows performant

Most build tools thus provide some kind of _"plugin system"_ to let you
implement your custom logic in a more comfortable programming environment
than Bash: Maven has its Java plugin interface called https://maven.apache.org/plugin-developers/[MOJO]s,
Webpack allows you to write https://webpack.js.org/plugins/[Webpack Plugins] in Javascript,
Bazel provides the https://bazel.build/rules/language[Starlark Language] for writing
extensions, and so on. The Mill build tool's custom logic runs on the JVM, and thus
comes with typechecking, IDE support, access to the standard JVM package
repositories and people are already used to.

How custom tasks and workflows are written does not matter for
small projects where customizations are trivial. But in larger projects with
a non-trivial amount of custom logic, this ability to write code to customize
and extend your development workflows becomes more important, and providing
a safe, easy-to-use way to do so makes all the difference at keeping your
project's build maintainable over time.

## Large Codebases and Monorepos

It's worth calling out the need for build tools on very-large-codebases:
those with 100 to 1,000 to even 10,000 developers actively working on it.
Just as small codebases start off not really needing a build tool, and start
needing one as they grow larger, very-large-codebases have an even stronger
need for something to help manage the development workflows, which "monorepo"
build tools like Bazel provides. Requirements such as:

- xref:3-selective-testing.adoc[Selective Testing], to avoid running the entire test
  suite (which may take hours) by only running the tests related to a change

- Multi-language support: e.g. a Java server with a Javascript frontend with a Python
  ML workflows. Bazel has `rules{lang}` for a wide variety of languages, and Mill
  also has support for xref:mill:ROOT:large/multi-language-builds.adoc[Multi-Language Builds]

- Distributed caching and execution: allowing different CI machines or developer
  laptops to share compiled artifacts so a module compiled on one machine and be
  re-used on another, or submitting a large workflow to a cluster of machines to
  parallelize it more than you could on a single laptop.

See the following blog post for a deeper discussion on what features a
_"monorepo build tool"_ provides and why they are necessary:

* xref:2-monorepo-build-tool.adoc[Why Use a Monorepo Build Tool?]

## How Build Tools Work: The Build Graph

After all this talk about what a build tool is, it is worth mentioning how most
modern build tools work. At their core, most modern build tools are some kind of
graph evaluation engine.

For example, consider the various tasks we mentioned earlier:

- Use the configured _direct_ third-party dependencies to resolve the _transitive_ third-party dependencies
- Download all transitive third-party library dependencies to files on disk
- Compile upstream _internal_ library dependencies
- Run code generators on IDL files to generate source files
- Run the compiler on source files to generate binary files
- Package the binary files to generate executable
- Run the static asset pipeline on input files to generate static files

We might even include a few more:

- Run unit tests on binary files to generate test_report
- Run integration tests on executable to generate test_report

At their core, most build steps are of the form

- Run *TOOL* on *INPUT1*, *INPUT2*, ... to generate *OUTPUT*

Which can be visualized as a node in a graph

```graphviz
digraph G {
  rankdir=LR
  node [shape=box width=0 height=0]
  input1 -> tool
  input2 -> tool
  tool -> output
  output[shape=none]
}
```

If we consider the tasks we looked at earlier, it might form a graph as shown below,
where the boxes are the tasks, non-boxed text labels are the input files, and the
arrows are the dependencies between them

```graphviz
digraph G {
  rankdir=LR
  node [shape=box width=0 height=0]
  direct_deps -> resolve_deps -> compile
  code_gen -> compile
  sources -> compile
  static_input_files -> asset_pipeline
  asset_pipeline -> integration_test
  compile -> unit_test
  compile -> package

  package -> integration_test
  direct_deps [shape=none]
  sources [shape=none]
  static_input_files [shape=none]
}
```

## Caching and Invalidation via the Build Graph

It is from this graph representation that most build tools are able to work
their magic. For example, if you ask to run `unit_test` (blue), then the build tool
can traverse the graph edges (red) to find it needs to ensure `compile`, `code_gen`, and
`resolve_deps` need to be run (red)

```graphviz
digraph G {
  rankdir=LR
  node [shape=box width=0 height=0]
  direct_deps -> resolve_deps -> compile
  code_gen -> compile  [color=red penwidth=2]
  sources -> compile  [color=red penwidth=2]
  static_input_files -> asset_pipeline
  asset_pipeline -> integration_test
  compile -> unit_test  [color=red penwidth=2]
  compile -> package

  package -> integration_test
  direct_deps [shape=none]
  sources [shape=none]
  static_input_files [shape=none]
  resolve_deps [fillcolor=lightpink style=filled]
  code_gen [fillcolor=lightpink style=filled]
  compile [fillcolor=lightpink style=filled]
  unit_test [fillcolor=lightblue style=filled]
}
```

If you then subsequently ask to run `integration_test` (blue), the build tool can see that
`compile`, `code_gen`, and `resolve_deps` were run earlier and can be re-used (green)
while `package` and `asset_pipeline` need to be run (red)

```graphviz
digraph G {
  rankdir=LR
  node [shape=box width=0 height=0]
  direct_deps -> resolve_deps [color=red penwidth=2]
  resolve_deps -> compile [color=red penwidth=2]
  code_gen -> compile  [color=red penwidth=2]
  sources -> compile
  static_input_files -> asset_pipeline
  asset_pipeline -> integration_test  [color=red penwidth=2]
  compile -> unit_test
  compile -> package  [color=red penwidth=2]

  package -> integration_test [color=red penwidth=2]
  direct_deps [shape=none]
  sources [shape=none]
  static_input_files [shape=none]
  resolve_deps [fillcolor=lightgreen style=filled]
  code_gen [fillcolor=lightgreen style=filled]
  compile [fillcolor=lightgreen style=filled]
  package [fillcolor=lightpink style=filled]
  asset_pipeline [fillcolor=lightpink style=filled]
  integration_test [fillcolor=lightblue style=filled]
}
```

If you then change a source file in `sources` and ask to run `integration_test` (blue)
again, the build tool can again traverse the graph edges (red) and see that:

- `resolve_deps`, `code_gen`, and `asset_pipeline` are not downstream of `sources` and can be reused (green)
- `compile` and `package` _are_ downstream of `sources` and need to be re-run (red)
- `unit_test` is not needed for `integration_test`, and so can be ignored (white)


```graphviz
digraph G {
  rankdir=LR
  node [shape=box width=0 height=0]
  direct_deps -> resolve_deps -> compile
  code_gen -> compile
  sources -> compile [color=red penwidth=2]
  static_input_files -> asset_pipeline
  asset_pipeline -> integration_test
  compile -> unit_test
  compile -> package [color=red penwidth=2]

  package -> integration_test [color=red penwidth=2]
  direct_deps [shape=none]
  sources [shape=filled color=red]
  static_input_files [shape=none]
  resolve_deps [fillcolor=lightgreen style=filled]
  code_gen [fillcolor=lightgreen style=filled]
  asset_pipeline [fillcolor=lightgreen style=filled]
  compile [fillcolor=lightpink style=filled]
  package [fillcolor=lightpink style=filled]
  integration_test [fillcolor=lightblue style=filled]
}
```

## Parallelism on the Build Graph

The build graph is also useful for automatically parallelizing your build tasks.
For example, consider a case where we want to do a clean build (i.e. no caching)
of `unit_test` and `integration_test`. From the build graph, Mill is able to determine:

- `resolve_deps`, `code_gen`, and `asset_pipeline` can run in parallel (green)
- `compile`, `package`, and `integration_test` must run sequentially (red),
  only starting once `resolve_deps` and `code_gen` is complete
- `unit_test` (blue) can run in parallel with `package` or `integration_test`,
  only starting once `compile` is complete

```graphviz
digraph G {
  rankdir=LR
  node [shape=box width=0 height=0]
  direct_deps -> resolve_deps -> compile
  code_gen -> compile
  sources -> compile
  static_input_files -> asset_pipeline
  asset_pipeline -> integration_test
  compile -> unit_test
  compile -> package

  package -> integration_test
  direct_deps [shape=none]
  sources [shape=none]
  static_input_files [shape=none]
  resolve_deps [style=filled fillcolor=lightgreen]
  code_gen [style=filled fillcolor=lightgreen]
  asset_pipeline [style=filled fillcolor=lightgreen]
  compile [style=filled fillcolor=lightpink]
  package [style=filled fillcolor=lightpink]
  integration_test [style=filled fillcolor=lightpink]
  unit_test [style=filled fillcolor=lightblue]
}
```


## Conclusion

Build tools are used widely throughout the software engineering community, but
seldom paid attention to.


Although modern build tools may look very different on the surface, most of them
are surprisingly similar once you peek under the covers. Bazel's StarLark config,
Gradle's Groovy/Kotlin config, Mill's Scala config, all end up boiling down to
a build graph similar to the one above with only minor differences. And although the
way they execute their tasks using the build graph does differ, at their most
fundamental level they use the sort of graph traversal that I discuss above.

Hopefully this blog post has given you a good idea of why they are necessary, as well
as a glimpse at how they work internally. This should give you a better appreciation
for how build tools do what they do, and perhaps give you some insight next time you need
to debug a build tool that is doing something wrong!
