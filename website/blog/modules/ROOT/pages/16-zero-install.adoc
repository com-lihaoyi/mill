= Zero-Step Installation of Mill's CLI Tool

// tag::header[]
:author: Li Haoyi
:revdate: 23 September 2025

_{author}, {revdate}_

Getting the software onto you want installed onto your machine is a constant point of
friction, whether you're on OS-X finding
https://github.com/orgs/Homebrew/discussions/1177[Homebrew being terribly slow] or on Ubuntu finding
https://www.reddit.com/r/Ubuntu/comments/1j3ldpm/why_are_all_my_apt_programs_so_outdated/[the versions available are all outdated].
You find yourself fighting different package managers to try and make sure you install the same
versions in different environment, and endlessly fighting version drift to keep things consistent.

The Mill build tool does something interesting here: unlike most CLI tools, it
requires no installation at all! You can checkout any codebase built with Mill on a bare Linux,
Mac, or Windows machine and build it without any prior setup using it's `./mill` bootstrap
script. This greatly simplifies building your project across diverse Dev and CI environments,
allowing your co-workers and CI-workers to get straight to work on a project without any
fussing with installs. For example, the `./mill __.compile` below is all that is needed
to compile all modules in a Mill project

```console
> curl -L https://github.com/com-lihaoyi/cask/archive/refs/heads/master.zip -o cask.zip

> unzip cask.zip && cd cask-master

> ./mill __.compile
```

This blog post explores how Mill's zero-install workflow works: the limitations of prior
approaches, the interesting innovations that Mill builds upon, and Mill's unique ideas that
let it achieve ultimate simplicity with its zero-step installation workflow.

// end::header[]

== 1-Step Installation

Perhaps the most common way software is installed is via package managers like `apt`, `yum`, or
`brew`. For example, the incantation to install `git` in an Amazon-Linux machine is:

```console
> sudo yum install git
```

Depending on how nicely the software you are installing is packaged, this may or may not require
additional commands to install transitive dependencies. For example, when setting up a codebase
for development, you may need to:

- `apt install` the Python version you want to use
- `pip install` the libraries you want to use
- Also `apt install` any native dependencies your python code needs to run.

There are other ways to install things apart from package managers: `curl <url> | bash` is common,
as is manually downloading binaries to put on your `PATH`. But all of these have a similar problem:
the installation must happen _before_ you can begin working on your project. Even with just 1 step,
this gives a lot of room for things to go wrong. For example

1. **Things falling out of sync**: the installation commands on MacOS using `brew` will be different
   from Amazon-Linux using `yum` or Ubuntu using `apt`, so it's terribly easy to end up with
   subtly different sets of packages on each. This results in frustrating "only works on my machine"
   mis-behaviors, and tedious busy-work trying to keep the various environments in sync.

2. **The number of steps growing**: while a 1-step install may seem fine, a large codebase
   may have many packages and tools requiring 1-step installs, resulting in an installation
   process with dozens of steps that can be tedious if run manually and fragile if scripted

While 1-step installation is better than multi-step installation, some may still
ask: could we do better?

== Maven & Gradle Bootstrap Scripts

One interesting innovation on the installation process is the use of a _bootstrap script_. These
were popularized by the https://gradle.org/[Gradle build tool] as a `./gradlew` script you commit
to the repository root. More recently, the https://maven.apache.org/[Maven build tool] has
adopted a similar convention with `./mvnw` scripts.

The bootstrap script hard-codes the version of the build tool you want to use, and ensures to
download and cache that specific version when it is invoked. That means you can checkout a
project's code and run:

```console
> ./gradlew build
```

Or

```console
> ./mvnw clean install
```

And be sure you are using the same version of Gradle or Maven that everyone else is also using
to build that project. This can be very handy: you now no longer need to worry about installing
the "right version" of the build tool on your colleagues' laptops, on CI, etc. The bootstrap
script ensures that anyone working on the project - human or otherwise - will be using the
same version.

Furthermore, as tools like Gradle or Maven automatically resolve the application-level
dependencies required by the project they are building, the user does not need to install
those manually. Any `build` or `install` or `test` command results in all necessary
dependencies being automatically downloaded and cached as necessary.

However, one limitation of the Maven and Gradle approach to bootstrap scripts is that they rely
on `java` being pre-installed to begin the bootstrapping process. Without `java`, they cannot
run at all, as shown below:

```console
> curl -L https://github.com/netty/netty/archive/refs/heads/4.2.zip -o netty.zip
> unzip netty.zip
> ./mvnw clean install
/usr/bin/which: no javac in (/home/ec2-user/.local/bin:/home/ec2-user/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin)
Error: JAVA_HOME is not defined correctly.
```

So even with the `./gradle` or `./mvnw` bootstrap scripts, working with Gradle or Maven still
ends up being a 1-step installation process: you need to install `java` (and the right version
of Java!) before you begin. Thus although these bootstrap scripts mitigate
the problem - differing Java versions tend to be more forgiving than differing Maven/Gradle
versions - they haven't completely solved it.

Why do these bootstrap scripts have require `java` to be installed? It's
because they don't want to put non-trivial bootstrapping logic into `.sh` or `.bat` scripts,
and as JVM build tools writing their bootstrapping logic in Java running on the JVM makes sense.
But that doesn't seem like a hard requirement, and it should be possible to make a bootstrapping
binary that can run without `java` or any other runtime pre-installed. That is the approach
that Mill takes.

== Mill's Zero-Install Bootstrap Scripts

Mill's `./mill` bootstrap scripts are similar to `./mvnw` or `./gradle`, but differ in that
by default they do not require `java` installed in order to run. Instead, `./mill` downloads
a native platform-specific binary that then performs the bootstrapping process:

```
https://repo1.maven.org/maven2/com/lihaoyi/mill-dist-native-linux-aarch64/1.0.5/mill-dist-native-linux-aarch64-1.0.5.exe
https://repo1.maven.org/maven2/com/lihaoyi/mill-dist-native-linux-amd64/1.0.5/mill-dist-native-linux-amd64-1.0.5.exe
https://repo1.maven.org/maven2/com/lihaoyi/mill-dist-native-mac-aarch64/1.0.5/mill-dist-native-mac-aarch64-1.0.5.exe
https://repo1.maven.org/maven2/com/lihaoyi/mill-dist-native-mac-amd64/1.0.5/mill-dist-native-mac-amd64-1.0.5.exe
```

These `.exe` files are JVM executables, but compiled to native platform-specific binaries using
the xref:7-graal-native-executables.adoc[Graal Native Image compiler]. Apart from the benefits
of reduced startup time and memory usage, native image binaries also can run on bare environments
without a `java` runtime pre-installed. This lets us write our non-trivial bootstrapping logic
in Java, run it on the JVM, without needing a `java` installation present on the machine we run
it on.

As native image binaries are OS/CPU-specific, we need some logic to pick the right binary for the
machine the bootstrap script it running on, and that logic needs to run in `.sh` or `.bat` because
we need it to run _before_ the native image binary has been downloaded. The `.sh` version of this
implemented using `uname` is as follows:

```bash
ARTIFACT_SUFFIX=""
set_artifact_suffix(){
  if [ "$(expr substr $(uname -s) 1 5 2>/dev/null)" = "Linux" ]; then
    if [ "$(uname -m)" = "aarch64" ]; then
      ARTIFACT_SUFFIX="-native-linux-aarch64"
    else
      ARTIFACT_SUFFIX="-native-linux-amd64"
    fi
  elif [ "$(uname)" = "Darwin" ]; then
    if [ "$(uname -m)" = "arm64" ]; then
      ARTIFACT_SUFFIX="-native-mac-aarch64"
    else
      ARTIFACT_SUFFIX="-native-mac-amd64"
    fi
  else
     echo "This native mill launcher supports only Linux and macOS." 1>&2
     exit 1
  fi
}
```

The bootstrap script can then assemble this into a download URL to `curl` down the relevant file:

```bash
DOWNLOAD_URL="https://repo1.maven.org/maven2/com/lihaoyi/mill-dist${ARTIFACT_SUFFIX}/${MILL_VERSION}/mill-dist${ARTIFACT_SUFFIX}-${MILL_VERSION}.${DOWNLOAD_EXT}"
curl -f -L -o "${DOWNLOAD_FILE}" "${DOWNLOAD_URL}"
```

And execute it, taking any command line arguments given to the bootstrap script and forwarding
them to the downloaded binary:

```bash
exec "${DOWNLOAD_FILE}" "$@"
```

The snippets above are somewhat simplified - the
https://github.com/com-lihaoyi/mill/blob/1.0.5/dist/scripts/src/mill.sh[actual bootstrap script]
contains a lot more logic to handle backwards compatibility, version configuration,
https://github.com/com-lihaoyi/mill/blob/1.0.5/dist/scripts/src/mill.bat[Windows support],
and other necessary details. But at a high level, this is what Mill's bootstrap script does:
it picks the downloads the native binary of the configured version, operating system, and CPU
architecture, and executes it to begin the Mill bootstrapping process.

== Bootstrapping a Full JVM Environment

Once we execute our native image binary, we then have an opportunity to run real JVM code (as
opposed to sketchy shell scripts) to proceed with bootstrapping. When someone runs
`./mill __.compile` to compile all modules in a repository, and the native image bootstrap
launcher has been downloaded as described above, we can then use it to:

1. Download the JVM that Mill needs to run, as Graal Native Images have limitations around
   classloading and reflection that make it unsuitable for the Mill daemon process

2. Download the `.jar` files that make up the Mill daemon process

3. Start the Mill daemon process, which runs on the JVM

Once we have the Mill daemon process running, further steps are necessary to bootstrap the Mill
build dependencies and user code dependencies

1. Resolve any `.jar` files necessary for Mill's own logic, or any plugins that the user
   may have set up in their build, and load them into a classloader to invoke the build

2. Resolve any `.jar` files necessary for user modules to compile and run, and resolving any
   other JVM that the user modules may be configured to user

3. Finally, compiling the user code using any `.jar` files and any custom JVM that they require.

The various `.jar` files are typically downloaded from
https://central.sonatype.com/[Maven Central], which is the standard for JVM libraries, and
the JVMs themselves come from the various provider download URLs that we've consolidated in
the https://github.com/coursier/jvm-index[Coursier JVM Index]

Note that we only do these steps once the native image bootstrap launcher has been downloaded,
as they require non-trivial logic: resolving JVM versions to download URLs, resolving `.jar`
files from group-artifact-version coordinates, adjudicating version conflicts, etc. Mill
handles this using https://github.com/coursier/coursier[Coursier], which is a dependency
resolution library that can run both compiled in the native image bootstrap launcher as well
as on the JVM in the Mill daemon process.

The final bootstrapping process of `./mill __.compile` looks something like this, with the
solid lines indicating local steps in the bootstrapping process, and the dashed lines
indicating downloads from Maven Central:

```graphviz
digraph G {
  node [shape=box width=0 height=0 style=filled fillcolor=white]
  subgraph cluster0{
    color=white

    "./mill" -> "native image binary" -> "mill daemon jars" -> "mill daemon" -> "build jars" -> "build classloader" -> "user module dependency jars"
    "native image binary" -> "mill daemon JVM" -> "mill daemon"
    "build classloader" -> "user module JVM"

    "user module JVM" -> "__.compile"
    "user module dependency jars" -> "__.compile"
    "user module sources" -> "__.compile"
  }

  "Maven Central" [style=dashed]
  "Maven Central" -> "native image binary" [style=dashed arrowhead=empty weight=0]
  "Maven Central" -> "mill daemon jars" [style=dashed arrowhead=empty weight=0]
  "Maven Central" -> "mill daemon JVM" [style=dashed arrowhead=empty weight=0]
  "Maven Central" -> "build jars" [style=dashed arrowhead=empty weight=0]
  "Maven Central" -> "user module dependency jars" [style=dashed arrowhead=empty weight=0]
  "Maven Central" -> "user module JVM" [style=dashed arrowhead=empty weight=0]
 }
```

Although this may seem like a lot of steps, all of them are completely automatic: jars and
JVMs are downloaded when needed, in parallel where possible, and cached for future use.
Different versions of libraries and packages are assigned different caches on disk and can
co-exist on the same machine. Even different versions of the JVM can be downloaded and used
at the same time without issue, e.g. if different user modules need to compile and run with
different Java versions. This is unlike packages installed via `brew` or `apt` or `yum` where
typically only a single version of a package can be "installed" or "active" globally on a
machine at any one point in time.


And once cached, running `./mill` feels just as fast as running any
pre-installed binary or executable.

Despite this complexity, Mill's zero-install bootstrap process means that the user never needs
to deal with any of it. As long as the user has a project using Mill checked out on their
machine, they can always run `./mill __.compile`, `./mill __.test`, etc. and be off to the races.
No manual installation and setup necessary!

== Conclusion

In this article, we discussed how the Mill build tool implements its zero-step installation
process. This isn't magic, but rather is done by carefully arranging the bootstrapping
process for the Mill project: starting from a `.sh` script (or `.bat` on windows), using it
to bootstrap a native binary, using the native binary to bootstrap a JVM, and using the JVM
to bootstrap the user-defined dependencies they need to build their project.

One thing worth mentioning is that zero-step installation is really the only thing
that scales as a project grows. While multiple 1-step installs can add up and become a long and
tedious installation process, multiple zero-step installs will always remain zero-step.

For the purposes of this article, we simplified and skimmed over a lot of things:

- The intricacies of writing equivalent `.sh` and `.bat` scripts
- https://github.com/oracle/graal/issues/9215[Graal native image not working on windows-aarch64],
  meaning we still need `java` on such systems
- Using a different package repository instead of Maven Central
- Strategies for dealing with non-Maven-Central dependencies in a similar way
- Explicitly pinning the JVM version to ensure consistency regardless of what may be installed locally

Nevertheless, we have discussed most of the important points, and the details will
differ from project to project. Although this article covers bootstrapping Java and JVM
applications, the same principles could apply to bootstrap any non-trivial project and its
dependencies: starting from a shell script, bootstrapping a native binary, which then
bootstraps the messy dependencies that are required for any real-world project.

Hopefully you've come away from this article with an appreciation for how Mill builds upon
prior art to come up with its zero-step install process, so next time the opportunity
arises you can implement something similar in your own projects.