= Scripting on the JVM with Java, Kotlin, and Scala
// tag::header[]
:author: Li Haoyi
:revdate: 24 September 2025

_{author}, {revdate}_


This article will explore use of JVM languages as scripting languages, replacing the Bash and
Python scripts common throughout the industry. We will walk through examples of how the
performance, compile-time safety, and vast library ecosystem of the JVM are advantages over
traditional scripting languages, but also how verbosity, build tool overhead, and lack
of script-focused libraries causes issues. Lastly we will demonstrate how lightweight
languages and script-focused tooling is able to smooth over some of those issues, making
the JVM truly a world-class scripting environment as robust and convenient as any scripting
language out there.

// end::header[]

== An Example Java Single-file Script

Consider this small Java program that someone may write.
This program uses `unirest-java` and `jackson-databind` to fetch the links of a
wikipedia page via the wikipedia API, which it then uses to perform
a breadth-first traversal of the wikipedia article graph. The user provides the
starting input via command-line articles parsed with `picocli`.

.JsonApiClient.java
```java
import com.fasterxml.jackson.databind.*;
import kong.unirest.Unirest;
import picocli.CommandLine;
import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.Callable;

@CommandLine.Command(name = "Crawler", mixinStandardHelpOptions = true)
public class JsonApiClient implements Callable<Integer> {

  @CommandLine.Option(names = {"--start"}, required = true, description = "Starting title")
  private String start;

  @CommandLine.Option(names = {"--depth"}, required = true, description = "Depth of crawl")
  private int depth;

  private static final ObjectMapper mapper = new ObjectMapper();

  public static List<String> fetchLinks(String title) throws Exception {
    var response = Unirest.get("https://en.wikipedia.org/w/api.php")
      .queryString("action", "query")
      .queryString("titles", title)
      .queryString("prop", "links")
      .queryString("format", "json")
      .header("User-Agent", "WikiFetcherBot/1.0 (https://example.com; contact@example.com)")
      .asString();

    if (!response.isSuccess())
      throw new IOException("Unexpected code " + response.getStatus());

    var root = mapper.readTree(response.getBody());
    var pages = root.path("query").path("pages");
    var links = new ArrayList<String>();

    for (var it = pages.elements(); it.hasNext();) {
      var linkArr = it.next().get("links");
      if (linkArr != null && linkArr.isArray()) {
        for (var link : linkArr) {
          var titleNode = link.get("title");
          if (titleNode != null) links.add(titleNode.asText());
        }
      }
    }
    return links;
  }

  public Integer call() throws Exception {
    var seen = new HashSet<>(Set.of(start));
    var current = new HashSet<>(Set.of(start));

    for (int i = 0; i < depth; i++) {
      var next = new HashSet<String>();
      for (var article : current) {
        for (var link : fetchLinks(article)) {
          if (!seen.contains(link)) next.add(link);
        }
      }
      seen.addAll(next);
      current = next;
    }

    try (var w = Files.newBufferedWriter(Paths.get("fetched.json"))) {
      mapper.writerWithDefaultPrettyPrinter().writeValue(w, seen);
    }
    return 0;
  }

  public static void main(String[] args) {
    System.exit(new CommandLine(new JsonApiClient()).execute(args));
  }
}
```

While this example is a
toy program, it is representative of the many kinds of small programs or scripts that
people typically use scripting languages for: simple code gluing together various
data sources and APIs and performing some computation based on them.

== Benefits of Scripting on the JVM

While the JVM isn't traditionally thought of as a scripting platform, in reality there
are many benefits from writing and running your scripts on the JVM:

=== Library Ecosystem

The first benefit of JVM scripting we will discuss is the JVM library ecosystem, which is
mostly hosted on https://central.sonatype.com/[Sonatype Central]. Java and the JVM has
one of the largest and most comprehensive set of third-party libraries of any programming language,
including high-quality well-maintained libraries such as https://github.com/FasterXML/jackson[Jackson],
https://github.com/Kong/unirest-java[Unirest], and https://picocli.info/[PicoCLI] that we used
above. Other JVM languages like Kotlin or Scala host their libraries on the same platform,
which allows them to inter-operate and use each other's libraries.
If a library exists anywhere in the world, it is likely you will find a Java version
of it on Sonatype Central for you to use.

=== IDE Support

Java is known for having great IDEs such as IntelliJ that make it much easier to navigate,
understand, and work with your codebase. This is just as helpful for small scripts as it
is for larger applications, as even in scripts you may be working with third-party libraries
(such as PicoCLI below) for which IDE assistance can come in very useful

image::ScriptIDESupportJava.png[ScriptIDESupportJava.png]

=== Toolability

Beyond the IDE, the JVM probably has the best tools of any programming ecosystem. From
simple things like https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstack.html[jstack]
to debug stuck processes, to https://www.yourkit.com/[Yourkit] or
https://www.ej-technologies.com/jprofiler[JProfiler] to investigate tricky performance issues.
Many of these come in handy when working with small scripts, which like application code
can get stuck or become slow and need investigation and debugging.

=== Performance

While people often neglect the performance of scripts and small programs, just as often you
find people complaining that poorly-optimized scripts are slow and taking longer than they
need to. The JVM not only provides excellent single-core performance that's 10-20x faster
than traditional scripting languages, it also allows you to easily spawn
threads to parallelize your script across multiple cores. This makes it much easier to
optimize and fix slow scripts on the JVM than when running on slower single-threaded
runtimes like Node.js or Python

== Challenges of Small-Scale Java Programs

While there are many benefits to writing scripts running on the JVM, in practice
it can be quite challenging to effectively use Java or other JVM languages to write
scripts.


=== Script Verbosity

The first thing you may notice is: the program above is pretty verbose! Although the Java
language has gotten more concise over the years, with features like the `var` keyword
that we make good use of in the script above, Java _libraries_ tend to still have a
pretty verbose code style that makes the code using them verbose. While
the code above seems _fine_, it might not seem elegant enough that you would choose
to write your scripts in Java on the JVM rather than Python.

=== Tricky to install Java and Maven

The next thing you might deal with writing scripts is how to run them: you need `java`,
and you need a build tool like https://maven.apache.org/[Maven]

* Installing Java can be surprisingly tricky (https://news.ycombinator.com/item?id=46037261[link]),
with a lot of subtle choices and decisions and ways things can go wrong. Installing Maven is
usually more straightforward.

* Installing Java and Maven on all environments your script may
run on is more difficult: you need to ensure every laptop, CI work, or production machine has
the same exact versions of Java and Maven installed.

* Most difficult is maintaining this installation over time: as laptops get provisioned and
retired, Java or Maven versions get upgrades, CI workers get cycled out, ensuring that every
machine has the right version of Java and Maven installed at all times can be quite challenging.

Installing Java and Maven is not a blocker: many people have done it in many codebases over
the past few decades. But it is certainly something that can be a lot more fiddly than expected,
especially when you have to ensure consistency over a fleet of heterogeneous machines and
ensure it stays consistent over time.

=== Configuring Maven is Tedious

Once you have Java and Maven installed, you then need to configure Maven to build it. The
script above has three third-party dependencies, so the Maven config looks something like this:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>json-api-client</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>info.picocli</groupId>
            <artifactId>picocli</artifactId>
            <version>4.7.6</version>
        </dependency>
        <dependency>
            <groupId>com.konghq</groupId>
            <artifactId>unirest-java</artifactId>
            <version>3.14.5</version>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.17.2</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.codehaus.mojo</groupId>
                <artifactId>exec-maven-plugin</artifactId>
                <version>3.4.1</version>
                <configuration>
                    <mainClass>JsonApiClient</mainClass>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

While this Maven config isn't particularly complicated, it is quite a screenful of text we
need to write or copy-paste from somewhere in order to get our small script running.
Again, not a blocker, but more fiddly stuff to set up and maintain just to write our
single-file Java program.

=== Running Maven is Tedious

Lastly, we need to run our script with Maven. The command to do so is as follows:

```console
> mvn compile exec:java -Dexec.args="--start Functional_programming --depth 2"
```

The single-line command for running your Maven project has a whole bunch of footguns
you need to avoid:

- Remember to `compile` first, otherwise your compiled code may be out of date!
- Remember to `exec:java` rather than just `exec`!
- Remember to pass in arguments via `-Dexec.args` rather than passing them indirectly!
- If your arguments themselves need to be quoted, remember to double-escape your nested quotes,
  or triple-escape them if the arguments themselves contain quotes!

This may seem nitpicky - and it is! - but it's just another papercut in making it
annoying to run the `JsonApiClient.java` file we have already written.

None of these issues with Maven or Java are fatal. We've all been writing and running
Java programs for decades by now, in my case since Java 4 in 2004. But the sum-total
of all these papercuts is that it's not pleasant to write small programs in Java.
So small programs and scripts end up being written in Python or Javascript or Ruby,
and even though in theory Java or Scala or Kotlin could work, in practice nobody uses them
for scripting.

== Improving the JVM Scripting Experience

While there are many issues with scripting on the JVM, these
issues are not insurmountable. Next we'll discuss some of the solutions and workarounds
that can mitigate these problems, to provide the streamlined scripting experience that
the JVM deserves

=== Mill as a Lightweight Build Tool

The first thing we can do to simplify our script workflow is to use a lighter weight
build tool such as https://www.jbang.dev/[JBang] or Mill. These tools make it much
easier to configure some third-party dependencies and compile/run a single file.
For example, JBang lets you write
https://www.jbang.dev/documentation/jbang/latest/script-directives.html[//DEPS header comments]
and run the `.java` file directly from the command line:

.JsonApiClient.java
```java
//DEPS info.picocli:picocli:4.7.6
//DEPS com.konghq:unirest-java:3.14.5
//DEPS com.fasterxml.jackson.core:jackson-databind:2.17.2
import com.fasterxml.jackson.databind.*;
import kong.unirest.Unirest;
import picocli.CommandLine;
...
```

```console
> jbang HtmlScraper.java -s Functional_programming -d 2
```

The Mill build tool uses a similar
xref:mill::javalib/intro.adoc#_single_file_scripts[YAML header syntax] that looks a bit
different but otherwise works basically the same way:

.JsonApiClient.java
```java
//| mvnDeps:
//| - info.picocli:picocli:4.7.6
//| - com.konghq:unirest-java:3.14.5
//| - com.fasterxml.jackson.core:jackson-databind:2.17.2
import com.fasterxml.jackson.databind.*;
import kong.unirest.Unirest;
import picocli.CommandLine;
...
```

```console
> ./mill HtmlScraper.java -s Functional_programming -d 2
```

Such lightweight build tools make it much easier to run our small Java program:

* Both JBang and Mill make it super easy to configure dependencies and run scripts from
  the command line by adding a header to the single-file Java program, solving the
  xref:#_configuring_maven_is_tedious[Configuring Maven is Tedious] and xref:#_running_maven_is_tedious[Running Maven is Tedious]
  problems above

* Mill with it's `./mill` bootstrap script also solves
  xref:#_tricky_to_install_java_and_maven_[Tricky to install Java and Maven] problem,
  as `./mill` will automatically download & cache the JVM and build-tool installation and
  ensure you are using the correct, consistent version

However, even if building and running small scripts written in Java is convenient, writing
and maintaining the code itself can be a pain due to the verbosity of the Java language
and libraries that makes even simple programs (such as that above) take pages and pages of code.
While Java's verbosity may be fine - or even beneficial - for complicated application code,
the same verbosity can get in the way of writing small scripts.

But Java isn't the only language on the JVM!

=== Kotlin as a Lightweight Language

One option here is to write the script in Kotlin. Kotlin is much more syntactically concise
than Java, which means much less code to write the same things overall. A version of the
`HtmlScraper.java` translated to Kotlin is shown below, using the Kotlin
https://ajalt.github.io/clikt/[Clikt] library rather than PicoCLI:

.JsonApiClient.kt
```scala
//| mvnDeps:
//| - com.github.ajalt.clikt:clikt:5.0.3
//| - com.konghq:unirest-java:3.14.5
//| - org.jetbrains.kotlinx:kotlinx-serialization-json:1.7.3
import com.github.ajalt.clikt.core.CliktCommand
import com.github.ajalt.clikt.core.main
import com.github.ajalt.clikt.parameters.options.*
import com.github.ajalt.clikt.parameters.types.int
import kotlinx.serialization.json.*
import kong.unirest.Unirest
import java.nio.file.*

fun fetchLinks(title: String): List<String> {
    val response = Unirest.get("https://en.wikipedia.org/w/api.php")
        .queryString("action", "query")
        .queryString("titles", title)
        .queryString("prop", "links")
        .queryString("format", "json")
        .header("User-Agent", "WikiFetcherBot/1.0 (https://example.com; contact@example.com)")
        .asString()

    if (!response.isSuccess) return emptyList()

    val json = Json.parseToJsonElement(response.body).jsonObject
    val pages = json["query"]?.jsonObject?.get("pages")?.jsonObject ?: return emptyList()
    return pages.values.flatMap { page ->
        page.jsonObject["links"]
            ?.jsonArray
            ?.mapNotNull { it.jsonObject["title"]?.jsonPrimitive?.content }
            ?: emptyList()
    }
}

class Crawler : CliktCommand(name = "wiki-fetcher") {
    val start by option(help = "Starting Wikipedia article").required()
    val depth by option(help = "Depth of link traversal").int().required()

    override fun run() {
        var seen = mutableSetOf(start)
        var current = mutableSetOf(start)

        repeat(depth) {
            val next = current.flatMap { fetchLinks(it) }.toSet()
            current = (next - seen).toMutableSet()
            seen += current
        }

        val jsonOut = Json { prettyPrint = true }
            .encodeToString(JsonElement.serializer(), JsonArray(seen.map { JsonPrimitive(it) }))
        Files.writeString(Paths.get("fetched.json"), jsonOut)
    }
}

fun main(args: Array<String>) = Crawler().main(args)
```

```console
> ./mill JsonApiClient.kt --start Functional_programming --depth 2
```

The Kotlin program has about 1/3 fewer lines than the Java equivalent, and overall much less
dense. Kotlin features like the properties used to define
`val depth` and `val start`, `?`, and `.mapNotNull` simplify the
code substantially. This makes it possible to express the same program in a much less verbose syntax.

As Kotlin is also a JVM language, it comes with all the same benefits as writing scripts in
Java, e.g. the excellent IDE support provided by editors such as IntelliJ:

image::ScriptIDESupportKotlin.png[ScriptIDESupportKotlin.png]

This makes using Kotlin a great way to streamline the scripting experience on the JVM.
Although the example above uses Mill as the build tool, Kotlin also supports
https://kotlinlang.org/docs/custom-script-deps-tutorial.html[its own scripting workflows],
which are also used in Gradle and other projects.

Although scripts in Kotlin are markedly nicer to write and read than scripts written
in Java, there is one more step further that we can take:

== Scala with its Lightweight Libraries

The last step to simplify scripting on the JVM is to write the script in Scala.
Scala is yet another JVM language, like Kotlin. But unlike Kotlin, Scala has
many script-focused libraries such as https://github.com/com-lihaoyi/os-lib[OS-Lib],
https://github.com/com-lihaoyi/mainargs[MainArgs],
https://github.com/com-lihaoyi/requests-scala[Requests-Scala],
https://github.com/com-lihaoyi/upickle[uPickle],
or https://github.com/com-lihaoyi/PPrint[PPrint] that make it very convenient to write
small script-like programs in Scala. The above `HtmlScraper.kt` translated to an equivalent
`HtmlScraper.scala` is shown below:

.HtmlScraper.scala
```scala
def fetchLinks(title: String): Seq[String] = {
  val resp = requests.get.stream(
    "https://en.wikipedia.org/w/api.php",
    params = Seq(
      "action" -> "query",
      "titles" -> title,
      "prop" -> "links",
      "format" -> "json"
    )
  )
  for {
    page <- ujson.read(resp)("query")("pages").obj.values.toSeq
    links <- page.obj.get("links").toSeq
    link <- links.arr
  } yield link("title").str
}

def main(start: String, depth: Int) = {
  var seen = Set(start)
  var current = Set(start)
  for (i <- Range(0, depth)) {
    current = current.flatMap(fetchLinks(_)).filter(!seen.contains(_))
    seen = seen ++ current
  }

  pprint.log(seen)
  os.write(os.pwd / "fetched.json", upickle.stream(seen, indent = 4))
}
```

```console
> ./mill HtmlScraper.scala --start Functional_programming --depth 2
```

What is notable about `HtmlScraper.scala` is how much less _stuff_ there is to read,
with about 1/2 the lines of code as `HtmlScraper.kt` and 1/3 the lines of code as
the `HtmlScraper.java`:

- The `requests.get`, `ujson.read`, and `os.write` APIs come from the Mill's bundled
  libraries, which makes it super easy to interact with third-party services, parse
  their responses, and deal with the filesystem

- Rather than parsing arguments via annotations or a special class, which is how it's
  done in PicoCLI or Clikt, `HtmlScraper.scala` uses MainArgs which lets you simply
  define a `def main` method and turns the parameter list into the command-line parser

In general, the Scala script we see above looks similar to any scripting language,
with code that specifies clearly the logical steps of accessing the Wikipedia
API and performing the breadth-first search, but without the verbose machinery
necessary to implement that logic in Kotlin or Java.
And although the Scala program is much shorter and more concise than the Java program
we started with, overall it still has all the benefits of running on the JVM:

- We can depend on any JVM library via `//| mvnDeps`. Although the Scala ecosystem
  may be smaller than the Java ecosystem, Scala can make use of any Java library as well,
  and so you can always find a library to do whatever you need to do

- We have full support in IDEs like IntelliJ or VSCode:

image::ScriptIDESupportScala.png[ScriptIDESupportScala.png]

- All other JVM tools work with Scala just as easily as they do with Java: `jstack`,
  Yourkit, JProfiler, etc.

- Scala performance is just as good as Java performance, and it makes it even easier
  to parallelize things using `scala.concurrent.Future` so your scripts can make
  full use of the multiple cores available on any modern computer.

== Conclusion

In this article, we discussed how scripts can benefit
from the JVM's library ecosystem, IDE support, tools, and performance, but also
how they are hampered by Maven's clunkiness, Java's verbosity, and the lack
of script-focused libraries. We explored solutions to these issues, by
running our scripts in Mill to simplify the workflow, porting them to Kotlin to
cut down on the verbosity, and moving to Scala to take advantage
of the many scripting-focused libraries in the Scala ecosystem.

Scripting on the JVM has never been very popular in the past, with
projects like https://github.com/jruby/jruby[JRuby] or
https://www.jython.org/[Jython] not taking off, and most JVM projects still
relying on a mix of Python or Bash for their scripting needs. Even with
the solutions discussed above, other issues such as the JVM's slow startup
time and large memory footprint remain as challenges

Despite that, scripting on the JVM can definitely be a valuable tool in your
toolbox. By writing scripts on the JVM, you can leverage all your existing
JVM experience working in Java/Kotlin/Scala, benefit from the performant
JVM runtime and rich JVM ecosystem of libraries, tools and IDEs. If this
sounds appealing, do try out the `./mill` build tool and it's JVM scripting
capabilities we mentioned above, and let us know in the Github discussions
how it goes for you!