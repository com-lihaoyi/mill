= Mill 1.1.0: Declarative Project Configuration and Single-File Scripts
// tag::header[]
:author: Li Haoyi
:revdate: 24 Dec 2025

_{author}, {revdate}_

The newly-released Mill version 1.1.0 contains two major new features:
xref:mill::javalib/intro.adoc#_declarative_modules[declarative `build.mill.yaml` configuration files],
and the ability to run xref:mill::javalib/intro.adoc#_single_file_scripts[single-file
Java, Scala, and Kotlin programs] with their build configuration in a build header
comment. This allows your project's build to be configured via a compact YAML file:

```yaml
# build.mill.yaml
extends: [mill.javalib.JavaModule]
mvnDeps:
- org.jsoup:jsoup:1.7.2
```

Or even as a single-file with the build configuration in a `//|` header comment:

```java
//| mvnDeps:
//| - org.jsoup:jsoup:1.7.2
import org.jsoup.Jsoup;
public class HtmlScraper {
  ...
}
```
```console
> ./mill HtmlScraper.java Java 1
```


While https://github.com/com-lihaoyi/mill/blob/main/changelog.adoc#110[the changelog] has
a more thorough listing of improvements and migration instructions, this blog post will
dive into these two new features, and how they change the way someone can use Mill and
develop on the JVM in general.


// end::header[]

== Declarative vs Programmable Builds

Traditionally, Mill has always had a
xref:mill::javalib/intro.adoc#_programmable_modules[programmable configuration syntax], similar
to Gradle. This has made Mill a good fit for projects that require custom build logic
and developers who are comfortable programming their build tool, but it comes at a cost:

1. Programmable configuration is inherently more complicated than declarative configuration,
   which can result in additional difficulty learning and maintaining the build setup

2. Not every project requires custom build logic, and so the added complexity of a programmable
   configuration syntax is pure downside without benefit.

This has made Mill a build tool most suitable for advanced use cases, as someone
https://www.reddit.com/r/java/comments/1ea3zv4/comment/lekc0qf[wrote on Reddit]:

> I'm relative new Mill and it is the most pleasant built tool for complex builds.
> When your build starts to hurt because it does not fit into Maven well enough, the Mill
> is a build tool worth evaluating.

However, for simple projects with simple builds, have a fully programmable configuration model
adds a lot of complexity for no gain. So for the majority of simple projects the only suitable
build tool was Maven. Maven has some weaknesses that make even working with simple projects
somewhat tedious, which I'll discuss in this article, but for Java programs up until now
you really had no other option.

Mill 1.1.0's new declarative configuration and single-file script support aims to change that.
Mill's declarative `build.mill.yaml` files aim to be a viable alternative to Maven for small
projects where declarative configuration is most suitable, while streamlining a lot of the
pain points that can make Maven inconvenient to use.

== The Challenge of Small Java Programs

To understand the need for declarative build configs, consider a developer that has written
a small program they want to run:


```java
// HtmlScraper.java
import org.jsoup.Jsoup;
import java.util.*;

public class HtmlScraper {
  static List<String> fetchLinks(String title) throws Exception {
    var url = "https://en.wikipedia.org/wiki/" + title;
    var doc = Jsoup.connect(url).header("User-Agent", "My Scraper").get();
    var links = new ArrayList<String>();
    for (var a : doc.select("main p a")) {
      var href = a.attr("href");
      if (href.startsWith("/wiki/")) links.add(href.substring(6));
    }
    return links;
  }

  public static void main(String[] args) throws Exception {
    if (args.length < 2) throw new Exception("HtmlScraper.java <start> <depth>");
    var seen = new HashSet<>(Set.of(args[0]));
    var current = new HashSet<>(Set.of(args[0]));
    for (int i = 0; i < Integer.parseInt(args[1]); i++) {
      var next = new HashSet<String>();
      for (String article : current) {
        for (String link : fetchLinks(article)) {
          if (seen.add(link)) next.add(link);
        }
      }
      current = next;
    }
    for (String s : seen) System.out.println(s);
  }
}
```

This is a single-file program that uses the https://jsoup.org/[Jsoup] library to scrape
the links off of a Wikipedia article's HTML page, which it then uses to perform a breadth-first
traversal across the Wikipedia article graph. While a bit contrived, this code is representative
of many of the small programs that may be written in practice:

- A student project
- A one-off prototype
- A small command-line script

In all these cases, the program would have a small amount of code and one or two third-party
dependencies. But with traditional build tools like Maven, running such code can be
surprisingly difficult:

1. Installing Java, which has https://news.ycombinator.com/item?id=46037261[a lot of intricacies]
2. Installing Maven
3. Writing out the `pom.xml`: _can you write the POM for the above program without copy-pasting from StackOverflow/Google/ChatGPT?_
4. Running the program using Maven: _can you remember the command-line invocation without looking it up?_

None of these are _blockers_. But for someone trying to write a small program that can build
and run reliably on their laptop, their colleagues' laptops, their CI machines and their
production environment, these things can end up being surprisingly tricky.

While you could run the program using Mill, setting up the programmable `build.mill` file
for this simple single-file program is also be a bit complicated:

```scala
// build.mill
package build
import mill.*, javalib.*
object `package` extends JavaModule {
  def moduleDeps = Seq(mvn"org.jsoup:jsoup:1.7.2")
}
```

While this `build.mill` file isn't rocket science, but it's a lot more complex than
it should be for someone who wants to write a small program like the `HtmlScraper.java`
we see above: ``package`` declarations, ``import``s, ``object``s and ``def``s, and so on.
These things are convenient when you actually need to program your build, but just get in
the way when a user just wants to run their Java program with 1 third-party dependency.

In theory Java and the JVM is a reasonable platform to write and run small programs: easy to
learn, widely used, and a rich standard library ecosystem of third-party libraries. The same
applies to other JVM languages like Scala and Kotlin. But in practice this build-tool-setup
friction means that people prefer to write their small programs in Bash, Python, or Node.js
rather than writing them in Java.

== Declarative Mill Builds

The first step Mill takes towards solving this issue with running small JVM programs is
a new declarative configuration format. That lets us turn the rather complicated programmable
`build.mill` above into a declarative `build.mill.yaml` file, such as that below:

```yaml
# build.mill.yaml
extends: [mill.javalib.JavaModule]
mvnDeps:
- org.jsoup:jsoup:1.7.2
```

Mill's declarative `build.mill.yaml` format is less flexible than the programmable `build.mill`
config files. For example, xref:mill::javalib/intro.adoc#_custom_build_logic[Custom Build Logic]
cannot be done in declarative `build.mill.yaml`, which only allow configuration of primitive
types and basic collections. However, in return the configuration format is much simpler: no
need to worry about `package` declarations, ``import``s, `object` and `def` statements, etc.
These `build.mill.yaml` files contain only the configuration you need, and _nothing else_.

=== Non-Trivial Declarative Builds

While Mill's declarative build files are simpler than its programmable config files, they are
by no means limited to toy projects. `build.mill.yaml` files support most of Mill's
task overrides, e.g. here is a more verbose example from xref:mill::javalib/config.adoc[]:

```yaml
extends: [mill.javalib.JavaModule]
mvnDeps:
- org.thymeleaf:thymeleaf:3.1.1.RELEASE
- org.slf4j:slf4j-nop:2.0.7

# Add a custom maven repository URL
repositories: ["https://oss.sonatype.org/content/repositories/releases"]

# Set an explicit main class
mainClass: "foo.Foo2"

# Add an additional source folder and resource folder, in addition to the default one
sources: ["./src", "./custom-src"]
resources: ["./resources", "./custom-resources"]

# Configure java compiler and runtime options and env vars
javacOptions: ["-deprecation"]
forkArgs: ["-Dmy.custom.property=my-prop-value"]
forkEnv: { "MY_CUSTOM_ENV": "my-env-value" }
```

Mill's declarative builds also support
xref:mill::javalib/intro.adoc#_multi_module_projects[multi-module projects] for when your
codebase grows beyond the complexity of a single module. The documentation for
xref:mill::javalib/config.adoc[] goes into more detail of how to do various tasks within
declarative `build.mill.yaml` configuration files.

In general, we hope that Mill's new declarative `build.mill.yaml` syntax will be a
viable alternative to Maven for Java developers who prefer declarative builds, and complement
it's existing programmable `build.mill` syntax nicely:

- For projects that just need basic key-value configuration, declarative `build.mill.yaml` config
  is a great fit to keep things simple

- For projects that need custom build logic, `build.mill` files can provide the required
  flexibility at the cost of some complexity

=== Integrating Programmable and Declarative Styles

Although Mill's declarative builds are akin to Maven, and Mill's programmable builds are akin to
Gradle, one thing unique about Mill is how well integrated the two approaches are:

* Declarative `build.mill.yaml` files can also inter-operate with programmable `build.mill` files,
  via xref:mill::javalib/config.adoc#_custom_module_traits[custom module traits] and
  xref:mill::javalib/config.adoc#_programmable_moduledeps[depending on programmable modules],
  so you can mix-and-match the two formats depending on which is more appropriate for each module.

* Setting `mvnDeps`, `repositories`, `mainClass`, etc. means the same thing in both formats
  even though the surface syntax is slightly different. The {mill-doc-url}/api/latest/mill.html[Mill API Reference],
  traditionally used as documentation for Mill's programmable configuration format, applies
  fully to declarative builds as well.

* Under the programmable and declarative configuration styles, it's still the same Mill build
  tool. That means concepts like xref:mill::depth/parallelism.adoc[parallelism],
  xref:mill::depth/caching.adoc[caching], xref:mill::depth/sandboxing.adoc[sandboxing], etc.
  work the same way regardless of which configuration style you are using.

* Like the rest of Mill, its declarative configuration syntax applies equally to
  all 3 major JVM languages: xref:mill::javalib/config.adoc[Java],
  xref:mill::scalalib/config.adoc[Scala], and xref:mill::kotlinlib/config.adoc[Kotlin].

Unlike Maven and Gradle, Mill's declarative and programmable configuration styles are seamlessly
integrated. That means you can transition between them easily without needing to do an
invasive replacement of one build tool with another. We hope that this will avoid the "holy wars"
common when discussing these topics, instead letting developers choose whichever configuration
style makes the most sense for their particular project without being "locked in" to that choice
forever.

Mill's declarative syntax pushes the limits of how concisely and easily you can setup a
Java project:

1. With Mill's xref:mill::cli/installation-ide.adoc#_bootstrap_scripts[Bootstrap Scripts],
   you never need to manually install Mill or install Java, and anyone who checks out your
   codebase is guaranteed to get the correct version of them when running `./mill`

2. Mill's declarative `build.mill.yaml` files are boilerplate-free, and are concise enough
   you _can_ write it out by hand and maintain them yourself without relying on copy-paste
   cargo-culting from StackOverflow/Google/ChatGPT

3. Mill's CLI syntax for running the code `./mill run <arg1> <arg2>` follows the conventions
   established by other CLIs (`python foo.py <arg1> <arg2>`, `bash foo.sh <arg1> <arg2>`, etc.)
   so anyone picking up Mill should find it immediately familiar without having to first
   ask their AI assistant.

However, needing to set up a separate "build file" is still a point of friction, and Mill 1.1.0
has one more trick to further reduce the overhead of building and running a small Java program.



== Mill Single-File Scripts

== Conclusion