= Mill 1.1.0: Declarative Config and Single-File Scripts on the JVM
// tag::header[]
:author: Li Haoyi
:revdate: 24 Dec 2025

_{author}, {revdate}_

The newly-released version 1.1.0 of the Mill build tool contains two major new features:
xref:#_declarative_mill_builds[declarative build.mill.yaml configuration files],
and the ability to run xref:#_mill_single_file_scripts[single-file
Java, Scala, and Kotlin programs] with their configuration in a build header
comment. This allows your project's build to be configured via a compact YAML file:

```yaml
# build.mill.yaml
extends: [mill.javalib.JavaModule]
mvnDeps:
- org.jsoup:jsoup:1.7.2
```

Or even together with the code in a single-file with a `//|` build header comment:

```java
//| mvnDeps:
//| - org.jsoup:jsoup:1.7.2
import org.jsoup.Jsoup;
public class HtmlScraper {
  ...
}
```
```console
> ./mill HtmlScraper.java Java 1
```


While https://github.com/com-lihaoyi/mill/blob/main/changelog.adoc#110[the version 1.1.0 changelog]
has a more thorough listing of improvements and migration instructions, this blog post will
dive into these two new features. We will discuss how these features work, why they are
interesting, and how we hope they will open up new use cases for writing small-scale programs
in Java and other JVM languages that were previously unfeasible due to tooling complexity.


// end::header[]

== Declarative vs Programmable Builds

Traditionally, the Mill build tool has always had a
xref:mill::javalib/intro.adoc#_programmable_module_config[programmable config syntax],
similar to https://gradle.org/[Gradle]. This has made Mill a good fit for projects that require
custom build logic and developers who are comfortable programming their build tool, but it
comes at a cost:

1. Programmable configuration is inherently more complicated than declarative configuration,
   which can result in additional difficulty learning and maintaining the build setup

2. Not every project requires custom build logic, and so the added complexity of programmable
   configuration is pure downside without benefit.

This has made Mill a build tool traditionally most suitable for advanced use cases, as someone
https://www.reddit.com/r/java/comments/1ea3zv4/comment/lekc0qf[wrote on Reddit]:

> I'm relative new Mill and it is the most pleasant built tool for complex builds.
> When your build starts to hurt because it does not fit into Maven well enough, the Mill
> is a build tool worth evaluating.

However, for simple projects with simple builds, programmable configuration
adds a lot of complexity for no gain. So for simple projects the only suitable
build tool was https://maven.apache.org/[Maven]. Maven has some weaknesses that can
make even simple projects somewhat tedious to work with, but for Java programs
you really had no other option.

Mill 1.1.0 aims to change that. Mill's declarative `build.mill.yaml` files aim to be a
viable alternative to Maven for small projects where declarative configuration is most
suitable, while fixing a lot of the pain points that can make Maven inconvenient to use.
We'll discuss these pain points next:

== The Challenge of Small Java Programs

To understand the pain points of running small Java programs, consider a developer
that has written a single-file Java program they want to run:


```java
// HtmlScraper.java
import org.jsoup.Jsoup;
import java.util.*;

public class HtmlScraper {
  static List<String> fetchLinks(String title) throws Exception {
    var url = "https://en.wikipedia.org/wiki/" + title;
    var doc = Jsoup.connect(url).header("User-Agent", "My Scraper").get();
    var links = new ArrayList<String>();
    for (var a : doc.select("main p a")) {
      var href = a.attr("href");
      if (href.startsWith("/wiki/")) links.add(href.substring(6));
    }
    return links;
  }

  public static void main(String[] args) throws Exception {
    if (args.length < 2) throw new Exception("HtmlScraper.java <start> <depth>");
    var seen = new HashSet<>(Set.of(args[0]));
    var current = new HashSet<>(Set.of(args[0]));
    for (int i = 0; i < Integer.parseInt(args[1]); i++) {
      var next = new HashSet<String>();
      for (String article : current) {
        for (String link : fetchLinks(article)) {
          if (seen.add(link)) next.add(link);
        }
      }
      current = next;
    }
    for (String s : seen) System.out.println(s);
  }
}
```

This is a simple program that uses the https://jsoup.org/[Jsoup] library to scrape
the links off of a Wikipedia article's HTML page, which it then uses to perform a breadth-first
traversal across the Wikipedia article graph. While a bit contrived, this code is representative
of many of the small programs that may be written in practice:

- A student project
- A one-off prototype
- A small command-line script

In all these cases, the program would have a small amount of code and one or two third-party
dependencies. But with traditional build tools like Maven, running such code can be
surprisingly difficult:

1. Installing Java, which has https://news.ycombinator.com/item?id=46037261[a surprising number of intricacies]
2. Installing Maven
3. Writing out the `pom.xml` (can you write the POM for the above program without copy-paste cargo-culting from StackOverflow/Google/ChatGPT?)
4. Running the program using Maven (can you remember the command-line invocation without looking it up?)

None of these are _blockers_: after all we've been building and running Java programs for decades,
and the necessary config is in the  xref:#_foot_notes[].
But for someone trying to write a small program that can build and run reliably on their laptop,
their colleagues' laptops, their CI machines and their production environment, these things can
end up being surprisingly tricky.

You could run the program using the Mill build tool instead of Maven, which has some benefits.
Mill's xref:mill::cli/installation-ide.adoc#_bootstrap_scripts[Bootstrap Scripts] manage both your
Mill and your JVM installation for you so you don't need to install things manually, and
Mill's command-line invocation syntax `./mill run <arg1> <arg2>` is a lot more intuitive than Maven's.
But While Mill `build.mill` files are a lot more concise than Maven ``pom.xml``s, the amount of
irrelevant things you have to do due to their programmable nature makes them still pretty involved:

```scala
// build.mill
package build
import mill.*, javalib.*
object `package` extends JavaModule {
  def moduleDeps = Seq(mvn"org.jsoup:jsoup:1.7.2")
}
```

This `build.mill` file has a lot of syntax that is irrelevant to someone who wants to
write a small program like the `HtmlScraper.java`
we see above: ``package`` declarations, ``import``s, ``object``s and ``def``s, and so on.
These things are convenient when you _actually need to program your build_, but just get in
the way when a user just wants to run their small Java program with 1 third-party dependency.

In theory Java and the JVM is a great platform to write and run small programs: easy to
learn, widely used, and a rich standard library and ecosystem of high-quality third-party
libraries. But in practice this build-tool-setup
friction means that people prefer to write their small programs in Bash, Python, or Node.js
rather than writing them in Java, Scala or Kotlin. While that is the reality of today,
Mill 1.1.0 aims to change that for the future.

== Declarative Mill Builds

The first step Mill takes towards solving this issue with running small JVM programs is
a new declarative configuration format. That lets us turn the rather complicated programmable
`build.mill` above into a declarative `build.mill.yaml` file, such as that below:

```yaml
# build.mill.yaml
extends: [mill.javalib.JavaModule]
mvnDeps:
- org.jsoup:jsoup:1.7.2
```

Mill's declarative `build.mill.yaml` format is less flexible than the programmable `build.mill`
config files: it doesn't support xref:mill::javalib/intro.adoc#_custom_build_logic[Custom Build Logic]
and only allows configuration of primitive types and basic collections. However, in exchange
the declarative configuration is much simpler: no
need to worry about `package` declarations, ``import``s, `object` and `def` statements, etc.

Like Maven, Mill follows the principle of _convention over configuration_: the class we extend
`mill.javalib.JavaModule` comes with a rich set of reasonable defaults, and we only need to
configure the things we want to do differently. That ensures that these `build.mill.yaml`
files contain only the configuration you need, and __nothing else__. Compared to the equivalent
Maven `pom.xml`, `build.gradle`, or programmable `build.mill` files, Mill's `build.mill.yaml`
files are truly declarative and boilerplate-free.

=== Non-Trivial Declarative Builds

While Mill's declarative build files are simpler than its programmable config files, they are
by no means limited to toy projects: `build.mill.yaml` files support most of Mill's
configuration overrides. For example, here is a more verbose example from the documentation for
xref:mill::javalib/declarative.adoc[] that demonstrates many of the common configuration
keys a developer may want to set:

```yaml
extends: [mill.javalib.JavaModule]
mvnDeps:
- org.thymeleaf:thymeleaf:3.1.1.RELEASE
- org.slf4j:slf4j-nop:2.0.7

# Add a custom maven repository URL
repositories: ["https://oss.sonatype.org/content/repositories/releases"]

# Set an explicit main class
mainClass: "foo.Foo2"

# Add an additional source folder and resource folder, in addition to the default one
sources: ["./src", "./custom-src"]
resources: ["./resources", "./custom-resources"]

# Configure java compiler and runtime options and env vars
javacOptions: ["-deprecation"]
forkArgs: ["-Dmy.custom.property=my-prop-value"]
forkEnv: { "MY_CUSTOM_ENV": "my-env-value" }
```

These keys are all documented in
{mill-doc-url}/api/latest/mill/javalib/JavaModule.html#mvnDeps-0[the API reference for mill.javalib.JavaModule],
along with every other configuration key that is available.
Mill's declarative builds also support
xref:mill::javalib/declarative.adoc#_unit_integration_testing[test suites],
xref:mill::javalib/intro.adoc#_multi_module_projects[multi-module projects],
xref:mill::javalib/declarative.adoc#_packaging_publishing[packaging and publishing],
and other common build tool features.

In general, we hope that Mill's new declarative `build.mill.yaml` syntax will be a
viable alternative to Maven for Java developers who prefer declarative builds, and complement
it's existing programmable `build.mill` syntax nicely:

- For projects that just need basic key-value configuration, declarative `build.mill.yaml` config
  is a great fit to keep things simple

- For projects that need custom build logic, `build.mill` files can provide the required
  flexibility at the cost of some complexity

Mill makes it easy to use both styles in the same project, so each can be used in the part of
the project where is most suitable, and users can easily transition between the two styles
as necessary.

=== Integrating Programmable and Declarative Styles

Although Mill's declarative builds are akin to Maven, and Mill's programmable builds are akin to
Gradle, one thing unique about Mill is how well integrated the two approaches are:

* Declarative `build.mill.yaml` files can inter-operate with programmable `build.mill` files,
  via xref:mill::javalib/declarative.adoc#_custom_module_traits[custom module traits] and
  xref:mill::javalib/declarative.adoc#_programmable_moduledeps[depending on programmable modules],
  so you can mix-and-match the two config styles depending on which is more appropriate for each module.

* Setting `mvnDeps`, `repositories`, `mainClass`, `jvmId`, etc. means the same thing in both
  styles even though the surface syntax is slightly different. The
  {mill-doc-url}/api/latest/mill.html[Mill API Reference], traditionally used as documentation
  for Mill's programmable configuration, applies fully to its declarative configuration as well.

* Under the programmable and declarative configuration styles, it's still the same Mill build
  tool. That means concepts like xref:mill::depth/parallelism.adoc[parallelism],
  xref:mill::depth/caching.adoc[caching], xref:mill::depth/sandboxing.adoc[sandboxing],
  command-line invocations like `./mill inspect`, etc. all work the same way regardless of
  which configuration style you are using.

Traditionally, you were locked into a declarative or programmable configuration style after choosing
between Maven or Gradle, making it a big decision and the root of many "holy wars". In contrast,
with Mill you can easily transition between declarative and programmable configuration styles
as appropriate, allowing the developer to pick whatever makes sense at the moment with the
knowledge they can easily change styles later as necessary.

=== Simplifying Java Project Setup with Mill

Mill's declarative configuration pushes the limits of how easily you can setup a
Java project:

1. With Mill's xref:mill::cli/installation-ide.adoc#_bootstrap_scripts[Bootstrap Scripts],
   you never need to manually install Mill or install Java, and anyone who checks out your
   codebase is guaranteed to get the correct version of them when running `./mill`

2. Mill's declarative `build.mill.yaml` files are boilerplate-free, and are concise enough
   you _can_ write it out by hand and maintain them yourself without relying on copy-paste
   cargo-culting from StackOverflow/Google/ChatGPT

3. Mill's CLI syntax for running the code `./mill run <arg1> <arg2>` follows the conventions
   established by other CLIs (`python foo.py <arg1> <arg2>`, `bash foo.sh <arg1> <arg2>`, etc.)
   so anyone picking up Mill should find it familiar and easy to use without having to first
   ask their AI assistant.

Like the rest of Mill, its declarative configuration syntax works for
all 3 major JVM languages: xref:mill::javalib/declarative.adoc[Java],
xref:mill::scalalib/declarative.adoc[Scala], and xref:mill::kotlinlib/declarative.adoc[Kotlin].
So anyone using a JVM language, or even multiple JVM languages, can use it to simplify their
setup and development workflows especially for smaller projects where setting up a build tool
like Maven, Gradle, or SBT can be troublesome.

However, needing to set up a separate "build file" is still a point of friction, and Mill 1.1.0
has one more trick to further reduce the overhead of building and running a small Java program.

== Mill Single-File Scripts

Mill 1.1.0 supports a new xref:mill::javalib/intro.adoc#_single_file_scripts[single-file script]
format for Java, Scala, and Kotlin files. For example, this lets you take the `HtmlScraper.java`
file above, add a `//|` build-header comment with the `mvnDeps` configuration it needs, and
run it directly without needing a separate build file:

```java
//| mvnDeps:
//| - org.jsoup:jsoup:1.7.2
import org.jsoup.Jsoup;
import java.util.*;

public class HtmlScraper {
  static List<String> fetchLinks(String title) throws Exception {
    var url = "https://en.wikipedia.org/wiki/" + title;
    var doc = Jsoup.connect(url).header("User-Agent", "My Scraper").get();
    var links = new ArrayList<String>();
    for (var a : doc.select("main p a")) {
      var href = a.attr("href");
      if (href.startsWith("/wiki/")) links.add(href.substring(6));
    }
    return links;
  }

  public static void main(String[] args) throws Exception {
    if (args.length < 2) throw new Exception("HtmlScraper.java <start> <depth>");
    var seen = new HashSet<>(Set.of(args[0]));
    var current = new HashSet<>(Set.of(args[0]));
    for (int i = 0; i < Integer.parseInt(args[1]); i++) {
      var next = new HashSet<String>();
      for (String article : current) {
        for (String link : fetchLinks(article)) {
          if (seen.add(link)) next.add(link);
        }
      }
      current = next;
    }
    for (String s : seen) System.out.println(s);
  }
}
```

This can be run via

```console
> ./mill HtmlScraper.java Java 1
Ptolemy
Bali
Greater_Sunda_Islands
Rama
Sulaiman_al-Tajir
Endemism
Gajah_Mada
Yingya_Shenglan
Mahabharata
Cirebon
Ethnic_groups_in_Indonesia
...
```

NOTE: the `extends: [mill.javalib.JavaModule]` clause is optional in single-file scripts;
if not provided it is inferred from the file extension (here `.java`) but it can also be
xref:mill::javalib/script.adoc#_custom_script_module_classes[configured explicitly] if needed
e.g. to integrate your scripts with a larger Mill project.

Although superficially this looks like running a Python or Bash script, under the hood it
actually goes through the full build tool process - dependency resolution, compilation,
and execution - with every step cached and parallelized where-ever possible.

=== Multi-Language JVM Scripting

Mill single-file scripts are inspired by the https://www.jbang.dev/[JBang] project for Java,
https://ammonite.io/[Ammonite] and https://scala-cli.virtuslab.org/[Scala-CLI] for Scala,
and https://blog.jetbrains.com/kotlin/2024/11/state-of-kotlin-scripting-2024/[Scripting for Kotlin].
Like the rest of Mill, single-file scripts support the three major JVM languages, and you can
run scripts written in xref:mill::javalib/script.adoc[Java], xref:mill::scalalib/script.adoc[Scala],
or xref:mill::kotlinlib/script.adoc[Kotlin]. For example, here is a
xref:mill::kotlinlib/script.adoc#_html_web_scraper[Kotlin version of the HtmlScraper]

```kotlin
//| mvnDeps: [org.jsoup:jsoup:1.7.2]
import org.jsoup.Jsoup

fun fetchLinks(title: String): List<String> {
    val url = "https://en.wikipedia.org/wiki/$title"
    val doc = Jsoup.connect(url).header("User-Agent", "My Scraper").get()

    return doc.select("main p a")
        .mapNotNull { a ->
            val href = a.attr("href")
            if (href.startsWith("/wiki/")) href.removePrefix("/wiki/")
            else null
        }
}

fun main(args: Array<String>) {
    if (args.size < 2) throw Exception("HtmlScraper.kt <start> <depth>")
    var seen = mutableSetOf(args[0])
    var current = mutableSetOf(args[0])

    repeat(args[1].toInt()) {
        val next = mutableSetOf<String>()
        for (article in current) {
            for (link in fetchLinks(article)) {
                if (seen.add(link)) next.add(link)
            }
        }
        current = next
    }
    seen.forEach { println(it) }
}
```
```console
> ./mill HtmlScraper.kt singapore 1
Hokkien
Conscription_in_Singapore
Malaysia_Agreement
Government_of_Singapore
...
```

And here is a xref:mill::scalalib/script.adoc#_html_web_scraper[Scala version of the HtmlScraper]:

```scala
//| mvnDeps:
//| - org.jsoup:jsoup:1.7.2
import org.jsoup._
import scala.collection.JavaConverters._

def fetchLinks(title: String): Seq[String] = {
  Jsoup.connect(s"https://en.wikipedia.org/wiki/$title")
    .header("User-Agent", "My Scraper")
    .get().select("main p a").asScala.toSeq.map(_.attr("href"))
    .collect { case s"/wiki/$rest" => rest }
}

@main
def main(startArticle: String, depth: Int) = {
  var seen = Set(startArticle)
  var current = Set(startArticle)
  for (i <- Range(0, depth)) {
    current = current.flatMap(fetchLinks(_)).filter(!seen.contains(_))
    seen = seen ++ current
  }

  pprint.log(seen, height = Int.MaxValue)
}
```
```console
> ./mill HtmlScraper.scala --start-article singapore --depth 1
  "Hokkien",
  "Conscription_in_Singapore",
  "Malaysia_Agreement",
  "Government_of_Singapore",
...
```

Like the xref:#_declarative_mill_builds[declarative mill builds] discussed above, single-file
scripts support the full range of build-tool functionality:
they can have test suites, be
xref:mill::javalib/script.adoc#_packaging_assemblies_and_native_binaries[packaged into assemblies or native binaries],
and can integrate easily into larger projects via
xref:mill::javalib/script.adoc#_custom_script_module_classes[custom script module classes] or
xref:mill::javalib/script.adoc#_project_moduledeps[project module deps]

Traditionally JVM languages and build tools were always somewhat troublesome to set up, and
so scripts and other small programs written in other languages like Python, Bash, or Javascript.
But with Mill's new single-file script support, we hope that running a Java, Scala, or Kotlin
script from the command-line is as easy as running a script or executable written in any other
language.

== Conclusion

While developers may differ in what their preferred JVM language is, we think that all three
major JVM languages are criminally under-utilized when it comes to writing scripts and small
programs. Java, Scala, and Kotlin are all great languages, with high-quality standard libraries,
rich ecosystems of third-party libraries, and a rock-solid JVM runtime. However, due to tooling
complexity, JVM languages have never been the preferred choice for small programs the same way
they are often used for large-scale enterprise systems.

With the new declarative and single-file configuration styles in Mill 1.1.0, we hope to be
able to change that.

Mill's `build.mill.yaml` configuration syntax offers a declarative syntax
that takes the best ideas from Maven, while streamlining installation, syntax, and command-line
usage. Mill's single-file scripts take that a step further allowing any `.java`, `.scala`, or
`.kt` file to be annotated and run without needing to set up a separate "project"
or "build file". And rather than having to juggle a zoo of different tools for different purposes -
https://www.jbang.dev/[JBang], https://www.jenv.be/[JEnv], https://sdkman.io/[SdkMan],
https://maven.apache.org/[Maven], and https://gradle.org/[Gradle] - Mill provides everything you
need in one xref:16-zero-setup.adoc[zero-setup bootstrap script] that is trivial to use anywhere
you want to run your code.

If you have made it this far, we hope that some of the problems and challenges we have discussed
in this article resonate with your own personal experience. If you are interested in trying out
Mill's new declarative configuration syntax or single-file scripts, please check out the
documentation linked below:

- xref:mill::javalib/intro.adoc#_declarative_module_config[Declarative Java Module Configuration]
- xref:mill::javalib/intro.adoc#_single_file_scripts[Java Single-File Scripts]

== Foot Notes

The Maven `pom.xml` necessary for building `HtmlScraper.java`
```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <modelVersion>4.0.0</modelVersion>
  <groupId>example</groupId>
  <artifactId>html-scraper</artifactId>
  <version>1.0</version>
  <dependencies>
    <dependency>
      <groupId>org.jsoup</groupId>
      <artifactId>jsoup</artifactId>
      <version>1.17.2</version>
    </dependency>
  </dependencies>
  <build>
    <plugins>
      <plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>exec-maven-plugin</artifactId>
        <version>3.2.0</version>
        <configuration>
          <mainClass>HtmlScraper</mainClass>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
```

The Maven command-line invocation necessary for running `HtmlScraper.java`

```console
> mvn exec:java -Dexec.args="Java 1"
Ptolemy
Bali
Greater_Sunda_Islands
Rama
Sulaiman_al-Tajir
Endemism
Gajah_Mada
Yingya_Shenglan
Mahabharata
Cirebon
Ethnic_groups_in_Indonesia
...
```