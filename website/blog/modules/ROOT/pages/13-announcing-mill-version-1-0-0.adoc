= v1.0.0 of the Mill Build Tool is out!

:link-github: https://github.com/com-lihaoyi/mill
:link-pr: {link-github}/pull

// tag::header[]
:author: Li Haoyi
:revdate: ???

_{author}, {revdate}_

{mill-doc-url}[Mill] is a JVM build tool that targets Java/Scala/Kotlin, and aims to
xref:mill::comparisons/why-mill.adoc[improve upon existing build tools like Maven, Gradle, or SBT].
https://github.com/com-lihaoyi/mill/blob/main/changelog.adoc#100[Mill 1.0.0] is
a major breaking release of the Mill project focused on setting a solid technical
foundation for the next several years of development, and this article explores some
highlights of the Mill 1.0.0 release.

// end::header[]

== Feature Highlights

=== Graal Native Launchers by default

Mill 1.0.0 defaults to using a https://www.graalvm.org/latest/reference-manual/native-image/[Graal-Native Image]
launchers by default. This shaves ~100ms off Mill command line invocations, meaning running `./mill`
commands in the terminal can often complete in as little as 100 millisecond:

```bash
$ time ./mill version
./mill version  0.01s user 0.02s system 29% cpu 0.102 total
```

Slow startups and long warmup times have always been a pain point working in the
JVM ecosystem, and this also applies to JVM command-line tooling as well. Mill has
always used axref:mill::depth/process-architecture.adoc[long-lived background daemon] to
try and mitigate the problem, but even if the heavyweight background daemon is long-lived,
the lightweight launcher/client process still adds a substantial overhead. With
Mill's Graal Native Image launcher, Mill's command-line experience feels as snappy
as any native binaries, because it is one!

=== JVM-free installation and bootstrapping

One consequence of using xref:#_graal_native_launchers_by_default[] is that Mill's launcher
no longer needs a JVM pre-installed in order to run. The launcher binary is self-contained,
and is able to bootstrap any JVM it needs in order to start up the background daemon or any
other Java processes.

```bash
$ echo temurin:23 > .mill-jvm-version

$ ./mill foo.test
https://github.com/adoptium/temurin23-binaries/releases/download/jdk-23.0.2%2B7/OpenJDK23U-jdk_aarch64_mac_hotspot_23.0.2_7.tar.gz
  100.0% [##########] 197.6 MiB (11.1 MiB / s)
[build.mill-60/65] compile
[build.mill-60] [info] compiling 3 Scala sources to /Users/lihaoyi/test/mill-dist-1.0.0-RC2-68-43069c-example-javalib-basic-1-simple/out/mill-build/compile.dest/classes ...
[build.mill-60] [info] done compiling
[81/95] foo.compile
[81] [info] compiling 1 Java source...
```

This means that Mill is able to manage your JVM installations on your behalf, without needing
to install external tools like https://github.com/jenv/jenv[JEnv] or https://sdkman.io/[SDKMan],
or having to first install package managers like https://brew.sh/[Homebrew]. By using
Mill's xref:mill::cli/installation-ide.adoc#_bootstrap_scripts[`./mill` bootstrap script]
(an idea borrowed from Gradle's `./gradle` and Maven's `./mvnw`) you can run `./mill` on any
clean Mac, Linux, or Windows or development machine or CI worker and have it bootstrap everything
necessary with zero installation up front.

=== Bash/Zsh tab-completion

Mill 1.0.0 comes with built-in support for Bash and Zsh tab-completion. This can be installed via

```bash
$ ./mill mill.tabcomplete/install
```

Once set up, you can then use `<TAB>` to auto-complete Mill modules and tasks from the command-line:

```bash
$ ./mill f<TAB>
$ ./mill foo

$ ./mill foo.run<TAB>
foo.run                foo.runClasspath       foo.runMain            foo.runMainLocal       foo.runUseArgsFile
foo.runBackground      foo.runLocal           foo.runMainBackground  foo.runMvnDeps
```

While this is not rocket science, we expect that this will be a significant quality-of-life
improvement to everyone using Mill. Nobody memorizes the names of every module and task within
a large build, and using `./mill resolve` to try and list things or opening your IDE to rely
on in-code autocomplete can be tedious and annoying. Mill's Bash/Zsh tab-completion relies on
the same underlying infrastructure that powers `./mill resolve` and other existing functionality,
but integrates it nicely into your shell so you have everything you need right at your fingertips
at all times

=== Task Filesystem Sandboxing

Like Gradle, Mill build files contain arbitrary code. And like Gradle, writing arbitrary
JVM code means you have a chance to make a mess of your Mill build files. For example,
although Mill relies on the assumption that tasks would only write to their destination
folder (available as `Task.dest` within any task body), and that module initialization
did not write to the filesystem, there was never enforcement of these expectations:


```scala
object foo extends Module{
  def bannedWriteTask = Task {
    os.write(BuildCtx.workspaceRoot / "banned-path", "hello")  // bad!
  }

  os.write(moduleDir / "banned-write.txt", "hello") // bad!
}
```

This meant it was possible to write code that violated Mill's internal expectations,
which could cause all sorts of things to go wrong. And onboarding new developers to use
Mill often resulted in a long process to teach them these conventions since the tool
itself would not give any feedback.

In Mill 1.0.0, most common filesystem read/write APIs have been instrumented to check
that they are not misused. That means code that violates Mill's conventions raises an
immediate error:

```bash
$ ./mill foo.bannedWriteTask
error: ...Writing to banned-path not allowed during execution of `foo.bannedWriteTask`
```

These sandboxes are not intended to be fully hermetic: there are escape hatches
(e.g. `BuildCtx.withFilesystemCheckerDisabled{ ... }`), not all APIs are instrumented
(e.g. direct use of `java.io.`/`java.nio`), and they are not intended to be a security
boundary against malicious code. Rather, they are meant to be simple guardrails to nudge
developers in the right direction to follow Mill's conventions and coding style, so
that everyone finds it easy to configure Mill the "right" way that leads to the fewest
surprises.

=== YAML Build Headers

Mill now supports a build header comment syntax for build that needs to be processed
before the main `build.mill` file is compiled and evaluated, and
contains configuration like the `mill-version`, `mill-jvm-version`, the `build.mill` file's `mvnDeps`
(separate from your application code's `mvnDeps`!) in a singl `//|`-prefixed comment block.
This is reminiscent of https://jekyllrb.com/docs/front-matter/[Jekyll FrontMatter] or Python's
https://peps.python.org/pep-0723/[PEP723 Inline script metadata]. Mill's build header:

_build.mill_
```scala
//| mill-version: 1.0.0
//| mill-jvm-version: 17
//| repositories: [$PWD_URI/custom-repo]
//| mvnDeps:
//| - com.grack:nanojson:1.8-custom-test
//| - com.lihaoyi::scalatags:0.12.0

package build
...
```

Previously, Mill had a wide variety of ways these things were configured:

- A `.mill-version` file to configure your Mill version
- A `.mill-jvm-version` file to configure the JVM used to run the Mill process
- `.config/mill-version` and `.config/mill-jvm-version` flavors of these config files
- `import $ivy` for configuring dependencies for your `build.mill`
- `import $repo` for configuring maven repositories used to resolve dependencies for compiling your `build.mill`

With Mill's YAML build headers, we can consolidate this zoo of different configuration
styles into a single compact block at the top of every `build.mill`. While the older
configuration styles continue to be supported for migration-compatibility, using
Mill's build headers is the recommended approach for configuring these values going forward.

Lastly, build headers are expected to be future-proof this "pre-build.mill" configuration
and allow all sorts of interesting use cases in future. For example, we can extend this
format to support running self-contained Java/Scala/Kotlin scripts that contain both their
dependency configuration and code, similar to
https://docs.astral.sh/uv/guides/scripts/#running-a-script-without-dependencies[uv scripts]
in Python.

=== Android build support

A huge amount of work went into improving Mill's support for Android builds. Android
apps have traditionally only been buildable using Gradle, and Mill is one of the only
other build tools that you can use as an alternative. While
in 0.12.x Android support was a demo-quality example build, in 1.0.0 it has been
fleshed out into a robust and complete framework for building android apps.

For example, Mill is now able to build, run, and test the https://github.com/android/compose-samples/tree/main/JetLagged[JetLagged Android Example App]:

image:blog::AndroidJetLagged.png[]

As well as the https://android.googlesource.com/platform/ndk/+/froyo-release/samples/san-angeles[San Angeles NDK example]:

image:blog::AndroidSanAngeles.png[]

This work was done by https://www.vaslabs.io/[VasLabs], who put in an immense amount
of work improving the support.

* ({link-pr}/4485[#4485], {link-pr}/4540[#4540], {link-pr}/4583[#4583],
{link-pr}/4626[#4626], {link-pr}/4759[#4759], {link-pr}/4892[#4892], {link-pr}/4947[#4947],
{link-pr}/5013[#5013], {link-pr}/5053[#5053])


Updating the xref:mill::android/java.adoc[Mill Android documentation for Java] and
the xref:mill::android/java.adoc[Mill Android documentation for Kotlin] is a work in
progress, but if you are unsatisfied with Gradle and interested in trying out an
alternate Android build tool, you should definitely take a look and try it out. We
will be fleshing out the Mill Android docs over the following weeks and months and
writing up blog posts on our experience integrating Mill with the Android toolchain

== Quality Highlights

Apart from concrete features, a lot of work in the Mill 1.0.0 series went into quality.
These are areas where

=== IDE Support

Mill has always had a best-in-class IDE experience, with the ability to get autocompletion
and code-navigation within your build files that far surpasses anything you can do in
Maven, Gradle, or SBT. But even so, there was a ton of room for improvement.


Many PRs went into improving Mill's IDE support with IntelliJ and VSCode, which
goes through the "BSP" https://github.com/build-server-protocol/build-server-protocol[build-server-protocol]:

- {link-pr}/5275[#5275], {link-pr}/5265[#5265],
{link-pr}/5220[#5220], {link-pr}/5202[#5202], {link-pr}/5200[#5200])

- {link-pr}/4851[#4851],{link-pr}/4873[#4873],
{link-pr}/4876[#4876], {link-pr}/4881[#4881], {link-pr}/4873[#4873],
{link-pr}/4940[#4940], {link-pr}/4941[#4941]

There were also some fixes on the IDE side on IntelliJ:

- https://youtrack.jetbrains.com/issue/SCL-23262/Mill-import-highlighting-error[SCL-23262 Mill import highlighting error]
- https://youtrack.jetbrains.com/issue/SCL-23198/Direct-references-to-package-objects-should-be-allowed-in-.mill-files[SCL-23198 Direct references to package objects should be allowed in `.mill` files]
- https://youtrack.jetbrains.com/issue/SCL-23961/Mill-projects-sometimes-get-into-bad-state-during-importing[SCL-23961 Mill projects sometimes get into bad state during importing]
- https://youtrack.jetbrains.com/issue/SCL-23975/Stop-Mill-BSP-import-progress-indicator-from-blocking-usage-of-iDE[SCL-23976 Stop Mill BSP import progress indicator from blocking usage of IDE]

and VSCode:

- https://github.com/scalameta/metals/issues/7149[#7149 Metals does not automatically setup the Mill BSP server]
- https://github.com/scalameta/metals/issues/7218[#7218 Support toe BSP "no-ide" build-target tag]

As Mill builds is able to leverage the existing IntelliJ/VSCode IDE infrastructure,
we did not need to implement support for the Mill build tool from scratch in its
own plugin. But nevertheless there was still a lot of work to properly wire up
Mill to talk to these IDEs and pass the necessary data so the IDEs can do their thing.

Improving IDE support is a slog: lots of fiddling with undocumented APIs and
undocumented behavior, with bugs randomly scattered across organizational boundaries
(some in Mill, some in IntelliJ, some in VSCode). But hopefully this work will provide
a smoother experience for anyone getting using Mill, and improve upon Mill's
ability to provide a best-in-class IDE experience for your build system.

=== Classpath Cleanup and Stabilization

Mill 1.0.0 runs with a much cleaner JVM classpath than Mill 0.12.x and below.
We expect that this will both speed up compiles, and also allow better long-term
backwards compatibility as the Mill project itself and user's Mill builds both evolve
over time.

- Mill 0.12.x compiled and ran your `build.mill` with the entire Mill assembly jar
  on the classpath. That meant that
  your `build.mill` could access all of Mill's internal code and dependencies,
  and versions of dependencies used by Mill are pinned and unchangeable
  (e.g. see https://github.com/com-lihaoyi/mill/issues/2985[#2985])

- Mill 1.0.0 compiles and runs your `build.mill` with only the code and
  dependencies that it actually requires on the classpath, with the rest of
  Mill's internal code and internal dependencies isolated via subprocess or
  classloader isolation. The only exception is the Scala standard library jar
  `scala-library` that continues to be fixed

While this may seem like an esoteric improvement, concretely it means two things:

- You are now much free-er to use or upgrade third-party dependencies
  in your `build.mill` via `//| mvnDeps`. They will not conflict with Mill's internal
  dependencies, and are not pinned to the versions that Mill uses

- Mill can evolve much more freely without worrying about breaking user code. All
  of Mill's internal code is now completely hidden from the user, so users don't
  need to worry about accidentally depending on some internal class or static method
  that may break in a newer version of Mill

== Upgrading to Mill 1.0.0