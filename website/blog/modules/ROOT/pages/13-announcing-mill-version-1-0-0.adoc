= v1.0.0 of the Mill Build Tool is out!

// tag::header[]
:author: Li Haoyi
:revdate: ???

_{author}, {revdate}_

{mill-doc-url}[Mill] is a JVM build tool that targets Java/Scala/Kotlin, and aims to
xref:mill::comparisons/why-mill.adoc[improve upon existing build tools like Maven, Gradle, or SBT].
https://github.com/com-lihaoyi/mill/blob/main/changelog.adoc#100[Mill 1.0.0] is
a major breaking release of the Mill project focused on setting a solid technical
foundation for the next several years of development, and this article explores some
highlights of the Mill 1.0.0 release.

// end::header[]

== Feature Highlights

=== Graal Native Launchers by default

Mill 1.0.0 defaults to using a https://www.graalvm.org/latest/reference-manual/native-image/[Graal-Native Image]
launchers by default. This shaves ~100ms off Mill command line invocations, meaning running `./mill`
commands in the terminal can often complete in as little as 100 millisecond:

```bash
$ time ./mill version
[1/1] version
1.0.0
[1/1] ============================== version ==============================
./mill version  0.01s user 0.02s system 29% cpu 0.102 total
```

Slow startups and long warmup times have always been a pain point working in the
JVM ecosystem, and this also applies to JVM command-line tooling as well. Mill has
always used axref:mill::depth/process-architecture.adoc[long-lived background daemon] to
try and mitigate the problem, but even if the heavyweight background daemon is long-lived,
the lightweight launcher/client process still adds a substantial overhead. With
Mill's Graal Native Image launcher, Mill's command-line experience feels as snappy
as any native binaries, because it is one!

=== JVM-free installation and bootstrapping

One consequence of using xref:#_graal_native_launchers_by_default[] is that Mill's launcher
no longer needs a JVM pre-installed in order to run. The launcher binary is self-contained,
and is able to bootstrap any JVM it needs in order to start up the background daemon or any
other Java processes.

```bash
$ echo temurin:23 > .mill-jvm-version

$ ./mill foo.test
https://github.com/adoptium/temurin23-binaries/releases/download/jdk-23.0.2%2B7/OpenJDK23U-jdk_aarch64_mac_hotspot_23.0.2_7.tar.gz
  100.0% [##########] 197.6 MiB (11.1 MiB / s)
[build.mill-60/65] compile
[build.mill-60] [info] compiling 3 Scala sources to /Users/lihaoyi/test/mill-dist-1.0.0-RC2-68-43069c-example-javalib-basic-1-simple/out/mill-build/compile.dest/classes ...
[build.mill-60] [info] done compiling
[81/95] foo.compile
[81] [info] compiling 1 Java source...
```

This means that Mill is able to manage your JVM installations on your behalf, without needing
to install external tools like https://github.com/jenv/jenv[JEnv] or https://sdkman.io/[SDKMan],
or having to first install package managers like https://brew.sh/[Homebrew]. By using
Mill's xref:mill::cli/installation-ide.adoc#_bootstrap_scripts[`./mill` bootstrap script]
(an idea borrowed from Gradle's `./gradle` and Maven's `./mvnw`) you can run `./mill` on any
clean Mac, Linux, or Windows or development machine or CI worker and have it bootstrap everything
necessary with zero installation up front.

=== Bash/Zsh tab-completion

Mill 1.0.0 comes with built-in support for Bash and Zsh tab-completion. This can be installed via

```bash
$ ./mill mill.tabcomplete/install
```

Once set up, you can then use `<TAB>` to auto-complete Mill modules and tasks from the command-line:

```bash
$ ./mill f<TAB>
$ ./mill foo

$ ./mill foo.run<TAB>
foo.run                foo.runClasspath       foo.runMain            foo.runMainLocal       foo.runUseArgsFile
foo.runBackground      foo.runLocal           foo.runMainBackground  foo.runMvnDeps
```

While this is not rocket science, we expect that this will be a significant quality-of-life
improvement to everyone using Mill. Nobody memorizes the names of every module and task within
a large build, and using `./mill resolve` to try and list things or opening your IDE to rely
on in-code autocomplete can be tedious and annoying. Mill's Bash/Zsh tab-completion relies on
the same underlying infrastructure that powers `./mill resolve` and other existing functionality,
but integrates it nicely into your shell so you have everything you need right at your fingertips
at all times

=== Task Filesystem Sandboxing

Like Gradle, Mill build files contain arbitrary code. And like Gradle, writing arbitrary
JVM code means you have a chance to make a mess of your Mill build files. For example,
although Mill relies on the assumption that tasks would only write to their destination
folder (available as `Task.dest` within any task body), and that module initialization
did not write to the filesystem, there was never enforcement of these expectations:


```scala
object foo extends Module{
  def bannedWriteTask = Task {
    os.write(BuildCtx.workspaceRoot / "banned-path", "hello")  // bad!
  }

  os.write(moduleDir / "banned-write.txt", "hello") // bad!
}
```

This meant it was possible to write code that violated Mill's internal expectations,
which could cause all sorts of things to go wrong. And onboarding new developers to use
Mill often resulted in a long process to teach them these conventions since the tool
itself would not give any feedback.

In Mill 1.0.0, most common filesystem read/write APIs have been instrumented to check
that they are not misused. That means code that violates Mill's conventions raises an
immediate error:

```bash
$ ./mill foo.bannedWriteTask
error: ...Writing to banned-path not allowed during execution of `foo.bannedWriteTask`
```

These sandboxes are not intended to be fully hermetic: there are escape hatches
(e.g. `BuildCtx.withFilesystemCheckerDisabled{ ... }`), not all APIs are instrumented
(e.g. direct use of `java.io.`/`java.nio`), and they are not intended to be a security
boundary against malicious code. Rather, they are meant to be simple guardrails to nudge
developers in the right direction to follow Mill's conventions and coding style, so
that everyone finds it easy to configure Mill the "right" way that leads to the fewest
surprises.

=== YAML Build Headers

Mill now supports a build header comment syntax for build that needs to be processed
before the main `build.mill` file is compiled and evaluated, and
contains configuration like the `mill-version`, `mill-jvm-version`, the `build.mill` file's `mvnDeps`
(separate from your application code's `mvnDeps`!) in a singl `//|`-prefixed comment block.
This is reminiscent of https://jekyllrb.com/docs/front-matter/[Jekyll FrontMatter] or Python's
https://peps.python.org/pep-0723/[PEP723 Inline script metadata]. Mill's build header:

_build.mill_
```scala
//| mill-version: 1.0.0
//| mill-jvm-version: 17
//| repositories: [$PWD_URI/custom-repo]
//| mvnDeps:
//| - com.grack:nanojson:1.8-custom-test
//| - com.lihaoyi::scalatags:0.12.0

package build
...
```

Previously, Mill had a wide variety of ways these things were configured:

- A `.mill-version` file to configure your Mill version
- A `.mill-jvm-version` file to configure the JVM used to run the Mill process
- `.config/mill-version` and `.config/mill-jvm-version` flavors of these config files
- `import $ivy` for configuring dependencies for your `build.mill`
- `import $repo` for configuring maven repositories used to resolve dependencies for compiling your `build.mill`

With Mill's YAML build headers, we can consolidate this zoo of different configuration
styles into a single compact block at the top of every `build.mill`. While the older
configuration styles continue to be supported for migration-compatibility, using
Mill's build headers is the recommended approach for configuring these values going forward.

Lastly, build headers are expected to be future-proof this "pre-build.mill" configuration
and allow all sorts of interesting use cases in future. For example, we can extend this
format to support running self-contained Java/Scala/Kotlin scripts that contain both their
dependency configuration and code, similar to
https://docs.astral.sh/uv/guides/scripts/#running-a-script-without-dependencies[uv scripts]
in Python.

=== Major improvements to Android build support

== Quality Highlights

== Upgrading to Mill 1.0.0