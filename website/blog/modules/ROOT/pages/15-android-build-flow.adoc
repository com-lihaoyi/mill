= How does Mill build Android apps?

// tag::header[]
:author: Vasilis Nicolaou
:revdate: 29 August 2025

_{author}, {revdate}_


Until recently, Gradle was the only realistic option for Android builds. Today, Mill - a fast, predictable build tool for Java, Scala, and Kotlin - can build Android applications end-to-end.

In less than a year, Mill went from minimal Android support to producing installable APKs for projects as complex as xref:mill::android/hilt-sample.adoc[the Android Architecture Samples] and https://github.com/vaslabs/Pokedex_Compose_Multi_Module/tree/testing-mill[multi-module apps] with xref:mill::android/java.adoc#_using_third_party_native_libraries[native code] and xref:mill::android/compose-samples.adoc[Jetpack Compose].
// end::header[]
Multi-module Pokedex sample app (https://github.com/NicosNicolaou16/Pokedex_Compose_Multi_Module[original], https://github.com/vaslabs/Pokedex_Compose_Multi_Module/tree/testing-mill[with mill])
image:AndroidPokedexMultimoduleExample.png[A multi-module Android app built with Mill, showing a list of Pokémon and details for each pokemon.]

Unlike Gradle, where build steps are buried inside plugins and DSL magic, Mill exposes each Android step as a task you can run, override, or extend.
Want to see the merged manifest? Run
[,console]
----
./mill app.androidMergedManifest
----

Curious what rules are passed to R8? Run
[,console]
----
./mill app.androidProguard
----

Because Mill’s Android support is built out of simple, object-oriented modules (AndroidModule, AndroidAppModule, etc.), the entire pipeline is transparent and hackable. If something doesn’t work, you don’t need to wait for a plugin update — you can open the task in your IDE, see the source, and tweak it yourself. This is the same design that let us implement end-to-end Android support in under a year, and it’s what makes Mill attractive if you value control and debuggability in your build.

This post is a walk through of the basic Android build flow in Mill: what it does, why it’s complex, and why Mill makes it easier to reason about.


== The Android build process

Building and running a mixed Java/Kotlin application can be as simple as:

.Standard JVM build pipeline
[graphviz]
....
digraph G {
  rankdir=TB
  node [shape=box width=0 height=0]

  "Sources" -> "Compile (Java/Kotlin)"
  "Compile (Java/Kotlin)" -> "Jar"
  "Jar" -> "Run"
}
....

Android adds a dozen more steps, each involving different tools and formats:

- Resource compilation (aapt2) for layouts, drawables, and strings
- Manifest merging (app + library manifests)
- Code shrinking and obfuscation (R8/Proguard)
- DEX bytecode conversion (d8/r8)
- APK packaging (resources + bytecode)
- App signing (debug or release keystores)
- Emulator deployment and test execution (ADB)


Each step is order-sensitive: resources must be compiled before classes, manifests merged before packaging, APKs signed before installation. With Gradle this is often hidden in a black box (evidently, as we tried reverse engineering a lot of Gradle's behaviour). Mill instead exposes each phase as a target you can call, inspect, or override.

=== The Mill Android Build Pipeline

.Standard Android build pipeline (without Hilt)
[graphviz]
....
digraph G {
rankdir=TB
node [shape=box width=0 height=0]

"Java/Kotlin Sources" -> "Compile (Java/Kotlin)"
"Resources (res/)" -> "Compile Resources (aapt2)"
"AndroidManifest.xml" -> "Manifest Merging"
"Manifest Merging" -> "Linked Resources"
"Compile Resources (aapt2)" -> "Linked Resources"
"Compile (Java/Kotlin)" -> "Compiled Classes"
"Linked Resources" -> "Package APK"
"Compiled Classes" -> "DEX (d8/r8)"
"DEX (d8/r8)" -> "Package APK"
"Package APK" -> "Code Shrinking (r8/Proguard)"
"Code Shrinking (r8/Proguard)" -> "Sign APK"
"Sign APK" -> "Install to Emulator"
"Install to Emulator" -> "Run/Test via ADB"
}
....


This flow considers plain apps without any dependencies. But real-world apps depend on libraries, which may have their own resources, manifests, and even native code. Android dependencies come with their own complexities:

- Instead of a simple jar file that can be added to the classpath, Android libraries are distributed as AAR files, which are zip files containing compiled classes, resources, manifests, native libraries, Proguard files and more.
- The AAR dependencies must be unpacked and each component processed separately in the appropriate step of the build pipeline.


.Standard Android build pipeline with dependencies (AARs)
[graphviz]
....
digraph G {
  rankdir=TB
  node [shape=box width=0 height=0 style=filled fillcolor=white]

  // --- App inputs
  "App Java/Kotlin Sources" -> "Compile (Java/Kotlin)"
  "App Resources (res/)" -> "Compile App Resources (aapt2)"
  "App AndroidManifest.xml" -> "Manifest Merging"
  "App Proguard rules" -> "Proguard rules"

  // --- Library inputs
  subgraph cluster_aar {
    label="Dependency (AARs)"
    rankdir=TB
    node [shape=box width=0 height=0 style=filled fillcolor=white]

    "AAR Files" -> "Unpack AARs"
    "Unpack AARs" -> "AAR classes.jar"
    "Unpack AARs" -> "AAR res/"
    "Unpack AARs" -> "AAR AndroidManifest.xml"
    "Unpack AARs" -> "AAR proguard.txt"
    "Unpack AARs" -> "AAR native .so (optional)"
  }

  // --- Resource/link phase
  "AAR res/" -> "Compile Lib Resources (aapt2)"
  "Compile App Resources (aapt2)" -> "Linked Resources"
  "Compile Lib Resources (aapt2)" -> "Linked Resources"
  "AAR AndroidManifest.xml" -> "Manifest Merging"
  "Manifest Merging" -> "Linked Resources"

  // --- Classes & DEX
  "Compile (Java/Kotlin)" -> "Compiled Classes"
  "AAR classes.jar" -> "Compile Classpath"
  "AAR classes.jar" -> "DEX (d8/r8)"
  "Compile Classpath" -> "Compile (Java/Kotlin)"
  "Linked Resources" -> "Package APK"
  "Compiled Classes" -> "DEX (d8/r8)"
  "DEX (d8/r8)" -> "Package APK"

  // --- Proguard / main-dex rules
  "AAR proguard.txt" -> "Proguard rules"
  "Linked Resources" -> "Proguard rules"
  "Proguard rules" -> "DEX (d8/r8)"

  // --- Native libs & META-INF (optional)
  "AAR native .so (optional)" -> "Package APK"

  // --- Final steps
  "Package APK" -> "Code Shrinking (r8/Proguard)"
  "Code Shrinking (r8/Proguard)" -> "Sign APK"
  "Sign APK" -> "Install to Emulator"
  "Install to Emulator" -> "Run/Test via ADB"
}
....

The diagram above still doesn’t tell the whole story! It shows a typical build flow for an everyday Android app, but there are more features to consider:

- Hilt/Dagger code generation (annotation processing)
- Jetpack Compose code generation (Kotlin compiler plugin)
- Instrumented tests (separate APK, own resources, manifests, dependencies)
- Native code (NDK builds, CMake integration)

We cover a lot of these architecture styles in various Android examples, based on xref:mill::android/java.adoc[Java], xref:mill::android/kotlin.adoc[Kotlin] and third party integration examples covering xref:mill::android/compose-samples.adoc[Android Compose], xref:mill::android/android-native-example.adoc[Android Native] and xref:mill::android/hilt-sample.adoc[Dependency Injection with Hilt].

Endless tunnel sample app
image:AndroidEndlessTunnelExample.png[An Android app built with Mill using native code, showing a 3D tunnel effect.]

== Try it out

Mill’s Android support is still young, but it already covers the full build pipeline: resource compilation, manifest merging, packaging, signing, running, and even testing on emulators.

What makes this different from other build tools is control: every build step is a visible Mill task, easy to run on its own, inspect, or override. That means you can debug problems faster, adapt the pipeline to your project’s needs, and extend it without fighting opaque built-in or plugin logic.

If you’re curious, the best way to appreciate this is to try it yourself:

Get the `architecture-samples` containing the Todo App.

[source,bash]
----
git clone git@github.com:android/architecture-samples.git
cd architecture-samples
----

Install mill

[source,bash]
----
curl -L https://repo1.maven.org/maven2/com/lihaoyi/mill-dist/1.0.4/mill-dist-1.0.4-mill.sh -o mill
chmod +x mill
echo "//| mill-version: 1.0.4-22-bcbf85" > build.mill
./mill version
----

Configure the mill build

[source,bash]
----
curl https://raw.githubusercontent.com/com-lihaoyi/mill/186ede23a7e8f2b8f4da80877ed5f316cece9477/example/thirdparty/androidtodo/build.mill >> build.mill
----

Start the emulator and run the app

[source,bash]
----
./mill show app.createAndroidVirtualDevice
./mill show app.startAndroidEmulator
./mill show app.androidInstall
./mill show app.androidRun --activity com.example.android.architecture.blueprints.todoapp.TodoActivity
----

Run the instrumented tests and watch the app being tested inside the emulator:

[source,bash]
----
./mill app.androidTest
----

The Android Todo App built with Mill
image:AndroidTodoExample.png[The Todo app built with Mill, showing a list of tasks and a button to add new tasks.]

You may also inspect xref:mill::android/android-initial-setup.adoc[the getting started docs] to find out more.

We’d love feedback from the Android community, whether it’s bug reports, feature requests, or success stories. If you’ve ever wished Android builds felt less like a black box, Mill is worth a look.
