= Simpler JVM Project Setup with Declarative Config in Mill 1.1.0
// tag::header[]
:author: Li Haoyi
:revdate: 24 Dec 2025

_{author}, {revdate}_

Java and other JVM languages are often used for large enterprise codebases, but the friction
of configuring their build tools means they are less often used for small programs or
scripts. The new release of the Mill build tool v1.1.0 contains two features that try to
improve upon this pain point, allowing your project's to be configured via a
compact `build.mill.yaml` file:

```yaml
extends: [mill.javalib.JavaModule]
mvnDeps:
- org.jsoup:jsoup:1.7.2
```

Or even together with the program code in a single-file with a `//|` build header comment:

.File `HtmlScraper.java`
```java
//| mvnDeps:
//| - org.jsoup:jsoup:1.7.2
import org.jsoup.Jsoup;
public class HtmlScraper {
  ...
}
```
```console
> ./mill HtmlScraper.java Singapore 1
Hokkien
Conscription_in_Singapore
Malaysia_Agreement
Government_of_Singapore
...
```


This blog post will dive into these two new features: how they work, why they are interesting,
and where they learn from or improve upon existing tools in the JVM ecosystem. Lastly, we will discuss how we hope
they will streamline the process of getting started with Java programs, making Java and other
JVM languages the best way to write small-scale programs and scripts.


// end::header[]

== The Challenge of Small Java Programs

To understand the pain points of running small Java programs, consider a developer
that has written a single-file Java program they want to run:


```java
// HtmlScraper.java
import org.jsoup.Jsoup;
import java.util.*;

public class HtmlScraper {
  static List<String> fetchLinks(String title) throws Exception {
    var url = "https://en.wikipedia.org/wiki/" + title;
    var doc = Jsoup.connect(url).header("User-Agent", "My Scraper").get();
    var links = new ArrayList<String>();
    for (var a : doc.select("main p a")) {
      var href = a.attr("href");
      if (href.startsWith("/wiki/")) links.add(href.substring(6));
    }
    return links;
  }

  public static void main(String[] args) throws Exception {
    if (args.length < 2) throw new Exception("HtmlScraper.java <start> <depth>");
    var seen = new HashSet<>(Set.of(args[0]));
    var current = new HashSet<>(Set.of(args[0]));
    for (int i = 0; i < Integer.parseInt(args[1]); i++) {
      var next = new HashSet<String>();
      for (String article : current) {
        for (String link : fetchLinks(article)) {
          if (seen.add(link)) next.add(link);
        }
      }
      current = next;
    }
    for (String s : seen) System.out.println(s);
  }
}
```

This is a simple program that uses the https://jsoup.org/[Jsoup] library to scrape
the links off of a Wikipedia article's HTML page, which it then uses to perform a breadth-first
traversal across the Wikipedia article graph. While a bit contrived, this code is representative
of many of the small programs that may be written in practice:

- A student project
- A one-off prototype
- A small command-line script

In all these cases, the program would have a small amount of code and a few third-party
dependencies. But with traditional build tools like https://maven.apache.org/[Maven], running
such code can be surprisingly involved:

1. Installing Java, which has https://news.ycombinator.com/item?id=46037261[a surprising number of intricacies]
2. Installing Maven
3. Writing out the `pom.xml` (can you write the POM for the above program without copy-paste cargo-culting from StackOverflow/Google/ChatGPT?)
4. Running the program using Maven (can you remember the command-line invocation without looking it up?)

None of these are _blockers_: after all we've been building and running Java programs for decades,
in my case since Java 4 in 2004 (pre-generics!). The necessary config is in the
xref:#_footnotes[footnotes], and I have no doubt most people would be able to get __something__
working on their machine. But for someone trying to write a small program that can build and run
reliably on their laptop, their colleagues' laptops, their CI machines and their production
environment, these things can end up being surprisingly tricky.

You could also run the program using the Mill build tool instead of Maven. Mill's
xref:mill::cli/installation-ide.adoc#_bootstrap_scripts[Bootstrap Scripts] manage
xref:16-zero-setup.adoc[both your Mill and your JVM installation] for you so you don't need
to install those things manually, and Mill's command-line invocation syntax
`./mill run <arg1> <arg2>` follows command-line conventions more closely than Maven's. But while
Mill `build.mill` files are a lot more concise than Maven ``pom.xml``s, the amount of irrelevant
things you have to do due to their programmable nature makes them still pretty involved:

```scala
// build.mill
package build
import mill.*, javalib.*
object `package` extends JavaModule {
  def moduleDeps = Seq(mvn"org.jsoup:jsoup:1.7.2")
}
```

``package`` declarations, ``import``s, ``object``s, ``def``s. These are all things that are
necessary when you _actually need to program your build_, but just get in
the way when a user just wants to run their small Java program with 1 third-party dependency.

In theory Java and the JVM is a great platform to write and run small programs: easy to learn,
widely used, and a rich standard library and ecosystem of high-quality third-party libraries.
But in practice this build-tool-setup friction means that people prefer to write their small
programs in Bash, Python, or Node.js rather than writing them in Java, Scala or Kotlin.


== Declarative vs Programmable Builds

The Mill build tool has traditionally had a
xref:mill::javalib/intro.adoc#_programmable_module_config[programmable config syntax],
similar to https://gradle.org/[Gradle]. This has made Mill a build tool traditionally
most suitable for advanced use cases, as someone
https://www.reddit.com/r/java/comments/1ea3zv4/comment/lekc0qf[wrote on Reddit]:

> I'm relative new Mill and it is the most pleasant built tool for complex builds.
> When your build starts to hurt because it does not fit into Maven well enough, the Mill
> is a build tool worth evaluating.

While there are benefits to programmable configuration, especially for advanced use cases where
you do have custom build logic that needs programming, it comes at a cost: programmable
configuration is inherently more complicated than declarative configuration. Many projects
do not need the custom build logic that programmable configurable allows, and in such cases
the added complexity is pure downside without benefit.

Thus, for simple Java projects the only suitable build tool was
Maven. Maven has its strength and weaknesses, but for simple
Java programs you really had no other option: simple projects work best with declarative
configuration, and Maven was the only declarative build tool in the JVM ecosystem.

Mill 1.1.0 tries to change that. Mill's declarative `build.mill.yaml` files aim to be a
viable alternative to Maven for small projects where declarative configuration is most
suitable, avoiding the need for Mill's complicated programmable configuration while fixing
a lot of the pain points that can make Maven inconvenient to use.
While Maven no doubt brought a lot of innovations to the JVM build tool landscape dominated
by Ant, Make, and Bash scripts, it still leaves many ways that we can improve upon it to
further streamline the process of building and running your Java programs.

== Declarative Mill Builds

The first step Mill 1.1.0 takes towards solving the friction of running small JVM programs is
a new declarative configuration format. That lets us turn the rather complicated programmable
`build.mill` above into a declarative `build.mill.yaml` file, such as that below:

```yaml
extends: [mill.javalib.JavaModule]
mvnDeps:
- org.jsoup:jsoup:1.7.2
```

Mill's declarative `build.mill.yaml` format is less flexible than the programmable `build.mill`
config files, doesn't support xref:mill::javalib/intro.adoc#_custom_build_logic[Custom Build Logic],
and only allows configuration of primitive types and basic collections. However, in exchange
the declarative configuration is much simpler: no need to worry about `package` declarations,
``import``s, `object` and `def` statements, etc. Like Maven, Mill follows the principle of
__convention over configuration__: we extend the `mill.javalib.JavaModule` class which comes
with a rich set of reasonable defaults, and we only need to  configure the things we want
to do differently.

The result of this is that `build.mill.yaml` files contain only the configuration you need,
and nothing else. Compared to the equivalent Maven `pom.xml`, `build.gradle`, or programmable
`build.mill` files, Mill's `build.mill.yaml` files are really lightweight. This makes them easy
to write, easy to read, and easy to maintain compared to other build tools.

NOTE: `build.mill.yaml` files are written in https://yaml.org/spec/1.2.2/[YAML 1.2], parsed
using the https://bitbucket.org/snakeyaml/snakeyaml-engine[SnakeYaml-Engine] library. This helps
mitigate many of the https://ruudvanasseldonk.com/2023/01/11/the-yaml-document-from-hell[issues
that YAML has traditionally faced], resolving issues such as the famous
https://www.bram.us/2022/01/11/yaml-the-norway-problem/[Norway Problem] or the mangling of
version numbers such as `1.10` to `1.1`. While YAML will always have edge cases, we expect
it will be relatively rare for users to hit YAML-related issues in their `build.mill.yaml` files.

=== Non-Trivial Declarative Builds

While Mill's declarative build files are simpler than its programmable config files, they are
by no means limited to toy projects: `build.mill.yaml` files support most of Mill's
configuration overrides. For example, here is a more verbose example from the documentation for
xref:mill::javalib/declarative.adoc[] that demonstrates many of the common configuration
keys a developer may want to set:

```yaml
extends: [mill.javalib.JavaModule]
mvnDeps:
- org.thymeleaf:thymeleaf:3.1.1.RELEASE
- org.slf4j:slf4j-nop:2.0.7

# Add a custom maven repository URL
repositories: [https://oss.sonatype.org/content/repositories/releases]

# Set an explicit main class
mainClass: foo.Foo2

# Pin a custom JVM version, Mill supports 11 and above
jvmId: temurin:11

# Add an additional source folder and resource folder, in addition to the default one
sources: [./src, ./custom-src]
resources: [./resources, ./custom-resources]

# Configure java compiler and runtime options and env vars
javacOptions: [-deprecation]
forkArgs: [-Dmy.custom.property=my-prop-value]
forkEnv: { MY_CUSTOM_ENV: my-env-value }
```

These keys are all documented in
{mill-doc-url}/api/latest/mill/javalib/JavaModule.html#mvnDeps-0[the API reference],
along with every other configuration key that is available.
Mill's declarative builds also support
xref:mill::javalib/declarative.adoc#_unit_integration_testing[test suites],
xref:mill::javalib/intro.adoc#_multi_module_projects[multi-module projects],
xref:mill::javalib/declarative.adoc#_packaging_publishing[packaging and publishing],
and other common build tool features. While declarative `build.mill.yaml` files are a lot
more compact than their equivalent in Maven `pom.xml` or programmable `build.mill`, they
are very much feature-complete enough to support most real-world use cases.

We hope Mill's new declarative `build.mill.yaml` syntax can be a
viable alternative to Maven for Java developers who prefer declarative builds, complementing
Mill's existing programmable `build.mill` syntax:

- For projects that just need basic key-value configuration, declarative `build.mill.yaml` config
  is a great fit to keep things simple

- For projects that need custom build logic, programmable `build.mill` files can provide the
  necessary flexibility to get what you need done

Mill makes it easy to use both styles in the same project, so each can be used in the part of
the project where is most suitable, and users can easily transition between the two styles
as necessary.

=== Integrating Programmable and Declarative Styles

Although Mill's declarative builds are inspired by Maven, and Mill's programmable builds
are inspired by Gradle, one thing unique about Mill is how well integrated the two approaches are:

* Declarative `build.mill.yaml` files can inter-operate with programmable `build.mill` files
  via xref:mill::javalib/declarative.adoc#_custom_module_traits[custom module traits] and
  xref:mill::javalib/declarative.adoc#_programmable_moduledeps[depending on programmable modules],
  so you can mix-and-match the two config styles depending on which is more appropriate for each module.

* Setting `mvnDeps`, `repositories`, `mainClass`, `jvmId`, etc. means the same thing in both
  styles. Although the syntax is different,
  both declarative and programmable config styles used the same config keys with the same meaning, and the same
  {mill-doc-url}/api/latest/mill.html[Mill API Reference] provides documentation for both.

* Underneath the programmable and declarative configuration styles, it's still the same Mill
  build tool. That means concepts like xref:mill::depth/parallelism.adoc[parallelism],
  xref:mill::depth/caching.adoc[caching], xref:mill::depth/sandboxing.adoc[sandboxing],
  command-line invocations like `./mill inspect`, etc. all work the same way regardless of
  which configuration style you are using.

Traditionally, you were locked into a declarative or programmable style when choosing between
Maven or Gradle. This made it a big, irreversible decision, and the root of many "holy wars". In
contrast, with Mill you can easily transition between declarative and programmable configuration
styles as appropriate, letting you pick whatever makes sense at the moment knowing that you can
easily incorporate the other style later as necessary.

=== Simplifying Java Project Setup with Mill

Mill's declarative configuration pushes the limits of how easily you can setup a
Java project:

1. Mill's xref:mill::cli/installation-ide.adoc#_bootstrap_scripts[Bootstrap Scripts]
   automatically xref:16-zero-setup.adoc[download and cache the right Mill and JVM versions],
   so your program is guaranteed to build the same way regardless of whose laptop, CI, or
   production machine it may be running on.

2. Mill's declarative `build.mill.yaml` files are boilerplate-free, which makes them much easier
   to write, read, or maintain without relying on copy-paste cargo-culting from
   StackOverflow/Google/ChatGPT

3. Mill's CLI syntax for running the code `./mill run <arg1> <arg2>` follows the conventions
   established by other CLIs so anyone picking up Mill can use it without the indirection of
   learning Maven's unusual command-line conventions

This solves the 4 frictions we xref:#_the_challenge_of_small_java_programs[mentioned earlier]
in this article, letting you set up a new JVM project easily with a tiny config file and
have it working across different environments and operating systems without needing to fiddle
with JVM or build tool installations.

Like the rest of Mill, its declarative configuration syntax works for
all 3 major JVM languages: xref:mill::javalib/declarative.adoc[Java],
xref:mill::scalalib/declarative.adoc[Scala], and xref:mill::kotlinlib/declarative.adoc[Kotlin].
So anyone using a JVM language, or even multiple JVM languages, can use it to simplify their
project setup and development workflows.

However, needing to set up a separate "build file" is still a point of friction, and Mill 1.1.0
has one more trick to further reduce the overhead of building and running a small Java program.

== Mill Single-File Scripts

Mill 1.1.0 supports a new xref:mill::javalib/intro.adoc#_single_file_scripts[single-file script]
format for Java, Scala, and Kotlin files. For example, this lets you take the `HtmlScraper.java`
file above, add a `//|` build-header comment with the `mvnDeps` configuration it needs, and
xref:mill::javalib/script.adoc#_html_web_scraper[run it directly self-contained within a single file]:

```java
//| mvnDeps:
//| - org.jsoup:jsoup:1.7.2
import org.jsoup.Jsoup;
import java.util.*;

public class HtmlScraper {
  static List<String> fetchLinks(String title) throws Exception {
    var url = "https://en.wikipedia.org/wiki/" + title;
    var doc = Jsoup.connect(url).header("User-Agent", "My Scraper").get();
    var links = new ArrayList<String>();
    for (var a : doc.select("main p a")) {
      var href = a.attr("href");
      if (href.startsWith("/wiki/")) links.add(href.substring(6));
    }
    return links;
  }

  public static void main(String[] args) throws Exception {
    if (args.length < 2) throw new Exception("HtmlScraper.java <start> <depth>");
    var seen = new HashSet<>(Set.of(args[0]));
    var current = new HashSet<>(Set.of(args[0]));
    for (int i = 0; i < Integer.parseInt(args[1]); i++) {
      var next = new HashSet<String>();
      for (String article : current) {
        for (String link : fetchLinks(article)) {
          if (seen.add(link)) next.add(link);
        }
      }
      current = next;
    }
    for (String s : seen) System.out.println(s);
  }
}
```

This can be run via

```console
> ./mill HtmlScraper.java Singapore 1
Hokkien
Conscription_in_Singapore
Malaysia_Agreement
Government_of_Singapore
...
```


Another neat example is xref:mill::javalib/script.adoc#_web_server[running a Spring-Boot
webserver, configured and implemented in a single file]:

```java
//| mvnDeps: [org.springframework.boot:spring-boot-starter-web:3.2.0]
package example;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.*;

@SpringBootApplication
@RestController
public class WebServer {
  public static void main(String[] args) throws Exception {
    SpringApplication.run(WebServer.class, args);
    Thread.sleep(Integer.MAX_VALUE);
  }

  @PostMapping("/reverse-string")
  public String reverseString(@RequestBody String body) {
    return new StringBuilder(body).reverse().toString();
  }
}
```

```console
> ./mill WebServer.java:runBackground

> curl -d 'helloworld' localhost:8080/reverse-string
dlrowolleh
```

Although superficially Mill single-file scripts look like running a Python or Bash script, under
the hood it actually goes through the full build tool process - dependency resolution, compilation,
and execution - with every step cached and parallelized where-ever possible. While single-file
scripts are handy for cute demos like the one above, Mill fleshes them out enough that they are
a viable way of writing code on the JVM.

=== Rich Scripting on the JVM

Mill single-file scripts are inspired by the https://www.jbang.dev/[JBang] project for Java,
https://ammonite.io/[Ammonite] and https://scala-cli.virtuslab.org/[Scala-CLI] for Scala,
and https://blog.jetbrains.com/kotlin/2024/11/state-of-kotlin-scripting-2024/[Scripting for Kotlin].
But Mill's single-file scripts are unique in how well they support the full set of build-tool
functionality and integrate with larger projects:

1. Mill scripts support the
{mill-doc-url}/api/latest/mill/javalib/JavaModule.html#mvnDeps-0[full range of configuration options]
available to any other Java module, where other JVM script runners tend to only support a subset

2. Mill scripts can have xref:mill::javalib/intro.adoc#_testing_scripts[test suites]
and xref:mill::javalib/script.adoc#_relative_and_absolute_script_moduledeps[depend on other scripts],
which other JVM script runners usually don't support

3. Mill scripts can be xref:mill::javalib/script.adoc#_packaging_assemblies_and_native_binaries[packaged into assemblies or native binaries]
for deployment

4. Mill scripts can integrate easily into larger projects via xref:mill::javalib/script.adoc#_custom_script_module_classes[custom script module classes] or
xref:mill::javalib/script.adoc#_project_moduledeps[project module deps], where other JVM script
runners tend to run standalone

5. Mill scripts have xref:mill::javalib/script.adoc#_script_ide_integration[full support in IDEs]
like IntelliJ or VSCode, where other JVM script runners often only have partial IDE support

image::ScriptIDESupport.png[]

Using Java to write small scripts isn't a new idea, with the ability to run `java Foo.java`
from the command line introduced in Java 11, and more feature-rich tools like JBang. But Mill
takes the idea several step further in polish and robustness, hopefully to a level where
scripting on the JVM can be a truly viable workflow rather than just a tech demo.

=== Multi-Language JVM Scripting

Like the rest of Mill, single-file scripts support the three major JVM languages, and you can
run scripts written in xref:mill::javalib/script.adoc[Java], xref:mill::scalalib/script.adoc[Scala],
or xref:mill::kotlinlib/script.adoc[Kotlin]. For example, here is a
xref:mill::kotlinlib/script.adoc#_html_web_scraper[Kotlin version of the HtmlScraper]

```kotlin
//| mvnDeps:
//| - org.jsoup:jsoup:1.7.2
import org.jsoup.Jsoup

fun fetchLinks(title: String): List<String> {
    val url = "https://en.wikipedia.org/wiki/$title"
    val doc = Jsoup.connect(url).header("User-Agent", "My Scraper").get()

    return doc.select("main p a")
        .mapNotNull { a ->
            val href = a.attr("href")
            if (href.startsWith("/wiki/")) href.removePrefix("/wiki/")
            else null
        }
}

fun main(args: Array<String>) {
    if (args.size < 2) throw Exception("HtmlScraper.kt <start> <depth>")
    var seen = mutableSetOf(args[0])
    var current = mutableSetOf(args[0])

    repeat(args[1].toInt()) {
        val next = mutableSetOf<String>()
        for (article in current) {
            for (link in fetchLinks(article)) {
                if (seen.add(link)) next.add(link)
            }
        }
        current = next
    }
    seen.forEach { println(it) }
}
```
```console
> ./mill HtmlScraper.kt singapore 1
Hokkien
Conscription_in_Singapore
Malaysia_Agreement
Government_of_Singapore
...
```

And here is a xref:mill::scalalib/script.adoc#_html_web_scraper[Scala version of the HtmlScraper]:

```scala
//| mvnDeps:
//| - org.jsoup:jsoup:1.7.2
import org.jsoup._
import scala.collection.JavaConverters._

def fetchLinks(title: String): Seq[String] = {
  Jsoup.connect(s"https://en.wikipedia.org/wiki/$title")
    .header("User-Agent", "My Scraper")
    .get().select("main p a").asScala.toSeq.map(_.attr("href"))
    .collect { case s"/wiki/$rest" => rest }
}

@main
def main(startArticle: String, depth: Int) = {
  var seen = Set(startArticle)
  var current = Set(startArticle)
  for (i <- Range(0, depth)) {
    current = current.flatMap(fetchLinks(_)).filter(!seen.contains(_))
    seen = seen ++ current
  }

  pprint.log(seen, height = Int.MaxValue)
}
```
```console
> ./mill HtmlScraper.scala --start-article singapore --depth 1
  "Hokkien",
  "Conscription_in_Singapore",
  "Malaysia_Agreement",
  "Government_of_Singapore",
...
```

Java is not the only JVM language, and languages like Kotlin or Scala complement it well by
offering a more concise experience that may be more suitable for scripts. So even if scripting
in Java may not suit you, scripting in Kotlin or Scala are definitely options you can consider
while still benefiting from the robust runtime and rich ecosystem of the JVM.

== Conclusion

While developers may differ in what their preferred JVM language is, we think that all three
major JVM languages are criminally under-utilized when it comes to writing scripts and small
programs. Java, Scala, and Kotlin are all great languages, with high-quality standard libraries,
rich ecosystems of third-party libraries, and a rock-solid JVM runtime. However, due to tooling
complexity, JVM languages have never been the preferred choice for small programs the same way
they are often used for large-scale enterprise systems.

With the new declarative and single-file configuration styles in Mill 1.1.0, we hope to be
able to change that. Mill's new declarative `build.mill.yaml` files
take the best ideas from Maven, while streamlining installation, syntax, and command-line
usage. Mill's single-file scripts take that a step further allowing any `.java`, `.scala`, or
`.kt` file to be annotated and run without needing to set up a separate "project"
or "build file".

Lastly, rather than having to juggle a zoo of different tools for different purposes -
https://www.jenv.be/[JEnv], https://sdkman.io/[SdkMan], https://maven.apache.org/[Maven],
https://gradle.org/[Gradle], https://www.jbang.dev/[JBang] - Mill provides everything you
need in one xref:16-zero-setup.adoc[zero-setup bootstrap script]. This makes it trivial to
for anyone using any JVM language to run your code conveniently and consistently.

If you have made it this far, we hope that some of the problems and challenges we have discussed
in this article resonate with your own personal experience. If you are interested in trying out
Mill's new declarative configuration syntax or single-file scripts, please check out the
documentation linked below:

- xref:mill::javalib/intro.adoc#_declarative_module_config[Declarative Java Module Configuration]
- xref:mill::javalib/intro.adoc#_single_file_scripts[Java Single-File Scripts]

For anyone upgrading from an earlier version of Mill, please see the changelog with a more
thorough listing of improvements and migration instructions:

- https://github.com/com-lihaoyi/mill/blob/main/changelog.adoc#110[Mill 1.1.0 Changelog]

== Footnotes

The Maven `pom.xml` necessary for building `HtmlScraper.java`
```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <modelVersion>4.0.0</modelVersion>
  <groupId>example</groupId>
  <artifactId>html-scraper</artifactId>
  <version>1.0</version>
  <dependencies>
    <dependency>
      <groupId>org.jsoup</groupId>
      <artifactId>jsoup</artifactId>
      <version>1.17.2</version>
    </dependency>
  </dependencies>
  <build>
    <plugins>
      <plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>exec-maven-plugin</artifactId>
        <version>3.2.0</version>
        <configuration>
          <mainClass>HtmlScraper</mainClass>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
```

The Maven command-line invocation necessary for running `HtmlScraper.java`

```console
> mvn exec:java -Dexec.args="Singapore 1"
Hokkien
Conscription_in_Singapore
Malaysia_Agreement
Government_of_Singapore
...
```