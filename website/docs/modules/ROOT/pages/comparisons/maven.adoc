= Comparing Mill vs Maven

xref:comparisons/maven.adoc[Maven] build tool is famous for pioneering the idea of
_"Declarative Builds"_: you should only need to specify what you want your project
to use, and the build tool should be able to get everything working on your behalf.
However, although that is an excellent ideal to strive towards, in practice
there remains a lot of room for improvement.

Mill learns from Maven's key ideas while improving on its rough edges, resulting in
a build tool much easier to use than Maven that came before it. This page discusses
some of the key ways that Mill both learns from Maven, and also how Mill tries to
improve upon some of its rough edges to provide a user experience that lets the
idea of _"Declarative Builds"_ really shine through.

== Where Maven's Declarative Builds Fall Short

Consider a small Java program such as the one below:

`HtmlScraper.java`

```java
import org.jsoup.Jsoup;
import java.util.*;

public class HtmlScraper {
  static List<String> fetchLinks(String title) throws Exception {
    var url = "https://en.wikipedia.org/wiki/" + title;
    var doc = Jsoup.connect(url).header("User-Agent", "My Scraper").get();
    var links = new ArrayList<String>();
    for (var a : doc.select("main p a")) {
      var href = a.attr("href");
      if (href.startsWith("/wiki/")) links.add(href.substring(6));
    }
    return links;
  }

  public static void main(String[] args) throws Exception {
    if (args.length < 2) throw new Exception("HtmlScraper.java <start> <depth>");
    var seen = new HashSet<>(Set.of(args[0]));
    var current = new HashSet<>(Set.of(args[0]));
    for (int i = 0; i < Integer.parseInt(args[1]); i++) {
      var next = new HashSet<String>();
      for (String article : current) {
        for (String link : fetchLinks(article)) {
          if (seen.add(link)) next.add(link);
        }
      }
      current = next;
    }
    for (String s : seen) System.out.println(s);
  }
}
```

This program is a single-file Java application that uses the https://jsoup.org/[Jsoup]
third-party library to scrape links from a wikipedia page, and then uses that in turn to
do a breadth-first search on the graph of Wikipedia articles and links. This is
representative of the many small programs that get written in practice:

- Students doing a homework assignment
- Developers trying to automate a common workflow
- Someone trying to reproduce and minimize a bug in a library so that it can be reported

This is a simple program that any computing student should be able to write without difficulty.
In theory, there should be no reason that developers do not write small automation scripts
and utilities in Java rather than Python or Bash, but in practice setting up your Java file
to actually be run proves quite a hurdle.

=== Installing Java

To run your Java program, you first might need to install Java. This may seem obvious and
straightforward, but in practice it can turn out to be surprisingly tricky.
Consider this discussion on https://news.ycombinator.com/item?id=46037261[Installing Java in 2025]:

> +1 sdkman! is awesome. I've been using sdkman! for a decade to manage Java installations. Doesn't seem to work on freebsd though, which I have to use freebsd's pkg instead.
>
> Avoid Oracle's builds unless you need them for compliance reasons
>
> If you are on Linux or mac, getting your sdk via your favorite package manager is fine for casual use. Just be aware that this might not necessarily work with all software projects you want to work on. If that matters to you, that's what sdkman is for.
>
> On macOS I wrote my own 9-line Zsh function that lists the JDKs available and sets JAVA_HOME.
>
> On Windows, the only sane way to install Java seems to be scoop.sh or chocolatey
>
> I just don't see the point in installing a version manager specifically for the JDK.
>
> I would say as well as using SDKMan, you should use Jenv shell plugin to easily manage your JDK versions across projects

Even among experienced developers, it is clear there is no clear consensus on how Java should be
installed: it varies between JDK distributions, between operating systems, and between different
users' personal preference.

Although a new Java developer might not need to understand the breadth
and depth of Java installation methods to get something working, there's a non-trivial number of
decisions that need to be made and a non-trivial number of ways things can go wrong. Maybe you
got things working on your Mac-OSX laptop, but can you ensure the project works when run on
your colleague's Windows-11 desktop machine, or your Linux backend servers?

=== Setting up your `pom.xml`

If our simple Java program had no third-party dependencies, then we could just run it
from the command-line via:

```console
> java HtmlScraper.java
```

However, the program _does_ use a third-party dependency - Jsoup - and so running it is no
longer so simple: we now need a build tool! The most common build tool in the Java ecosystem
is Maven, and so you may want to set up a Maven `pom.xml` for the project.

**At this point it's worth thinking: are you able to write out the `pom.xml` for this project
without copy-paste cargo-culting something from Stackoverflow or similar?**

In practice, nobody, even experienced developers, is able to write ``pom.xml``s by hand. They're
simply too verbose with too much irrelevant boilerplate that you don't actually care about. Here's
an example `pom.xml` for the above project:

`pom.xml`
```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <modelVersion>4.0.0</modelVersion>
  <groupId>example</groupId>
  <artifactId>html-scraper</artifactId>
  <version>1.0</version>
  <dependencies>
    <dependency>
      <groupId>org.jsoup</groupId>
      <artifactId>jsoup</artifactId>
      <version>1.17.2</version>
    </dependency>
  </dependencies>
  <build>
    <plugins>
      <plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>exec-maven-plugin</artifactId>
        <version>3.2.0</version>
        <configuration>
          <mainClass>HtmlScraper</mainClass>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
```

Although copy-pasting something from Stackoverflow (or from an existing project, from ChatGPT,
from Gemini, etc.) works in a pinch, the boilerplate does have longer term costs that may not be
immediately obvious:

- When you need to _update_ the `pom.xml` later, splicing together multiple copy-pasted blobs
of XML can be a lot more error-prone than copy-pasting things the first time

- Although modern AI assistants like ChatGPT or Gemini are able to modify the code on your behalf,
they sometimes make mistakes or hallucinate. Will you be able to catch these errors in the
reams of boilerplate?

- When the build tool is misbehaving because something is misconfigured, and your AI assistant
isn't able to diagnose the problem (maybe they're the one who made the mistake in the first place!),
would you be able to debug it and figure out how to fix things?

But let's assume we have our `pom.xml` written, we next need to install Maven to use it:

=== Installing Maven

Next we need to install Maven. From the https://maven.apache.org/install.html[Maven docs], there
are a bunch of different commands needed for different operating systems or Linux distributions.

```console
> brew install maven
> sdk install maven
> sudo port install maven
> sudo apt install maven
> sudo dnf install maven
> sudo yum install maven
> choco install maven
> scoop install maven
```

This itself isn't a huge problem, but even after installing Maven on your machine, there are
questions remaining:

1. Did we install the _right version_ of Maven? Not every project builds on every version of Maven,
and the same command above may install a different version of Maven on different operating system
versions. Figuring out what Maven version our project needs and figuring out the command-line
syntax to make our specific package manage install it can be a challenge

2. To solve the right-maven-version problem, many projects these days use
https://maven.apache.org/tools/wrapper/maven-wrapper-plugin/usage.html[./mvnw bootstrap scripts]
as a best practice. Should you be using that instead?

=== Running your Java program

Finally, now that we have our `HtmlScraper.java` written, `java` installed, our `pom.xml`
set up, and `mvn` (or `./mvnw`) installed, we need to run our Java application.

**Consider: can you remember the command to run this Java application from the command line?**

It's not

```console
> mvn run Java 1
```

Neither is it

```console
> mvn HtmlScraper.java Java 1
```

Or

```console
> mvn run HtmlScraper.java Java 1
```

Rather, the correct invocation is:

```console
> mvn exec:java -Dexec.args="Java 1"
Ptolemy
Bali
Greater_Sunda_Islands
Rama
Sulaiman_al-Tajir
Endemism
Gajah_Mada
Yingya_Shenglan
Mahabharata
Cirebon
Ethnic_groups_in_Indonesia
...
```

Maven experts should be able to write this out from memory without issues, but it
is surprisingly involved for someone who just wants to run a single `HtmlScraper.java`
file containing their code!

=== Whither Declarative Builds?

Although Maven is the first "declarative" build tool, in practice there's a lot of
friction in setting up and using it that gets in the way of the declarative experience.
From installing Java and Maven to setting up the verbose `pom.xml` and the unusual
command-line invocation syntax. None of this is rocket science, but it adds enough
friction to our `HtmlScraper.java` that people prefer to write their small programs
in Python, Javascript, or some other language.

This is not for any fault of Java _the language_: while Java is a bit more verbose
than Python or Bash, it is fine for writing this particular `HtmlScraper.java` program.
The problem is that Java _the platform_ makes it annoying to run the code you have
already written! That is why many people would prefer to only use Java in large projects
where all this infrastructure has already been set up an automated for you, and
for small programs and scripts people would prefer to use something else.

== Simpler Declarative Builds with Mill

Because all of the issues above are with Java's _tooling_ rather than the language itself,
the Mill build tool is able to streamline these things considerably.

=== Mill Bootstrap Scripts

Mill is primarily installed via a `./mill`
xref:cli/installation-ide.adoc#_bootstrap_scripts[bootstrap script], similar to
`./mvnw` or `./gradlew` scripts common with those build tools. But Mill's approach
has several advantages that may not be obvious at a glance:

1. `./mill` is the _standard way_ to install Mill. Any Mill project you check out should
   be runnable via `./mill` without needing to first figure out how the project expects
   you to set up your machine.

2. The `./mill` bootstrap script downloads and caches both Mill itself, _as well
   as the Java runtime needed to run your project_. In general, Mill projects do not
   need Java to be pre-installed at all!

Mill does not rely on a pre-installed Java runtime by default, and instead uses its own
default version or the version explicitly configured in your `build.mill.yaml` file via:

`build.mill.yaml`
```
mill-jvm-version: 24
```

You can easily try out different Java versions by changing the `mill-jvm-version` config key,
and any Mill project can set `mill-jvm-version` to specify what Java version to use and ensure
it is used regardless of where the project is being built.
Thus the `./mill` bootstrap script is able to fix both the challenges
xref:#_installing_java[Installing Java] as well as xref:#_installing_maven[Installing Maven]:
any Mill project you check out should be runnable using `./mill` without needing any
global installation.

=== Mill Build Configuration

Mill's `build.mill.yaml` xref:javalib/intro.adoc#_config_based_modules[declarative configuration
files] are much simpler than the Maven ``pom.xml``s you may be used to writing. For example, for
the `HtmlScraper.java` file shown above, the minimal configuration file looks like this:

`build.mill.yaml`
```yaml
extends: [mill.javalib.JavaModule]
mvnDeps:
- org.jsoup:jsoup:1.7.2
```

In this file, the `extends` clause tells us what class of modules this is (e.g.
`mill.javalib.JavaModule`, `mill.kotlinlib.KotlinModule`, `mill.scalalib.ScalaModule`),
and the other keys tell us which keys on that module we want to override (in this case `mvnDeps`).

Mill's `build.mill.yaml` file allows a lot of configuration options:
`mvnDeps`/`compileMvnDeps`/`runMvnDeps`, `repositiries`, `javacOptions`, linting and
testing and packaging and publishing configuration, etc. discussed under
xref:javalib/config.adoc[]. However, the  `build.mill.yaml` file only needs to contain
the keys the user needs to customize, which greatly simplifies the common case where
the user is mostly fine with the default configuration and avoids the complexity of
xref:#_setting_up_your_pom_xml[].

=== Running Java Programs with Mill

When the time comes to running your program, with Mill it is simply:

```console
> ./mill run Java 1
Ptolemy
Bali
Greater_Sunda_Islands
Rama
Sulaiman_al-Tajir
Endemism
Gajah_Mada
Yingya_Shenglan
Mahabharata
Cirebon
Ethnic_groups_in_Indonesia
...
```

This command-line syntax follows closely the syntax used in other runtimes
(e.g. `python foo.py <arg2> <arg2>`, `bash foo.sh <arg2> <arg2>`), and should hopefully
be immediately familiar to any programmer who begins using Mill.

=== Mill Scripts

Apart from Mill modules defined via a `build.mill.yaml`, Mill also allows you to write
single-file "scripts" with their build configuration defined in a build header comment. For
example, the `HtmlScraper.java` file above can be annotated with a `//|` build header comment
as shown below:

```java
//| mvnDeps:
//| - org.jsoup:jsoup:1.7.2
import org.jsoup.Jsoup;
import java.util.*;
public class HtmlScraper {
  static List<String> fetchLinks(String title) throws IOException {
    var url = "https://en.wikipedia.org/wiki/" + title;
    var doc = Jsoup.connect(url).header("User-Agent", "My Scraper").get();
    var links = new ArrayList<String>();
    for (var a : doc.select("main p a")) {
      var href = a.attr("href");
      if (href.startsWith("/wiki/")) links.add(href.substring(6));
    }
    return links;
  }
  public static void main(String[] args) throws Exception {
    if (args.length < 2) throw new Exception("HtmlScraper.java <start> <depth>");
    var seen = new HashSet<>(Set.of(args[0]));
    var current = new HashSet<>(Set.of(args[0]));
    for (int i = 0; i < Integer.parseInt(args[1]); i++) {
      var next = new HashSet<String>();
      for (String article : current) {
        for (String link : fetchLinks(article)) {
          if (seen.add(link)) next.add(link);
        }
      }
      current = next;
    }
    for (String s : seen) System.out.println(s);
  }
}
```

Mill single-file script modules can be run from the command line just like any Python or Bash
script, via:

```console
> ./mill HtmlScraper.java Java 1
Ptolemy
Bali
Greater_Sunda_Islands
Rama
Sulaiman_al-Tajir
Endemism
Gajah_Mada
Yingya_Shenglan
Mahabharata
Cirebon
Ethnic_groups_in_Indonesia
...
```

Mill scripts further simplifies the usage of Mill for small programs. Like Maven, Mill
single-file scripts are fully declarative, with any build configuration set in the `//|`
build header comment, and any downloading of dependencies or compilation of `.java` files
scheduled parallelized and cached automatically. But unlike Maven, Mill is able to streamline
the process of taking your `.java` file and running it, such that the underlying simplicity
of its declarative configuration really shines through in the user experience.

== Conclusion: Mill vs Maven

Maven invented the idea of __"declarative builds"__, which was a big step forward in
a build-tool landscape dominated by tools like https://www.gnu.org/software/bash/[Bash]
or https://ant.apache.org/[Ant]. However, despite being declarative, Maven still has a
lot of rough edges that make getting started with it and Java troublesome and error-prone:
from installing a Java runtime (the "right" way), to installing Maven (the "right" way),
to cargo-cult copy-pasting a `pom.xml` and associated commands to run your program from the
command-line.

Mill tries to learn from all the best-practices of Maven, but polishes the rough edges
to provide a much smoother experience working with declarative builds. From the
zero-setup installation process and declarative `mill-jvm-version` specification,
to the concise `build.mill.yaml` format and familiar command-line syntax, Mill let's
the key ideas of declarative shine through to provide an experience that is every bit
as smooth as running a Python or Bash script from the command line.
