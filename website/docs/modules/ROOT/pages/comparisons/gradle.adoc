= Mill vs Gradle

Gradle is a popular open source build tool in the Java and JVM ecosystem,
second only to Maven. Gradle's core API is built around programmable configuration
files written in Groovy or Kotlin. Mill also provides programmable configuration
in its `build.mill` syntax, but thanks to its xref:#_object_oriented_builds[object-oriented builds]
Mill is able to provide a much more familiar programming experience with much better
IDE support than Gradle has been able to do.

== Extending Mill

When you do need to extend it, Mill allows you to directly write code to configure your build,
and even download libraries from Maven Central.

Most build tools need plugins to do anything: if you want to _Foo_ you need a
_Foo plugin_, if you want to Bar you need a _Bar plugin_, for any possible _Foo_ or _Bar_. These could
be simple tasks - zipping up files, pre-rendering web templates, preparing static assets for
deployment - but even a task that would be trivial to implement in a few lines of code requires
you to Google for third-party plugins, dig through their Github to see which one is best
maintained, and hope for the best when you include it in your build. And while you could
write plugins yourself, doing so is usually non-trivial.

Mill is different. Although Mill does have plugins supporting common integrations (linked above),
for most simple things you can directly write code to achieve what you want, using the bundled
filesystem, subprocess, and dependency-management libraries. And even if you need third-party
libraries from Maven Central to do `xyz`, you can directly import the "`xyz`" library and use it
directly, without having to find a "xyz build plugin" wrapper.

=== Simple Custom Tasks

The following Mill build is a minimal Java module `foo`. It contains no custom configuration, and
so inherits all the defaults from `mill.javalib.JavaModule`: default source folder layout, default
assembly configuration, default compiler flags, and so on. This _convention over configuration_
is a philosophy that Mill inherited from Maven and other JVM build tools:

[source,scala]
----
package build
import mill.*, javalib.*

object foo extends JavaModule {
}
----

[source,console]
----
> mill compile
Compiling 1 Java source...
----

If you want to add a custom task, this is as simple as defining a method e.g.
`def lineCount = Task { ... }`. The body of `Task` performs the action we want, and
can depend on other tasks such as `allSourceFiles()` below:

[source,scala]
----
package build
import mill.*, javalib.*

object foo extends JavaModule {
  /** Total number of lines in module source files */
  def lineCount = Task {
    allSourceFiles().map(f => os.read.lines(f.path).size).sum
  }
}
----

Once we define a new task, we can immediately begin using it in our build.
`lineCount` is not used by any existing `JavaModule` tasks, but we can still
show its value via the Mill command line to evaluate it, or inspect its metadata:

[source,console]
----
> ./mill show foo.lineCount
17

> ./mill inspect foo.lineCount
foo.lineCount(build.mill:4)
    Total number of lines in module source files

Inputs:
    foo.allSourceFiles
----

Note that as `lineCount` is a `Task`, we get automatic caching, invalidation, and
parallelization: these are things that every `Task` gets for free, without the task
author to do anything. And although we wrote the `lineCount` logic in the main
`build.mill` file for this example, if it grows complex enough to get messy it is
easy to move it to your own xref:extending/writing-plugins.adoc[custom plugins]

=== Overriding Tasks

To wire up `lineCount` into our main `JavaModule` `compile`/`test`/`run` tasks,
one way is to take the line count value and write it to a JVM resource file
to be used at runtime. In Mill your JVM resources are just a method `def resources`,
so we can override it and make it depend on `lineCount`, in addition
to its prior value `super.resources()` (that references the `resources/` folder on disk):

[source,scala]
----
package build
import mill.*, javalib.*

object foo extends JavaModule {
  /** Total number of lines in module source files */
  def lineCount = Task {
    allSourceFiles().map(f => os.read.lines(f.path).size).sum
  }

  /** Generate resources using lineCount of sources */
  override def resources = Task {
    os.write(Task.dest / "line-count.txt", "" + lineCount())
    super.resources() ++ Seq(PathRef(Task.dest))
  }
}
----


Because our `def resources` overrides the existing `resources` method inherited from `JavaModule`,
the downstream tasks automatically now use the new override instead, similar to any Java
method overrides. That means if you call `mill foo.run`, it will automatically pick up the new
`resources` including the generated `line-count.txt` file and make it available to
the application code to use e.g. to print it out at runtime:

[source,console]
----
> mill foo.run
Line Count: 18
----

Next, we'll look at a more realistic example,
which includes usage of third-party libraries in the build.

=== Using Third-Party JVM Libraries in Tasks

Many build tasks require third-party libraries. One example is pre-rendering HTML pages
in the build so they can be served at runtime: if a page never changes, rendering it on every request is
wasteful, and even rendering it once on startup and then caching it
can impact your application startup time. Thus, you may want to move some HTML rendering to
build-time, but with traditional build tools such a move is sufficiently inconvenient and
complicated that people rarely do it. Other use cases may include custom linters, custom
deployment artifacts, custom debugging metadata, and so on.

With Mill, using third-party libraries in your build tasks is very easy. Mill does not
ship with a bundled HTML templating engine, but you can use the
xref:extending/import-mvn-plugins.adoc[//| mvnDeps] syntax to include one such as
https://www.thymeleaf.org/[Thymeleaf], which would immediately make the
Thymeleaf classes available for you to import and use in your build as below:

[source,scala]
----
//| mvnDeps: ["org.thymeleaf:thymeleaf:3.1.1.RELEASE"]
package build

import mill.*, javalib.*
import org.thymeleaf.TemplateEngine
import org.thymeleaf.context.Context

object foo extends JavaModule {
  /** Total number of lines in module source files */
  def lineCount = Task {
    allSourceFiles().map(f => os.read.lines(f.path).size).sum
  }

  def htmlSnippet = Task {
    var context = new Context()
    context.setVariable("heading", "Line Count is: " + lineCount())
    new TemplateEngine().process(
        "<h1 th:text=\"${heading}\"></h1>",
        context
    )
  }

  def resources = Task {
    os.write(Task.dest / "snippet.txt", htmlSnippet())
    super.resources() ++ Seq(PathRef(Task.dest))
  }
}
----

Once we have specified our `//| mvnDeps` in the build file YAML header, we can import
`TemplateEngine`, `Context`, and follow our `def lineCount` with a `def htmlSnippet` task
that uses Thymeleaf to render HTML. We get full IDE support for working with the
Thymeleaf Java API, the new `htmlSnippet` task is inspectable from the Mill command line
via `show`, and we wire it up into `def resources` so it can be inspected and used at
runtime by the application (in this case just printed out):

image::why-mill/ExtendingIDESupport.png[]

[source,console]
----
> mill show foo.htmlSnippet
"<h1>Line count is: 17</h1>"

> mill foo.compile
compiling 1 Java source...
...

> mill foo.run
generated snippet.txt resource: <h1>Line count is: 17</h1>
----

Rendering HTML using the Thymeleaf templating engine is not rocket science, but what is
interesting here is what we did _not_ need to do:

* We did _not_ need to find a Thymeleaf-Mill plugin in order to include Thymeleaf in our
build

* We did _not_ need to learn a special API or framework for authoring build plugins ourselves
to write a plugin to include Thymeleaf in our build

* We did _not_ need to add fragile shell scripts to augment our build logic and
implement the functionality we need.


Instead, we could simply import Thymeleaf as a Java library directly from Maven Central
and use it just like we would use it in any Java application, with IDE support,
typechecking, and all the necessary build tool features like automatic parallelism, caching,
and invalidation.

=== Mill vs Gradle Configuration as Code

It's worth contrasting the Mill config above with e.g. the equivalent Gradle configuration
for setting up a line-count resource file:

[,kotlin]
----
import java.io.File

tasks.register("generateLineCount") {
    val sourceDirs = listOf("src/main/java")
    val outputDir = layout.buildDirectory.dir("generated-resources")
    val outputFile = outputDir.get().file("line-count.txt")

    inputs.files(fileTree("src/main"))
    outputs.file(outputFile)

    doLast {
        var totalLines = 0

        sourceDirs.map(::file).filter { it.exists() }.forEach { srcDir ->
            srcDir.walkTopDown()
                .filter { it.isFile && it.extension in listOf("java") }
                .forEach { file ->
                    totalLines += file.readLines().size
                }
        }

        outputFile.asFile.writeText(totalLines.toString())
        println("Generated line-count.txt with $totalLines lines")
    }
}

tasks.named("processResources") {
    dependsOn("generateLineCount")
    from(layout.buildDirectory.dir("generated-resources"))
}
----

While the Gradle config is a bit more verbose than Mill's, that is not where the problem
lies. The problem lies in the fact that the Gradle "config as code" doesn't _actually_
look like the code you are writing day-to-day: although it is written in Kotlin,
things like `task.named`, `dependsOn`, `inputs.files` and `outputs.file`, `doLast`
(or should we use `doFirst`?) are not "normal" Kotlin. The stringly-typed `"generateLineCount"`,
`"generated-resources"`, `"processResources"`, values add to the potential for error.
The end result is that although you may know Kotlin as a compiled language with great
IDE support, you will likely be unfamiliar with Gradle's flavor of Kotlin, and your
IDE will likely not be as useful as you would like.

In fact, there is even a bug in the above Gradle config that will cause the build to
be non-deterministically slower sometimes, but not other times.
Can you spot it?

The difficulty of catching these issues e.g. during code review
illustrates how difficult it is to write "correct" Gradle config: if even the simplest
hello-world customization results in impossible-to-find bugs slowing things down, how many
bugs will there be in any more-complex real-world customization or plugin? It's no wonder
then than real-world builds using Gradle or other tools often end up being inexplicably
slow and flaky!
(Click the footnote to see the answer footnote:[The bug is `inputs.files` is depending on `src/main`, when it only really needs
`src/main/java`. That means that changes to `src/main/resources` or `src/main/templates`
will cause the task redundantly re-compute, making your build slower than necessary. If the bug was the other way -
rather than depending on too large a folder instead depending on too small a folder -
it would instead cause flakiness where `generateLineCount` would sometimes not run when it needs to.])

In contrast, Mill's `extends`, ``def``s, and `overrides`
behave exactly as you would expect any object-oriented program to work, so you already
know how Mill behaves even if you've never touched a Mill build before. And the fact
that Mill build config is so much easier to write means that you're much less likely
to have bugs causing slowness or flakiness, resulting in the improved performance
(discussed above) and not needing to regularly run `clean` as you often have to do with other
build tools.

'''

Most real projects require some kind of ad-hoc build tasks: you may be pre-processing static
assets for web deployment, embedding build metadata for runtime debugging, or generating
reports for security scanning. With most build tools, you often needed to pull
in some poorly-maintained plugin off of Github, write your own using a complicated plugin
framework, or even wrap your build tool in ad-hoc shell scripts. With most other build tools,
caching and parallelism are things that the build or plugin author needs to set up manually,
meaning everyone makes mistakes and your build system performance is never as good as it could be.

In contrast, Mill makes it easy it is to write concise type-checked code to perform ad-hoc tasks
to do whatever you need to do. You get full IDE support, automatic caching and
parallelism, and access to the huge JVM library ecosystem on Maven Central.
Rather than grabbing unmaintained plugins off of Github or augmenting your build
with fragile shell scripts, Mill allows your own custom logic to be implemented
in a way that is flexible, performant, and safe, such that anyone can configure their
build correctly and achieve maximum performance even without being a build tool expert.

== IDE Support

The last area that Mill does better than Maven, Gradle or SBT is providing a seamless IDE
experience. Working with Mill builds in IntelliJ or VSCode, you get the full power of
your IDE to autocomplete, peek at docs, browse signatures, and otherwise navigate
around your build system. Working with your Mill build, you get the same level of
IDE support as working within any Java, Scala, or Kotlin application codebase.

image:comparisons/IntellijOverrideAutocomplete.png[]

=== Limitations of Existing Build Tool IDE Integrations

While JVM application codebases universally have excellent IDE support, build tools are usually
not nearly as well-supported. For example, consider the snippet below where we are using Gradle to
configure the javac compiler options. The autocomplete and code-assist experience working
with these files is hit-or-miss. In the example below, we can see that IntelliJ is able to
identify that `compileArgs` exists and has the type `List<String>`:

image:comparisons/IntellijMockitoGradleCompileOptions.png[]

But if you try to jump to definition or find out anything else about it you hit a wall.
The IDE is able to bring you to the getter and setter, but it isn't able to tell you
_where the value is coming from_, _how it is computed_, or _where it is used_:

image:comparisons/IntellijMockitoGradleCompileOptions2.png[]

Often working with build configurations feels like hitting dead ends: if you don't have
`options.compilerArgs` memorized in your head, there is literally nothing you can do in
your IDE to figure out what it is or what it is used for. That leaves
you googling for answers, which can be a frustrating experience that distracts you from
the task at hand.

Although this example is using Gradle's un-typed Groovy syntax, the experience
using Gradle's typed Kotlin syntax is largely the same. The problem isn't unique
to Gradle, and isn't unique to IntelliJ: any IDE would have similar problems working
with this code. The problem is the build tool configuration itself, or rather the
style of code that most build tools require they be configured with.

=== Global Mutable Variables

The fundamental problem with build tools like Gradle is that the entire configuration system
is based around _global mutable variables_. The Groovy or Kotlin code you write does not
actually _perform the build_, but instead is just setting up some
global mutable data structure that is used to configure the _real_ build engine that
runs _later_. Thus when you explore the Gradle build in an IDE, the IDE can only explore the
configuration logic (the `getCompilerArgs` method above) and is unable to explore
the actual build logic (how `getCompilerArgs` _actually gets used in Gradle_). And
just because the global mutable variable is wrapped in a getter and setter
does not make it any less global or any less mutable!

The problem with IDEs not being able to understand code written with global mutable
variables is not new. If you wrote your application code primarily using global mutable
variables, your IDE would not be able to help you much there either! So nobody does that,
and instead applications are primarily built using classes and methods, but some how
no build tool follows the same style so they all have problems with IDEs not being able
to work with their global mutable variables effectively.

=== The Mill IDE Experience


In comparison, not only are Mill's `.mill` files statically typed, they are
built on top of _classes_ and _methods_ like any other JVM codebase. While IDEs struggle
with global variables, they are very good at navigating classes and methods!
For example IntelliJ is able to take your `def javacOptions` override and
find the original definitions that were overridden, and show you where they are defined:

image::comparisons/IntellijMockitoMillJavacOptionsParents.png[]

You can jump to any of the overridden ``def``s quickly and precisely:

image::comparisons/IntellijMockitoMillJavacOptionsDef.png[]

And because tasks in Mill are just normal methods, IntelliJ is
able to _find usages_, showing you where the task is used. Below, we can see the method
call in the `def compile` task, which uses `javacOptions()` along with a number of other tasks:

image::comparisons/IntellijMockitoMillCompile.png[]

From there, if you are curious about any of the other tasks used alongside `javacOptions`, it's
easy for you to pull up _their_ documentation, jump to _their_
definition, or find _their_ usages. For example we can pull up the docs of
`compileClasspath()` below, jump to _its_ implementation, and continue
interactively exploring your build logic from there:

image::comparisons/IntellijMockitoMillCompileClasspath.png[]

Unlike most other build tools, Mill build pipelines can be explored interactively in your
IDE. If you do not know what something does, it's documentation, definition, or usages is always
one click away in IntelliJ or VSCode. This isn't a new experience for Java developers, as it
is what you experience every day working in your application code! But Mill brings that same
polished experience to your build system - traditionally something that has been opaque
and hard to understand - and does so in a way that no other build tool does. And this is
possible because Mill builds avoid the global mutable variables common in other build
tools, in favor of configuring your build via classes and methods that are familiar to
both users and to IDEs.

== Object-Oriented Builds

Mill has a lot of improvements over build tools like Maven or Gradle, but it begs the
question: why can't other build tools improve performance, extensibility, IDE support
as well? It turns out that other tools _have_ been working on improving performance,
extensibility and IDE support - for decades in the case of Maven or Gradle - but Mill
does have secret sauce that makes providing this experience in Mill much easier than
providing it in any other build tool.

All build tools are complex, because the requirements of building any size-able real-world
project are complex. One big source of build tool complexity is that users need some way to
define templated, customizable graph-computations when setting up their build pipelines.

- *Computations* as you need to specify what each build step does
- *Graph* as the data structure necessary to order and parallelize steps in your build
- *Templated* as different modules in a build are often very similar, with similar pipelines
- *Customizable* as there are always some module, or group of modules, special in some way

For example, even a simplified three-module Java build pipeline may look like this:

[graphviz]
....
digraph G {
  rankdir=LR
  node [shape=box width=0 height=0 style=filled fillcolor=white]
  bgcolor=transparent
  newrank=true;
  subgraph cluster_0 {
    style=dashed
    node [shape=box width=0 height=0 style=filled fillcolor=white]
    label = "foo";
    "foo.sources"
    "foo.compile"
    "foo.mainClass"
    "foo.assembly"
    "foo.classPath"
  }
  subgraph cluster_1 {
    style=dashed
    node [shape=box width=0 height=0 style=filled fillcolor=white]
    label = "bar";
    "bar.sources"
    "bar.compile"
    "bar.mainClass"
    "bar.assembly"
    "bar.classPath"
  }
  subgraph cluster_2 {
    style=dashed
    node [shape=box width=0 height=0 style=filled fillcolor=white]
    label = "qux";
    "qux.sources"
    "qux.compile"
    "qux.mainClass"
    "qux.assembly"
    "qux.classPath"
  }
  "foo.sources" -> "foo.compile" -> "foo.classPath" -> "foo.assembly"
  "foo.mainClass" -> "foo.assembly"
  "foo.classPath" -> "bar.compile"   [constraint=false];

  "foo.classPath" -> "bar.classPath"
  "bar.mainClass" -> "bar.assembly"
  "bar.sources" -> "bar.compile" -> "bar.classPath" -> "bar.assembly"

  "bar.classPath" -> "qux.compile" [constraint=false];
  "bar.classPath" -> "qux.classPath"
  "qux.mainClass" -> "qux.assembly"
  "qux.sources" -> "qux.compile" -> "qux.classPath" -> "qux.assembly"
}
....

Apart from the various tasks doing different things, we also see multiple modules
with similar task layouts (`foo`, `bar` and `qux`), but with subtle customizations in
each module to wire them up
(e.g. `foo.classPath` having one upstream task but `bar.classPath` and `qux.classPath`
each having two). And this is one of the simplest possible builds: you can imagine that
with compiler and runtime flags, code-generation, dependency-downloading, different language
toolchains, these graphs can get complicated quickly. And any build tool will need some way
for the user to define these graphs and maintain them over time.

Most build tools provide ad-hoc config formats (Maven's XML) or programmable builder
APIs (e.g. Gradle's Groovy/Kotlin) to satisfy this need, but these ad-hoc formats
inevitably end up being unfamiliar and confusing to users (e.g. the Gradle code
xref:#_mill_vs_gradle_configuration_as_code[discussed above]). Many
tools try to hide complexity behind plugins, but that doesn't actually solve it: plugin
authors are human too, and can also make mistakes and cause bugs when publishing their plugins.
It doesn't matter whether the bugs are in your own build customization or in the plugins
you use if the end result is your build system becomes slow and flaky!


Fundamentally, defining an API for templated, customizable graph-computations is
non-trivial, so it is not surprising the APIs and to do so can get complicated. But Mill
has one big insight in how it can be done better:

=== Object-Oriented Build Pipelines

Mill has the same requirement of defining templated, customizable graph-computations, but
rather than inventing a bespoke programming, configuration and plugin model to do so, Mill
builds upon what everyone already knows: _Object-Oriented Programming_. It turns out that the
object-oriented programming every Java developer learned in school provides all the key
building blocks necessary to define templated, customizable graph-computations:

- *Methods* provide a way of defining discrete build steps that perform
some necessary action in your build

- The *Call Graph* between methods provides the build graph, where which method call
which other methods defines the incoming edges of that node in the graph

- *Classes* provide the templating, where you can define a set of methods calling each
other, and instantiate those call graphs more than once in different parts of your build

- *Overrides* and *Subclasses* provide customization: when a particular instance or
sub-class needs a different implementation of one-or-more build steps, you can
override the respective methods to customize the build call graph to your liking

Thus, when you see a Mill build configured as such, with an `object` extending a `class`:

[source,scala]
----
package build
import mill.*, javalib.*

object foo extends JavaModule {
}
----

This is not some special syntax, but is literally defining an object named `foo`
inheriting from the class `JavaModule`. Like any other inheritance, this picks up
the methods and method call graph of `JavaModule` (slightly simplified below)

[graphviz]
....
digraph G {
  rankdir=LR
  node [shape=box width=0 height=0 style=filled fillcolor=white]
  bgcolor=transparent
  newrank=true;
  subgraph cluster_0 {
    style=dashed
    node [shape=box width=0 height=0 style=filled fillcolor=white]
    label = "foo";

    "foo.sources" -> "foo.compile" -> "foo.classPath" -> "foo.assembly"
    "foo.resources" -> "foo.assembly"
  }
}
....

And when you add additional tasks by defining methods using `def`, or `override` tasks
and call `super`:

[source,scala]
----
package build
import mill.*, javalib.*

object foo extends JavaModule {
  /** Total number of lines in module source files */
  def lineCount = Task {
    allSourceFiles().map(f => os.read.lines(f.path).size).sum
  }

  /** Generate resources using lineCount of sources */
  override def resources = Task {
    os.write(Task.dest / "line-count.txt", "" + lineCount())
    super.resources() ++ Seq(PathRef(Task.dest))
  }
}
----

You as a Java programmer already know how these changes affect the build graph, by splicing
in the new method `foo.lineCount`, replacing `foo.resources` with a new method body, and
calling `foo.super.resources`:

[graphviz]
....
digraph G {
  rankdir=LR
  node [shape=box width=0 height=0 style=filled fillcolor=white]
  bgcolor=transparent
  newrank=true;
  subgraph cluster_0 {
    style=dashed
    node [shape=box width=0 height=0 style=filled fillcolor=white]
    label = "foo";

    "foo.sources" -> "foo.compile" -> "foo.classPath" -> "foo.assembly"
    "foo.super.resources" -> "foo.resources" -> "foo.assembly"  [color = darkgreen, penwidth=3]
    "foo.lineCount"  [color = darkgreen, penwidth=3]
    "foo.sources" -> "foo.lineCount" -> "foo.resources" [color = darkgreen, penwidth=3]
    "foo.resources" [color = darkgreen, penwidth=3]
  }
}
....

If you want to re-use your build pipeline customizations, it as simple as turning the
`object foo` into a `class MyJavaModule` (called a `trait MyJavaModule` in Mill's syntax), so it
can be inherited  by `object foo` and `object bar` to share the configuration:


[source,scala]
----
package build
import mill.*, javalib.*

object foo extends MyJavaModule
object bar extends MyJavaModule

trait MyJavaModule extends JavaModule {
  /** Total number of lines in module source files */
  def lineCount = Task {
    allSourceFiles().map(f => os.read.lines(f.path).size).sum
  }

  /** Generate resources using lineCount of sources */
  override def resources = Task {
    os.write(Task.dest / "line-count.txt", "" + lineCount())
    super.resources() ++ Seq(PathRef(Task.dest))
  }
}
----

[graphviz]
....
digraph G {
  rankdir=LR
  node [shape=box width=0 height=0 style=filled fillcolor=white]
  bgcolor=transparent
  newrank=true;
  subgraph cluster_1 {
    style=dashed
    node [shape=box width=0 height=0 style=filled fillcolor=white]
    color = darkgreen
    penwidth=3
    label = "bar";

    "bar.sources" -> "bar.compile" -> "bar.classPath" -> "bar.assembly"
    "bar.super.resources" -> "bar.resources" -> "bar.assembly"
    "bar.lineCount"
    "bar.sources" -> "bar.lineCount" -> "bar.resources"
    "bar.resources"
  }
  subgraph cluster_0 {
    style=dashed
    node [shape=box width=0 height=0 style=filled fillcolor=white]
    label = "foo";

    "foo.sources" -> "foo.compile" -> "foo.classPath" -> "foo.assembly"
    "foo.super.resources" -> "foo.resources" -> "foo.assembly"
    "foo.lineCount"
    "foo.sources" -> "foo.lineCount" -> "foo.resources"
    "foo.resources"
  }

}
....

If you want to further customize either of those modules, you can `override`
one or more of the inherited methods. And if you want to publish your customizations
for others to use in their own projects,
you can xref:extending/writing-plugins.adoc#_publishing[publish
MyJavaModule to Maven Central] for others to
xref:extending/import-mvn-plugins.adoc[import into their build].

Mill's usage of methods, classes, and overrides is also what powers the IDE support
discussed earlier on this page. IDEs like IntelliJ or VSCode are uniquely adept at
working with JVM codebases full of methods and classes, and so
they can help you navigate and understand your Mill build pipelines just as easily
as any application codebase. And the simplicity of this extension model is what
allows Mill developers to avoid making mistakes aroun caching or parallelism when setting
up their builds or publishing plugins, which ultimately is what gives Mill builds great
performance without ever needing to `clean`.


// = Case Study: Mill vs Gradle
// :page-aliases: Case_Study_Mill_vs_Gradle.adoc
//
// This page goes into the weeds comparing the Mill and Gradle build tools.
// For a higher-level comparison of Mill vs other tools, and why Mill is interesting,
// see the page xref:comparisons/why-mill.adoc[].
//
//
// Compared to Gradle, Mill tries to improve in the following ways:
//
// * **Performance**: Mill compiles the same project 3-4x faster than Gradle. Mill is generally
// much more aggressive at caching and parallelizing things than Gradle is, and tries hard to
// minimize the overhead the build tool adds on top of the build logic being executed
//
// * **Extensibility**: Mill makes customizing the build tool much easier than Gradle. When defining
// custom tasks, you do not need to worry about registering task dependencies, registering tasks,
// assigning output folders on disk, and so on. You just write your build step as a normal method
// `def` that calls other methods, and all that boilerplate work is done automatically for you.
//
// * **IDE Support**: Mill has better IDE support in tools like IntelliJ or VsCode than Gradle does.
// Whether using the Groovy syntax or the Kotlin syntax, _jump-to-definition_ in Gradle would frequently
// bring you to stub getter-setter methods or de-compiled classfiles (or both at the same time!). With
// Mill, IntelliJ is able to navigate around the build logic just as easil as any application codebase,
// making it easier to navigate, understand, and maintain your build configuration.
//
//
// This page compares using Mill to Gradle using the https://github.com/mockito/mockito[Mockito Testing Library]
// codebase as the example. Mockito is a medium sized codebase, 100,000 lines of Java split over 22
// subprojects. By porting it to Mill, this case study should give you
// an idea of how Mill compares to Gradle in more realistic, real-world projects.
//
// To do this, we have written a Mill `build.mill` file for the Mockito project. This can be used
// with Mill to build and test the various submodules of the Mockito project without needing to
// change any other files in the repository:
//
// - https://github.com/com-lihaoyi/mill/blob/main/example/thirdparty/mockito/build.mill[Mockito build.mill file]
//
// == Completeness
//
// The Mill build for Mockito is not 100% complete, but it covers most of the major parts of Mockito:
// compiling Java, running JUnit tests. For now, the Android, Kotlin, and OSGI tests are skipped,
// as support for xref:android/java.adoc[Building Android apps in Mill]
// and xref:kotlinlib/intro.adoc[Kotlin with Mill] is still experimental.
//
// The goal of this exercise is not to be 100% feature complete enough to replace the Gradle build
// today. It is instead meant to provide a realistic comparison of how using Mill in a realistic,
// real-world project compares to using Gradle.
//
// == Performance
//
// The Mill build for Mockito is generally snappier than the Gradle build. This applies to
// most workflows, but the difference matters most for workflows which are short-lived,
// where the difference in the fixed overhead of the build tool is most noticeable.
//
// For comparison purposes, I disabled the Gradle subprojects that we did not fully implement in Mill
// (`groovyTest`, `groovyInlineTest`, `kotlinTest`, `kotlinReleaseCoroutinesTest`, `android`,
// `osgi-test`, `java21-test`), and added the necessary flags to ensure caching/parallelism/etc. is
// configured similarly for both tools. This ensures the comparison is fair with both builds compiling the
// same code and running the same tests in the same way.
//
// For the benchmarks below, each provided number is the median wall time of three consecutive runs
// on my M1 Macbook Pro with Java 17 and Mill `0.12.9-native`. While ad-hoc, these benchmarks are
// enough to give you a flavor of how Mill's performance compares to Gradle:
//
// [cols="1,1,1,1"]
// |===
// | Benchmark | Gradle | Mill | Speedup
//
// | <<Sequential Clean Compile All>> | 17.6s | 5.86s | 3.0x
// | <<Parallel Clean Compile All>> | 12.3s | 3.75s | 3.3x
// | <<Clean Compile Single-Module>> | 4.41s | 1.30s | 3.4x
// | <<Incremental Compile Single-Module>> | 1.37s | 0.20s | 6.9x
// | <<No-Op Compile Single-Module>> | 0.94s | 0.11s | 8.5x
// |===
//
// The column on the right shows the speedups of how much faster Mill is compared to the
// equivalent Gradle workflow. In most cases,  Mill is 2-4x faster than Gradle. Below, we
// will go into more detail of each benchmark: how they were run, what they mean, and how
// we can explain the difference in performing the same task with the two different build tools.
//
// === Sequential Clean Compile All
//
// [source,console]
// ----
// $ ./gradlew clean; time ./gradlew classes testClasses --no-build-cache
// 17.6s
// 18.2s
// 17.4s
//
// $ ./mill clean; time ./mill -j 1 __.compile
// 6.19s
// 5.86s
// 5.28s
// ----
//
// This benchmark measures the time taken to sequentially compiled all the Java code in
// the Mockito code base. The goal of this benchmark is to try and measure the "clean compile
// everything" step, without the effects of parallelism that can be nondeterministic and vary
// wildly from machine to machine depending on the number of cores available.
//
// To limit our comparison to compiling Java code only, we avoid
// using `build` in favor of `classes` and `testClasses`: this skips running tests,
// lint, jar/docjar generation, and other steps that `build` performs to make it an apples-to-apples
// comparison. Furthermore, Gradle parallelizes the build by default and caches things globally
// under `~/.gradle/caches`, while Mill parallelizes by default but does not cache things globally.
// Again to make it a fair comparison, we use `--no-build-cache` in Gradle and set
// `org.gradle.parallel=false` in `gradle.properties`, and pass `-j 1` to limit Mill to a
// single thread.
//
// Here we see Mill being about ~3.3x faster than Gradle, to do the equivalent amount of work.
// As a point of reference, Java typically compiles at 10,000-50,000 lines per second on a
// single thread, and the Mockito codebase is ~100,000 lines of code, so we would expect compile
// to take 2-10 seconds without parallelism.
// The 5-6s taken by Mill seems about what you would expect for a codebase of this size,
// and the ~17s taken by Gradle is much more than what you would expect from simple Java compilation.
//
// It's actually not clear to me where the difference in execution time is coming from. Unlike
// the xref:comparisons/maven.adoc[Mill v.s. Maven comparison], Gradle's command line output
// doesn't show any obvious network requests or jar packing/unpacking/comparing going on. But
// Gradle's CLI output is also much less verbose than Maven's, so it's possible things are going
// on under the hood that I'm not aware of.
//
// === Parallel Clean Compile All
//
// [source,console]
// ----
// $ ./gradlew clean; time ./gradlew classes testClasses --no-build-cache
// 13.8s
// 12.3s
// 11.4s
//
// $ ./mill clean; time ./mill __.compile
// 3.75s
// 3.74s
// 3.86s
// ----
//
// This benchmark is identical to the <<Sequential Clean Compile All>> benchmark above, but enables
// parallelism: Gradle by default, Mill without `-j 1` to run on 10 cores (the number on my Macbook Pro).
//
// Neither Gradle nor Mill benefit hugely from parallelism: both show a moderate ~50% speedup,
// despite receiving 900% more CPUs. This likely indicates that the module dependency graph
// of the Mockito codebase is laid out in a way that does not allow huge amounts of compile-time
// parallelism.
//
// Again, we see Mill being about ~3.4x faster than Gradle, to do the equivalent amount of work.
// This indicates the the speedup Mill provides over Gradle is unrelated to the parallelism of
// each tool.
//
// === Clean Compile Single-Module
//
// [source,console]
// ----
// $ ./gradlew clean; time ./gradlew :classes --no-build-cache
// 4.14s
// 4.41s
// 4.41s
//
// $ ./mill clean; time ./mill compile
// 1.30s
// 1.90s
// 1.13s
// ----
//
// This benchmark indicates the use case of clean-compiling a single module. In this case,
// the root module in `src/main/java/` containing the bulk of the Mockito library code,
// _excluding_ the test code in `src/test/java/` and all the downstream subprojects in
// `subprojects/`.
//
// This benchmark gives us Mill being about ~3.7x faster than Gradle. This is in line with
// the results above.
//
// === Incremental Compile Single-Module
//
// [source,console]
// ----
// $ echo "" >> src/main/java/org/mockito/BDDMockito.java; time ./gradlew :classes
// 1.37s
// 1.39s
// 1.28s
//
// $ echo "" >> src/main/java/org/mockito/BDDMockito.java; time ./mill compile
// compiling 1 Java source to /Users/lihaoyi/Github/netty/out/common/compile.dest/classes ...
// 0.23s
// 0.20s
// 0.20s
// ----
//
// This benchmark measures the common case of making a tiny change to a single file and
// re-compiling just that module. This is the common workflow that most software developers
// do over and over day-in and day-out. We simulate this by appending a new line to the
// file `src/main/java/org/mockito/BDDMockito.java`.
//
// Both Mill and Gradle are able to take advantage of the small code change and re-compile
// only the single files needing re-compilation, demonstrating substantial speedups over
// the <<Clean Compile Single-Module>> benchmark above. Mill remains faster than Gradle,
// showing a ~2.7x speedup for this task
//
// === No-Op Compile Single-Module
//
// [source,console]
// ----
// $ time ./gradlew :classes
// 0.95s
// 0.93s
// 0.94s
//
// $ time ./mill compile
// 0.13s
// 0.11s
// 0.10s
// ----
//
// This benchmark is meant to measure the pure overhead of running the build tool: given a single
// module that did _not_ change, the build tool should need to do _nothing_ in response, and so
// any time taken is pure overhead.
//
// For both Mill and Gradle, we see small speedups relative to the <<Incremental Compile Single-Module>>
// benchmark above, which likely comes from not having to compile any Java source files at all. Mill
// remains faster than Gradle by about 2.0x.
//
//
// == Extensibility
//
// Another facet of Mill is that is worth exploring is the ease of making custom tasks or build steps.
// For example, in Mill, overriding the resources to duplicate a file can be done as follows:
//
// [source,scala]
// ----
// def resources = Task {
//   os.copy(
//     compile().classes.path / "org/mockito/internal/creation/bytebuddy/inject/MockMethodDispatcher.class",
//     Task.dest / "org/mockito/internal/creation/bytebuddy/inject/MockMethodDispatcher.raw",
//     createFolders = true
//   )
//   super.resources() ++ Seq(PathRef(Task.dest))
// }
// ----
//
// In Gradle, it is written as:
//
// [source,groovy]
// ----
// tasks.register('copyMockMethodDispatcher', Copy) {
//     dependsOn compileJava
//
//     from "${sourceSets.main.java.classesDirectory.get()}/org/mockito/internal/creation/bytebuddy/inject/MockMethodDispatcher.class"
//     into layout.buildDirectory.dir("generated/resources/inline/org/mockito/internal/creation/bytebuddy/inject")
//
//     rename '(.+)\\.class', '$1.raw'
// }
//
// classes.dependsOn("copyMockMethodDispatcher")
//
// sourceSets.main {
//     resources {
//         output.dir(layout.buildDirectory.dir("generated/resources/inline"))
//     }
// }
// ----
//
// At a first glance, both of these snippets do the same thing, just with different syntaxes
// and helper method names. However, on a deeper look, a few things are worth noting:
//
// 1. In Mill, you do not need to manually add `dependsOn` clauses, unlike Gradle:
// * In Mill, referencing the value of `compile()`, we both explicitly get access to the value of `compile`
// and also add a dependency on it. In Gradle, you need to separately add `dependsOn compile`
// to mark the dependency, and `rename '(.+)\\.class', '$1.raw'` to make use of it implicitly.
//
// * In Mill, overriding `def resources` is enough to make all tasks that previously depended on `resources`
// now depend on the override (e.g. `run`, `test`, `jar`, `assembly`, etc.) as is the norm for object-oriented
// ``override``s. In Gradle, you need to explicitly call `classes.dependsOn("copyMockMethodDispatcher")` to
// make the downstream `classes` task depend on `copyMockMethodDispatcher`, and
// `sourcesSets.main resources output.dir` to wire up the generated files to the resources of the module
//
// 2. In Mill, the `resources` task is given a unique `Task.dest` folder that is unique to it.
// In contrast, Gradle's `copyMockMethodDispatcher` puts things in a global `generated/` folder
// * This means that in Mill, you do not need to worry about filesystem collisions, since every
// task's `Task.dest` is unique. In contrast, in Gradle you need to make sure that no other
// task in the entire build is scribbling over `generated/`, otherwise they could interfere
// with one another in confusing ways
//
// * This also means that in Mill, you always know where the output of a particular task
// is - `foo.bar.resources` writes to `out/foo/bar/resources.dest/` - so you can always easily
// find the output of a particular task. In Gradle, you have to dig through the source code to
// find where the task is implemented and see where it is writing to.
//
// 3. Mill passes typed structured ``Path``s and ``PathRef``s between each other, while Gradle often
// uses raw path strings
// * In Mill, `def resources` returns a `PathRef(Task.dest)` for downstream tasks to use,
// so downstream tasks can use it directly (similar to how it makes use of
// `compile().classes.path` directly). This means different tasks can refer to each other
// in a foolproof way without room for error
//
// * In Gradle, `sourcesSets.map resources output.dir` needs to refer to the path generated by
// `copyMockMethodDispatcher` via it's string `"generated/resources/inline"`. That adds a lot of
// room for error, since the strings can easily get out of sync accidentally.
//
// In general, although the two snippets aren't that different superficially, Mill makes it
// easy to do the right thing by default:
//
// * Upstream task dependencies are recorded automatically when used
// * Overridden definitions and automatically used by downstream tasks
// * Every task is automatically assigned a place on disk so you don't need
// to worry about collisions and can easily find outputs
// * Tasks interact with each other via typed structured values - ``Path``s, ``PathRef``s,
// etc. - rather than magic strings
//
// Although in Gradle it is possible for an expert to customize their build in a
// way that mitigates these issues, Mill does it automatically and in a way that
// is foolproof even for non-experts. This helps democratize the build so that
// any engineer can contribute fixes or improvements without needing to be a
// build-system expert and learn all the best practices first.
//
// Lastly, as mentioned earlier, the Gradle script has limited IDE support: it can
// autocomplete things for you, but once you try to jump-to-definition or otherwise
// navigate your build you hit a wall: it tells you some minimal documentation about
// the identifier, but nothing about how it is implemented or where it is used:
//
// image::comparisons/IntellijGradleResourcesClasses.png[]
// image::comparisons/IntellijGradleResourcesClassesDefinition.png[]
//
// In contrast, IntelliJ is able to navigate straight to the definition of `compile()` in the
// Mill build (as we saw earlier in <<_ide_experience>>), and from there can continue to
// traverse the build via _jump to definition_ (which we saw earlier) or _find usages_,
// as we saw earlier:
//
// image::comparisons/IntellijMockitoMillCompile.png[]
// image::comparisons/IntellijMockitoMillCompileClasspath.png[]
// image::comparisons/IntellijMockitoMillCompileUsages.png[]
//
// Mill build scripts are written in Scala, but you do not need to be an expert in Scala
// to use Mill, just like you do not need to be an expert in Groovy to use Gradle. Because
// Mill has great IDE support, and does the right things by default, I hope it would be
// much easier for a non-expert to contribute to a Mill build than it would be for a
// non-expert to contribute to Gradle
//
// == IDE Experience
//
// One area that Mill does better than Gradle is providing a seamless IDE experience. For example,
// consider the snippet below where we are using Gradle to configure the javac compiler options.
// Due to `.gradle` files being untyped Groovy, the autocomplete and code-assist experience working
// with these files is hit-or-miss. In the example below, we can see that IntelliJ is able to identify
// that `compileArgs` exists and has the type `List<String>`:
//
// image::comparisons/IntellijMockitoGradleCompileOptions.png[]
//
// But if you try to jump to definition or find out anything else about it you hit a wall:
//
// image::comparisons/IntellijMockitoGradleCompileOptions2.png[]
//
// Often working with build configurations feels like hitting dead ends: if you don't have
// `options.compilerArgs` memorized in your head, there is literally nothing you can do in your editor to
// make progress to figure out what it is or what it is used for. That leaves you googling
// for answers, which can be a frustrating experience that distracts you from the task at hand.
//
// The fundamental problem with tools like Gradle is that the code you write does not
// actually perform the build: rather, you are just setting up some data structure that
// is used to configure the _real_ build engine that runs later. Thus when you explore
// the Gradle build in an IDE, the IDE can only explore the configuration logic (which
// is usually un-interesting) and is unable to explore the actual build logic (which
// is what you actually care about!)
//
// In comparison, Mill's `.mill` files are all statically typed, and as a result IntelliJ is easily able to
// pull up the documentation for `def javacOptions`, even though it doesn't have any special support
// for Mill built into the IDE:
//
// image::comparisons/IntellijMockitoMillJavacOptionsDocs.png[]
//
// Apart from static typing, the way Mill builds are structured also helps the IDE: Mill
// code _actually performs your build_, rather than configuring some opaque build engine.
// While that sounds academic, one concrete consequence is that IntelliJ is able to take
// your `def javacOptions` override and
// find the original definitions that were overridden, and show you where they are defined:
//
// image::comparisons/IntellijMockitoMillJavacOptionsParents.png[]
//
// image::comparisons/IntellijMockitoMillJavacOptionsDef.png[]
//
// Furthermore, because task dependencies in Mill are just normal method calls, IntelliJ is
// able to _find usages_, showing you where the task is used. Below, we can see the method
// call in the `def compile` task, which uses `javacOptions()` along with a number of other tasks:
//
// image::comparisons/IntellijMockitoMillCompile.png[]
//
// From there, if you are curious about any of the other tasks used alongside `javacOptions`, it's
// easy for you to pull up _their_ documentation, jump to _their_
// definition, or find _their_ usages. For example we can pull up the docs of
// `compileClasspath()` below:
//
// image::comparisons/IntellijMockitoMillCompileClasspath.png[]
//
// Or we can use _find usages_ on `def compile` to see where it is used, both in this build
// and upstream in the Mill libraries:
//
// image::comparisons/IntellijMockitoMillCompileUsages.png[]
//
// Unlike most other build tools, Mill builds are extremely easy to explore interactively in your
// IDE. If you do not know what something does, it's documentation, definition, or usages is always
// one click away in IntelliJ or VSCode. That's not to say Mill builds aren't complex - as
// we saw above, compilation has to deal with upstream outputs, classpaths, flags, reporters, and so on -
// but at least in Mill your IDE can help you explore, understand and manage the complexity in a way
// that no other build tool supports.
//
// Note that the IDE experience that Mill provides should already be very familiar to anyone writing
// Java, Kotlin, or Scala:
//
// * _of course_, you can find the overridden definitions!
// * _of course_, you can pull up the documentation in a click!
// * _of course_, you can navigate around the codebase with your IDE, up and down
//   the call graph, to see who calls who!
//
// What Mill provides isn't rocket science, but rather it is just about taking your existing experience
// and existing IDE tooling working with application codebases, and lets you use it to manage your build
// system as well.
//
// Mill IDE support isn't perfect - you may have noticed the spurious red squigglies above - but it's
// much better than what you get with Gradle.
//
// == Conclusion
//
//
// Both the Mill and Gradle builds we discussed in this case study do the same thing: they
// compile Java code and run tests. Sometimes they perform additional configuration, tweaking
// JVM arguments or doing ad-hoc classpath mangling.
//
// In general, building projects with Mill is significantly faster than Gradle, but the gap
// is not as big as when comparing xref:comparisons/maven.adoc[Mill v.s. Maven]. Mill builds
// do all the same things as gradle builds, and need to manage the same kind of complexity.
// But where Mill shines over Gradle is just the understandability of the build: while Gradle is
// https://news.ycombinator.com/item?id=25801986[famously confusing and opaque], Mill's great
// IDE support allows the user to explore and understand their build as easily as any
// application codebase, and its fool-proof approach to extensibility means non-experts can
// confidently modify or add to their build system without worrying about getting it wrong.
//
// Again, the Mill build used in this comparison is for demonstration purposes, and more
// work would be necessary to make the Mill build production ready: publishing configuration,
// code coverage integration, and so on. Furthermore, Mill is definitely not perfect,
// and it is a work in progress to improve the user experience and iron out bugs. However,
// hopefully this comparison demonstrates the potential value, and convinces you to give it a try!
